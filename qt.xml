This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
base/
  rss/
    feed_serializer.cpp
    feed_serializer.h
    rss_article.cpp
    rss_article.h
    rss_autodownloader.cpp
    rss_autodownloader.h
    rss_autodownloadrule.cpp
    rss_autodownloadrule.h
    rss_feed.cpp
    rss_feed.h
    rss_folder.cpp
    rss_folder.h
    rss_item.cpp
    rss_item.h
    rss_parser.cpp
    rss_parser.h
    rss_session.cpp
    rss_session.h
  search/
    searchdownloadhandler.cpp
    searchdownloadhandler.h
    searchhandler.cpp
    searchhandler.h
    searchpluginmanager.cpp
    searchpluginmanager.h
gui/
  rss/
    articlelistwidget.cpp
    articlelistwidget.h
    automatedrssdownloader.cpp
    automatedrssdownloader.h
    automatedrssdownloader.ui
    feedlistwidget.cpp
    feedlistwidget.h
    htmlbrowser.cpp
    htmlbrowser.h
    rssfeeddialog.cpp
    rssfeeddialog.h
    rssfeeddialog.ui
    rsswidget.cpp
    rsswidget.h
    rsswidget.ui
  search/
    pluginselectdialog.cpp
    pluginselectdialog.h
    pluginselectdialog.ui
    pluginsourcedialog.cpp
    pluginsourcedialog.h
    pluginsourcedialog.ui
    searchjobwidget.cpp
    searchjobwidget.h
    searchjobwidget.ui
    searchsortmodel.cpp
    searchsortmodel.h
    searchwidget.cpp
    searchwidget.h
    searchwidget.ui
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="base/rss/feed_serializer.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2022  Prince Gupta <guptaprince8832@gmail.com>
 * Copyright (C) 2015-2022  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "feed_serializer.h"

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QList>

#include "base/logger.h"
#include "base/path.h"
#include "base/utils/io.h"
#include "rss_article.h"

const int ARTICLEDATALIST_TYPEID = qRegisterMetaType<QList<QVariantHash>>();

void RSS::Private::FeedSerializer::load(const Path &dataFileName, const QString &url)
{
    const auto readResult = Utils::IO::readFile(dataFileName, -1);
    if (!readResult)
    {
        if (readResult.error().status == Utils::IO::ReadError::NotExist)
        {
            emit loadingFinished({});
            return;
        }

        LogMsg(tr("Failed to read RSS session data. %1").arg(readResult.error().message), Log::WARNING);
        return;
    }

    emit loadingFinished(loadArticles(readResult.value(), url));
}

void RSS::Private::FeedSerializer::store(const Path &dataFileName, const QList<QVariantHash> &articlesData)
{
    QJsonArray arr;
    for (const QVariantHash &data : articlesData)
    {
        auto jsonObj = QJsonObject::fromVariantHash(data);
        // JSON object doesn't support DateTime so we need to convert it
        jsonObj[Article::KeyDate] = data[Article::KeyDate].toDateTime().toString(Qt::RFC2822Date);

        arr << jsonObj;
    }

    const nonstd::expected<void, QString> result = Utils::IO::saveToFile(dataFileName, QJsonDocument(arr).toJson(QJsonDocument::Compact));
    if (!result)
    {
       LogMsg(tr("Failed to save RSS feed in '%1', Reason: %2").arg(dataFileName.toString(), result.error())
              , Log::WARNING);
    }
}

QList<QVariantHash> RSS::Private::FeedSerializer::loadArticles(const QByteArray &data, const QString &url)
{
    QJsonParseError jsonError;
    const QJsonDocument jsonDoc = QJsonDocument::fromJson(data, &jsonError);
    if (jsonError.error != QJsonParseError::NoError)
    {
        LogMsg(tr("Couldn't parse RSS Session data. Error: %1").arg(jsonError.errorString())
               , Log::WARNING);
        return {};
    }

    if (!jsonDoc.isArray())
    {
        LogMsg(tr("Couldn't load RSS Session data. Invalid data format."), Log::WARNING);
        return {};
    }

    QList<QVariantHash> result;
    const QJsonArray jsonArr = jsonDoc.array();
    result.reserve(jsonArr.size());
    for (int i = 0; i < jsonArr.size(); ++i)
    {
        const QJsonValue jsonVal = jsonArr[i];
        if (!jsonVal.isObject())
        {
            LogMsg(tr("Couldn't load RSS article '%1#%2'. Invalid data format.")
                   .arg(url, QString::number(i)), Log::WARNING);
            continue;
        }

        const auto jsonObj = jsonVal.toObject();
        auto varHash = jsonObj.toVariantHash();
        // JSON object store DateTime as string so we need to convert it
        varHash[Article::KeyDate] =
                QDateTime::fromString(jsonObj.value(Article::KeyDate).toString(), Qt::RFC2822Date);

        result.push_back(varHash);
    }

    std::sort(result.begin(), result.end(), [](const QVariantHash &left, const QVariantHash &right)
    {
        return (left.value(Article::KeyDate).toDateTime() > right.value(Article::KeyDate).toDateTime());
    });

    return result;
}
</file>

<file path="base/rss/feed_serializer.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2022  Prince Gupta <guptaprince8832@gmail.com>
 * Copyright (C) 2015-2022  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QtContainerFwd>
#include <QObject>
#include <QString>
#include <QVariantHash>

#include "base/pathfwd.h"

namespace RSS::Private
{
    class FeedSerializer final : public QObject
    {
        Q_OBJECT
        Q_DISABLE_COPY_MOVE(FeedSerializer)

    public:
        using QObject::QObject;

        void load(const Path &dataFileName, const QString &url);
        void store(const Path &dataFileName, const QList<QVariantHash> &articlesData);

    signals:
        void loadingFinished(const QList<QVariantHash> &articles);

    private:
        QList<QVariantHash> loadArticles(const QByteArray &data, const QString &url);
    };
}
</file>

<file path="base/rss/rss_article.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "rss_article.h"

#include <QVariant>

#include "base/global.h"
#include "rss_feed.h"

using namespace RSS;

const QString Article::KeyId = u"id"_s;
const QString Article::KeyDate = u"date"_s;
const QString Article::KeyTitle = u"title"_s;
const QString Article::KeyAuthor = u"author"_s;
const QString Article::KeyDescription = u"description"_s;
const QString Article::KeyTorrentURL = u"torrentURL"_s;
const QString Article::KeyLink = u"link"_s;
const QString Article::KeyIsRead = u"isRead"_s;

Article::Article(Feed *feed, const QVariantHash &varHash)
    : QObject(feed)
    , m_feed(feed)
    , m_guid(varHash.value(KeyId).toString())
    , m_date(varHash.value(KeyDate).toDateTime())
    , m_title(varHash.value(KeyTitle).toString())
    , m_author(varHash.value(KeyAuthor).toString())
    , m_description(varHash.value(KeyDescription).toString())
    , m_torrentURL(varHash.value(KeyTorrentURL).toString())
    , m_link(varHash.value(KeyLink).toString())
    , m_isRead(varHash.value(KeyIsRead, false).toBool())
    , m_data(varHash)
{
}

QString Article::guid() const
{
    return m_guid;
}

QDateTime Article::date() const
{
    return m_date;
}

QString Article::title() const
{
    return m_title;
}

QString Article::author() const
{
    return m_author;
}

QString Article::description() const
{
    return m_description;
}

QString Article::torrentUrl() const
{
    return (m_torrentURL.isEmpty() ? m_link : m_torrentURL);
}

QString Article::link() const
{
    return m_link;
}

bool Article::isRead() const
{
    return m_isRead;
}

QVariantHash Article::data() const
{
    return m_data;
}

void Article::markAsRead()
{
    if (!m_isRead)
    {
        m_isRead = true;
        m_data[KeyIsRead] = m_isRead;
        emit read(this);
    }
}

bool Article::articleDateRecentThan(const Article *article, const QDateTime &date)
{
    return article->date() > date;
}

Feed *Article::feed() const
{
    return m_feed;
}
</file>

<file path="base/rss/rss_article.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017-2022  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QDateTime>
#include <QObject>
#include <QString>
#include <QVariantHash>

namespace RSS
{
    class Feed;

    class Article final : public QObject
    {
        Q_OBJECT
        Q_DISABLE_COPY_MOVE(Article)

        friend class Feed;

        Article(Feed *feed, const QVariantHash &varHash);

    public:
        static const QString KeyId;
        static const QString KeyDate;
        static const QString KeyTitle;
        static const QString KeyAuthor;
        static const QString KeyDescription;
        static const QString KeyTorrentURL;
        static const QString KeyLink;
        static const QString KeyIsRead;

        Feed *feed() const;
        QString guid() const;
        QDateTime date() const;
        QString title() const;
        QString author() const;
        QString description() const;
        QString torrentUrl() const;
        QString link() const;
        bool isRead() const;
        QVariantHash data() const;

        void markAsRead();

        static bool articleDateRecentThan(const Article *article, const QDateTime &date);

    signals:
        void read(Article *article = nullptr);

    private:
        Feed *m_feed = nullptr;
        QString m_guid;
        QDateTime m_date;
        QString m_title;
        QString m_author;
        QString m_description;
        QString m_torrentURL;
        QString m_link;
        bool m_isRead = false;
        QVariantHash m_data;
    };
}
</file>

<file path="base/rss/rss_autodownloader.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017-2023  Vladimir Golovnev <glassez@yandex.ru>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "rss_autodownloader.h"

#include <queue>

#include <QDataStream>
#include <QDebug>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonValue>
#include <QList>
#include <QThread>
#include <QTimer>
#include <QUrl>
#include <QVariant>

#include "base/addtorrentmanager.h"
#include "base/asyncfilestorage.h"
#include "base/bittorrent/addtorrenterror.h"
#include "base/bittorrent/session.h"
#include "base/bittorrent/torrentdescriptor.h"
#include "base/global.h"
#include "base/interfaces/iapplication.h"
#include "base/logger.h"
#include "base/profile.h"
#include "base/utils/fs.h"
#include "base/utils/io.h"
#include "rss_article.h"
#include "rss_autodownloadrule.h"
#include "rss_feed.h"
#include "rss_folder.h"
#include "rss_session.h"

struct ProcessingJob
{
    QString feedURL;
    QVariantHash articleData;
};

const QString CONF_FOLDER_NAME = u"rss"_s;
const QString RULES_FILE_NAME = u"download_rules.json"_s;

namespace
{
    QList<RSS::AutoDownloadRule> rulesFromJSON(const QByteArray &jsonData)
    {
        QJsonParseError jsonError;
        const QJsonDocument jsonDoc = QJsonDocument::fromJson(jsonData, &jsonError);
        if (jsonError.error != QJsonParseError::NoError)
            throw RSS::ParsingError(jsonError.errorString());

        if (!jsonDoc.isObject())
            throw RSS::ParsingError(RSS::AutoDownloader::tr("Invalid data format."));

        const QJsonObject jsonObj {jsonDoc.object()};
        QList<RSS::AutoDownloadRule> rules;
        for (auto it = jsonObj.begin(); it != jsonObj.end(); ++it)
        {
            const QJsonValue jsonVal {it.value()};
            if (!jsonVal.isObject())
                throw RSS::ParsingError(RSS::AutoDownloader::tr("Invalid data format."));

            rules.append(RSS::AutoDownloadRule::fromJsonObject(jsonVal.toObject(), it.key()));
        }

        return rules;
    }
}

using namespace RSS;

QPointer<AutoDownloader> AutoDownloader::m_instance = nullptr;

QString computeSmartFilterRegex(const QStringList &filters)
{
    return u"(?:_|\\b)(?:%1)(?:_|\\b)"_s.arg(filters.join(u")|(?:"));
}

AutoDownloader::AutoDownloader(IApplication *app)
    : ApplicationComponent(app)
    , m_storeProcessingEnabled {u"RSS/AutoDownloader/EnableProcessing"_s, false}
    , m_storeSmartEpisodeFilter {u"RSS/AutoDownloader/SmartEpisodeFilter"_s}
    , m_storeDownloadRepacks {u"RSS/AutoDownloader/DownloadRepacks"_s}
    , m_processingTimer {new QTimer(this)}
    , m_ioThread {new QThread}
{
    Q_ASSERT(!m_instance); // only one instance is allowed
    m_instance = this;

    m_fileStorage = new AsyncFileStorage(specialFolderLocation(SpecialFolder::Config) / Path(CONF_FOLDER_NAME));

    m_fileStorage->moveToThread(m_ioThread.get());
    connect(m_ioThread.get(), &QThread::finished, m_fileStorage, &AsyncFileStorage::deleteLater);
    connect(m_fileStorage, &AsyncFileStorage::failed, [](const Path &fileName, const QString &errorString)
    {
        LogMsg(tr("Couldn't save RSS AutoDownloader data in %1. Error: %2")
               .arg(fileName.toString(), errorString), Log::CRITICAL);
    });

    m_ioThread->setObjectName("RSS::AutoDownloader m_ioThread");
    m_ioThread->start();

    connect(app->addTorrentManager(), &AddTorrentManager::torrentAdded
            , this, &AutoDownloader::handleTorrentAdded);
    connect(app->addTorrentManager(), &AddTorrentManager::addTorrentFailed
            , this, &AutoDownloader::handleAddTorrentFailed);

    // initialise the smart episode regex
    const QString regex = computeSmartFilterRegex(smartEpisodeFilters());
    m_smartEpisodeRegex = QRegularExpression(regex
            , QRegularExpression::CaseInsensitiveOption
                    | QRegularExpression::ExtendedPatternSyntaxOption
                    | QRegularExpression::UseUnicodePropertiesOption);

    load();

    connect(Session::instance(), &Session::feedURLChanged, this, &AutoDownloader::handleFeedURLChanged);

    m_processingTimer->setSingleShot(true);
    connect(m_processingTimer, &QTimer::timeout, this, &AutoDownloader::process);

    const auto *btSession = BitTorrent::Session::instance();
    if (btSession->isRestored())
    {
        if (isProcessingEnabled())
            startProcessing();
    }
    else
    {
        connect(btSession, &BitTorrent::Session::restored, this, [this]()
        {
            if (isProcessingEnabled())
                startProcessing();
        });
    }
}

AutoDownloader::~AutoDownloader()
{
    store();
}

AutoDownloader *AutoDownloader::instance()
{
    return m_instance;
}

bool AutoDownloader::hasRule(const QString &ruleName) const
{
    return m_rulesByName.contains(ruleName);
}

AutoDownloadRule AutoDownloader::ruleByName(const QString &ruleName) const
{
    const auto index = m_rulesByName.value(ruleName, -1);
    return m_rules.value(index, AutoDownloadRule(u"Unknown Rule"_s));
}

QList<AutoDownloadRule> AutoDownloader::rules() const
{
    return m_rules;
}

void AutoDownloader::setRule(const AutoDownloadRule &rule)
{
    if (!hasRule(rule.name()))
    {
        // Insert new rule
        setRule_impl(rule);
        sortRules();
        m_dirty = true;
        store();
        emit ruleAdded(rule.name());
        resetProcessingQueue();
    }
    else if (ruleByName(rule.name()) != rule)
    {
        // Update existing rule
        setRule_impl(rule);
        sortRules();
        m_dirty = true;
        storeDeferred();
        emit ruleChanged(rule.name());
        resetProcessingQueue();
    }
}

bool AutoDownloader::renameRule(const QString &ruleName, const QString &newRuleName)
{
    if (!hasRule(ruleName) || hasRule(newRuleName))
        return false;

    const auto index = m_rulesByName.take(ruleName);
    m_rules[index].setName(newRuleName);
    m_rulesByName.insert(newRuleName, index);
    m_dirty = true;
    store();
    emit ruleRenamed(newRuleName, ruleName);
    return true;
}

void AutoDownloader::removeRule(const QString &ruleName)
{
    if (!hasRule(ruleName))
        return;

    emit ruleAboutToBeRemoved(ruleName);

    const auto index = m_rulesByName.take(ruleName);
    m_rules.removeAt(index);
    for (qsizetype i = index; i < m_rules.size(); ++i)
    {
        const AutoDownloadRule &rule = m_rules[i];
        m_rulesByName[rule.name()] = i;
    }

    m_dirty = true;
    store();
}

QByteArray AutoDownloader::exportRules(AutoDownloader::RulesFileFormat format) const
{
    switch (format)
    {
    case RulesFileFormat::Legacy:
        return exportRulesToLegacyFormat();
    default:
        return exportRulesToJSONFormat();
    }
}

void AutoDownloader::importRules(const QByteArray &data, const AutoDownloader::RulesFileFormat format)
{
    switch (format)
    {
    case RulesFileFormat::Legacy:
        importRulesFromLegacyFormat(data);
        break;
    default:
        importRulesFromJSONFormat(data);
    }
}

QByteArray AutoDownloader::exportRulesToJSONFormat() const
{
    QJsonObject jsonObj;
    for (const auto &rule : asConst(rules()))
        jsonObj.insert(rule.name(), rule.toJsonObject());

    return QJsonDocument(jsonObj).toJson();
}

void AutoDownloader::importRulesFromJSONFormat(const QByteArray &data)
{
    for (const auto &rule : asConst(rulesFromJSON(data)))
        setRule(rule);
}

QByteArray AutoDownloader::exportRulesToLegacyFormat() const
{
    QVariantHash dict;
    for (const auto &rule : asConst(rules()))
        dict[rule.name()] = rule.toLegacyDict();

    QByteArray data;
    QDataStream out(&data, QIODevice::WriteOnly);
    out.setVersion(QDataStream::Qt_4_5);
    out << dict;

    return data;
}

void AutoDownloader::importRulesFromLegacyFormat(const QByteArray &data)
{
    QDataStream in(data);
    in.setVersion(QDataStream::Qt_4_5);
    QVariantHash dict;
    in >> dict;
    if (in.status() != QDataStream::Ok)
        throw ParsingError(tr("Invalid data format"));

    for (const QVariant &val : asConst(dict))
        setRule(AutoDownloadRule::fromLegacyDict(val.toHash()));
}

QStringList AutoDownloader::smartEpisodeFilters() const
{
    const QVariant filter = m_storeSmartEpisodeFilter.get();
    if (filter.isNull())
    {
        const QStringList defaultFilters =
        {
            u"s(\\d+)e(\\d+)"_s,                       // Format 1: s01e01
            u"(\\d+)x(\\d+)"_s,                        // Format 2: 01x01
            u"(\\d{4}[.\\-]\\d{1,2}[.\\-]\\d{1,2})"_s, // Format 3: 2017.01.01
            u"(\\d{1,2}[.\\-]\\d{1,2}[.\\-]\\d{4})"_s  // Format 4: 01.01.2017
        };
        return defaultFilters;
    }
    return filter.toStringList();
}

QRegularExpression AutoDownloader::smartEpisodeRegex() const
{
    return m_smartEpisodeRegex;
}

void AutoDownloader::setSmartEpisodeFilters(const QStringList &filters)
{
    m_storeSmartEpisodeFilter = filters;

    const QString regex = computeSmartFilterRegex(filters);
    m_smartEpisodeRegex.setPattern(regex);
}

bool AutoDownloader::downloadRepacks() const
{
    return m_storeDownloadRepacks.get(true);
}

void AutoDownloader::setDownloadRepacks(const bool enabled)
{
    m_storeDownloadRepacks = enabled;
}

void AutoDownloader::process()
{
    if (m_processingQueue.isEmpty()) // processing was disabled
        return;

    processJob(m_processingQueue.takeFirst());
    if (!m_processingQueue.isEmpty())
    {
        // Schedule to process the next torrent (if any)
        m_processingTimer->start();
    }
}

void AutoDownloader::handleTorrentAdded(const QString &source)
{
    const auto job = m_waitingJobs.take(source);
    if (!job)
        return;

    if (Feed *feed = Session::instance()->feedByURL(job->feedURL))
    {
        if (Article *article = feed->articleByGUID(job->articleData.value(Article::KeyId).toString()))
            article->markAsRead();
    }
}

void AutoDownloader::handleAddTorrentFailed(const QString &source, const BitTorrent::AddTorrentError &error)
{
    const auto job = m_waitingJobs.take(source);
    if (!job)
        return;

    if (error.kind == BitTorrent::AddTorrentError::DuplicateTorrent)
    {
        if (Feed *feed = Session::instance()->feedByURL(job->feedURL))
        {
            if (Article *article = feed->articleByGUID(job->articleData.value(Article::KeyId).toString()))
                article->markAsRead();
        }
    }
    else
    {
        // TODO: Re-schedule job here.
    }
}

void AutoDownloader::handleNewArticle(const Article *article)
{
    if (!article->isRead() && !article->torrentUrl().isEmpty())
        addJobForArticle(article);
}

void AutoDownloader::handleFeedURLChanged(Feed *feed, const QString &oldURL)
{
    for (AutoDownloadRule &rule : m_rules)
    {
        if (const auto i = rule.feedURLs().indexOf(oldURL); i >= 0)
        {
            auto feedURLs = rule.feedURLs();
            feedURLs.replace(i, feed->url());
            rule.setFeedURLs(feedURLs);
            m_dirty = true;
        }
    }

    for (const QSharedPointer<ProcessingJob> &job : asConst(m_processingQueue))
    {
        if (job->feedURL == oldURL)
            job->feedURL = feed->url();
    }

    for (const QSharedPointer<ProcessingJob> &job : asConst(m_waitingJobs))
    {
        if (job->feedURL == oldURL)
            job->feedURL = feed->url();
    }

    store();
}

void AutoDownloader::setRule_impl(const AutoDownloadRule &rule)
{
    const QString ruleName = rule.name();
    const auto index = m_rulesByName.value(ruleName, -1);
    if (index < 0)
    {
        m_rules.append(rule);
        m_rulesByName[ruleName] = m_rules.size() - 1;
    }
    else
    {
        m_rules[index] = rule;
    }
}

void AutoDownloader::sortRules()
{
    std::sort(m_rules.begin(), m_rules.end(), [](const AutoDownloadRule &lhs, const AutoDownloadRule &rhs)
    {
        return (lhs.priority() < rhs.priority());
    });

    for (qsizetype i = 0; i < m_rules.size(); ++i)
    {
        const AutoDownloadRule &rule = m_rules[i];
        m_rulesByName[rule.name()] = i;
    }
}

void AutoDownloader::addJobForArticle(const Article *article)
{
    const QString torrentURL = article->torrentUrl();
    if (m_waitingJobs.contains(torrentURL))
        return;

    auto job = QSharedPointer<ProcessingJob>::create();
    job->feedURL = article->feed()->url();
    job->articleData = article->data();
    m_processingQueue.append(job);
    if (!m_processingTimer->isActive())
        m_processingTimer->start();
}

void AutoDownloader::processJob(const QSharedPointer<ProcessingJob> &job)
{
    for (AutoDownloadRule &rule : m_rules)
    {
        if (!rule.isEnabled())
            continue;
        if (!rule.feedURLs().contains(job->feedURL))
            continue;
        if (!rule.accepts(job->articleData))
            continue;

        m_dirty = true;
        storeDeferred();

        LogMsg(tr("RSS article '%1' is accepted by rule '%2'. Trying to add torrent...")
                .arg(job->articleData.value(Article::KeyTitle).toString(), rule.name()));

        const auto torrentURL = job->articleData.value(Article::KeyTorrentURL).toString();
        app()->addTorrentManager()->addTorrent(torrentURL, rule.addTorrentParams());

        if (BitTorrent::TorrentDescriptor::parse(torrentURL))
        {
            if (Feed *feed = Session::instance()->feedByURL(job->feedURL))
            {
                if (Article *article = feed->articleByGUID(job->articleData.value(Article::KeyId).toString()))
                    article->markAsRead();
            }
        }
        else
        {
            // waiting for torrent file downloading
            m_waitingJobs.insert(torrentURL, job);
        }

        return;
    }
}

void AutoDownloader::load()
{
    const qint64 maxFileSize = 10 * 1024 * 1024;
    const auto readResult = Utils::IO::readFile((m_fileStorage->storageDir() / Path(RULES_FILE_NAME)), maxFileSize);
    if (!readResult)
    {
        if (readResult.error().status == Utils::IO::ReadError::NotExist)
        {
            loadRulesLegacy();
            return;
        }

        LogMsg((tr("Failed to read RSS AutoDownloader rules. %1").arg(readResult.error().message)), Log::WARNING);
        return;
    }

    loadRules(readResult.value());
}

void AutoDownloader::loadRules(const QByteArray &data)
{
    try
    {
        const auto rules = rulesFromJSON(data);
        for (const auto &rule : rules)
            setRule_impl(rule);
        sortRules();
    }
    catch (const ParsingError &error)
    {
        LogMsg(tr("Couldn't load RSS AutoDownloader rules. Reason: %1")
                .arg(error.message()), Log::CRITICAL);
    }
}

void AutoDownloader::loadRulesLegacy()
{
    const std::unique_ptr<QSettings> settings = Profile::instance()->applicationSettings(u"qBittorrent-rss"_s);
    const QVariantHash rules = settings->value(u"download_rules"_s).toHash();
    for (const QVariant &ruleVar : rules)
    {
        const auto rule = AutoDownloadRule::fromLegacyDict(ruleVar.toHash());
        if (!rule.name().isEmpty())
            setRule(rule);
    }
}

void AutoDownloader::store()
{
    if (!m_dirty)
        return;

    m_dirty = false;
    m_savingTimer.stop();

    QJsonObject jsonObj;
    for (const auto &rule : asConst(m_rules))
        jsonObj.insert(rule.name(), rule.toJsonObject());

    m_fileStorage->store(Path(RULES_FILE_NAME), QJsonDocument(jsonObj).toJson());
}

void AutoDownloader::storeDeferred()
{
    if (!m_savingTimer.isActive())
        m_savingTimer.start(5 * 1000, this);
}

bool AutoDownloader::isProcessingEnabled() const
{
    return m_storeProcessingEnabled;
}

void AutoDownloader::resetProcessingQueue()
{
    m_processingQueue.clear();
    if (!isProcessingEnabled())
        return;

    for (Article *article : asConst(Session::instance()->rootFolder()->articles()))
    {
        if (!article->isRead() && !article->torrentUrl().isEmpty())
            addJobForArticle(article);
    }
}

void AutoDownloader::startProcessing()
{
    resetProcessingQueue();

    const RSS::Folder *rootFolder = Session::instance()->rootFolder();
    for (const Article *article : asConst(rootFolder->articles()))
        handleNewArticle(article);

    connect(rootFolder, &Folder::newArticle, this, &AutoDownloader::handleNewArticle);
}

void AutoDownloader::setProcessingEnabled(const bool enabled)
{
    if (m_storeProcessingEnabled != enabled)
    {
        m_storeProcessingEnabled = enabled;
        if (enabled)
        {
            if (BitTorrent::Session::instance()->isRestored())
                startProcessing();
        }
        else
        {
            m_processingQueue.clear();
            disconnect(Session::instance()->rootFolder(), &Folder::newArticle, this, &AutoDownloader::handleNewArticle);
        }

        emit processingStateChanged(enabled);
    }
}

void AutoDownloader::timerEvent([[maybe_unused]] QTimerEvent *event)
{
    store();
}
</file>

<file path="base/rss/rss_autodownloader.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017-2023  Vladimir Golovnev <glassez@yandex.ru>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QBasicTimer>
#include <QHash>
#include <QList>
#include <QObject>
#include <QPointer>
#include <QRegularExpression>
#include <QSharedPointer>

#include "base/applicationcomponent.h"
#include "base/exceptions.h"
#include "base/settingvalue.h"
#include "base/utils/thread.h"

class QTimer;

class Application;
class AsyncFileStorage;
struct ProcessingJob;

namespace BitTorrent
{
    struct AddTorrentError;
}

namespace RSS
{
    class Article;
    class Feed;
    class Item;

    class AutoDownloadRule;

    class ParsingError : public RuntimeError
    {
    public:
        using RuntimeError::RuntimeError;
    };

    class AutoDownloader final : public ApplicationComponent<QObject>
    {
        Q_OBJECT
        Q_DISABLE_COPY_MOVE(AutoDownloader)

        friend class ::Application;

        explicit AutoDownloader(IApplication *app);
        ~AutoDownloader() override;

    public:
        enum class RulesFileFormat
        {
            Legacy,
            JSON
        };

        static AutoDownloader *instance();

        bool isProcessingEnabled() const;
        void setProcessingEnabled(bool enabled);

        QStringList smartEpisodeFilters() const;
        void setSmartEpisodeFilters(const QStringList &filters);
        QRegularExpression smartEpisodeRegex() const;

        bool downloadRepacks() const;
        void setDownloadRepacks(bool enabled);

        bool hasRule(const QString &ruleName) const;
        AutoDownloadRule ruleByName(const QString &ruleName) const;
        QList<AutoDownloadRule> rules() const;

        void setRule(const AutoDownloadRule &rule);
        bool renameRule(const QString &ruleName, const QString &newRuleName);
        void removeRule(const QString &ruleName);

        QByteArray exportRules(RulesFileFormat format = RulesFileFormat::JSON) const;
        void importRules(const QByteArray &data, RulesFileFormat format = RulesFileFormat::JSON);

    signals:
        void processingStateChanged(bool enabled);
        void ruleAdded(const QString &ruleName);
        void ruleChanged(const QString &ruleName);
        void ruleRenamed(const QString &ruleName, const QString &oldRuleName);
        void ruleAboutToBeRemoved(const QString &ruleName);

    private slots:
        void process();
        void handleTorrentAdded(const QString &source);
        void handleAddTorrentFailed(const QString &url, const BitTorrent::AddTorrentError &error);
        void handleNewArticle(const Article *article);
        void handleFeedURLChanged(Feed *feed, const QString &oldURL);

    private:
        void timerEvent(QTimerEvent *event) override;
        void setRule_impl(const AutoDownloadRule &rule);
        void sortRules();
        void resetProcessingQueue();
        void startProcessing();
        void addJobForArticle(const Article *article);
        void processJob(const QSharedPointer<ProcessingJob> &job);
        void load();
        void loadRules(const QByteArray &data);
        void loadRulesLegacy();
        void store();
        void storeDeferred();
        QByteArray exportRulesToJSONFormat() const;
        void importRulesFromJSONFormat(const QByteArray &data);
        QByteArray exportRulesToLegacyFormat() const;
        void importRulesFromLegacyFormat(const QByteArray &data);

        static QPointer<AutoDownloader> m_instance;

        CachedSettingValue<bool> m_storeProcessingEnabled;
        SettingValue<QVariant> m_storeSmartEpisodeFilter;
        SettingValue<bool> m_storeDownloadRepacks;

        QTimer *m_processingTimer = nullptr;
        Utils::Thread::UniquePtr m_ioThread;
        AsyncFileStorage *m_fileStorage = nullptr;
        QList<AutoDownloadRule> m_rules;
        QHash<QString, qsizetype> m_rulesByName;
        QList<QSharedPointer<ProcessingJob>> m_processingQueue;
        QHash<QString, QSharedPointer<ProcessingJob>> m_waitingJobs;
        bool m_dirty = false;
        QBasicTimer m_savingTimer;
        QRegularExpression m_smartEpisodeRegex;
    };
}
</file>

<file path="base/rss/rss_autodownloadrule.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017-2023  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "rss_autodownloadrule.h"

#include <algorithm>

#include <QDebug>
#include <QHash>
#include <QJsonArray>
#include <QJsonObject>
#include <QRegularExpression>
#include <QSharedData>
#include <QString>
#include <QStringList>

#include "base/global.h"
#include "base/path.h"
#include "base/preferences.h"
#include "base/utils/fs.h"
#include "base/utils/string.h"
#include "rss_article.h"
#include "rss_autodownloader.h"
#include "rss_feed.h"

namespace
{
    std::optional<bool> toOptionalBool(const QJsonValue &jsonVal)
    {
        if (jsonVal.isBool())
            return jsonVal.toBool();

        return std::nullopt;
    }

    QJsonValue toJsonValue(const std::optional<bool> boolValue)
    {
        return boolValue.has_value() ? *boolValue : QJsonValue {};
    }

    std::optional<bool> addPausedLegacyToOptionalBool(const int val)
    {
        switch (val)
        {
        case 1:
            return true; // always
        case 2:
            return false; // never
        default:
            return std::nullopt; // default
        }
    }

    int toAddPausedLegacy(const std::optional<bool> boolValue)
    {
        if (!boolValue.has_value())
            return 0; // default

        return (*boolValue ? 1 /* always */ : 2 /* never */);
    }

    std::optional<BitTorrent::TorrentContentLayout> jsonValueToContentLayout(const QJsonValue &jsonVal)
    {
        const QString str = jsonVal.toString();
        if (str.isEmpty())
            return std::nullopt;
        return Utils::String::toEnum(str, BitTorrent::TorrentContentLayout::Original);
    }

    QJsonValue contentLayoutToJsonValue(const std::optional<BitTorrent::TorrentContentLayout> contentLayout)
    {
        if (!contentLayout)
            return {};
        return Utils::String::fromEnum(*contentLayout);
    }
}

const QString S_NAME = u"name"_s;
const QString S_ENABLED = u"enabled"_s;
const QString S_PRIORITY = u"priority"_s;
const QString S_USE_REGEX = u"useRegex"_s;
const QString S_MUST_CONTAIN = u"mustContain"_s;
const QString S_MUST_NOT_CONTAIN = u"mustNotContain"_s;
const QString S_EPISODE_FILTER = u"episodeFilter"_s;
const QString S_AFFECTED_FEEDS = u"affectedFeeds"_s;
const QString S_LAST_MATCH = u"lastMatch"_s;
const QString S_IGNORE_DAYS = u"ignoreDays"_s;
const QString S_SMART_FILTER = u"smartFilter"_s;
const QString S_PREVIOUSLY_MATCHED = u"previouslyMatchedEpisodes"_s;

const QString S_SAVE_PATH = u"savePath"_s;
const QString S_ASSIGNED_CATEGORY = u"assignedCategory"_s;
const QString S_ADD_PAUSED = u"addPaused"_s;
const QString S_CONTENT_LAYOUT = u"torrentContentLayout"_s;

const QString S_TORRENT_PARAMS = u"torrentParams"_s;

namespace RSS
{
    struct AutoDownloadRuleData : public QSharedData
    {
        QString name;
        bool enabled = true;
        int priority = 0;

        QStringList mustContain;
        QStringList mustNotContain;
        QString episodeFilter;
        QStringList feedURLs;
        bool useRegex = false;
        int ignoreDays = 0;
        QDateTime lastMatch;

        BitTorrent::AddTorrentParams addTorrentParams;

        bool smartFilter = false;
        QStringList previouslyMatchedEpisodes;

        mutable QStringList lastComputedEpisodes;
        mutable QHash<QString, QRegularExpression> cachedRegexes;

        friend bool operator==(const AutoDownloadRuleData &left, const AutoDownloadRuleData &right)
        {
            return (left.name == right.name)
                    && (left.enabled == right.enabled)
                    && (left.priority == right.priority)
                    && (left.mustContain == right.mustContain)
                    && (left.mustNotContain == right.mustNotContain)
                    && (left.episodeFilter == right.episodeFilter)
                    && (left.feedURLs == right.feedURLs)
                    && (left.useRegex == right.useRegex)
                    && (left.ignoreDays == right.ignoreDays)
                    && (left.lastMatch == right.lastMatch)
                    && (left.smartFilter == right.smartFilter)
                    && (left.addTorrentParams == right.addTorrentParams);
        }
    };

    bool operator==(const AutoDownloadRule &left, const AutoDownloadRule &right)
    {
        return (left.m_dataPtr == right.m_dataPtr) // optimization
                || (*(left.m_dataPtr) == *(right.m_dataPtr));
    }
}

using namespace RSS;

QString computeEpisodeName(const QString &article)
{
    const QRegularExpression episodeRegex = AutoDownloader::instance()->smartEpisodeRegex();
    const QRegularExpressionMatch match = episodeRegex.match(article);

    // See if we can extract an season/episode number or date from the title
    if (!match.hasMatch())
        return {};

    QStringList ret;
    for (int i = 1; i <= match.lastCapturedIndex(); ++i)
    {
        const QString cap = match.captured(i);
        if (cap.isEmpty())
            continue;

        ret.append(cap);
    }
    return ret.join(u'x');
}

AutoDownloadRule::AutoDownloadRule(const QString &name)
    : m_dataPtr(new AutoDownloadRuleData)
{
    setName(name);
}

AutoDownloadRule::AutoDownloadRule(const AutoDownloadRule &other) = default;

AutoDownloadRule::~AutoDownloadRule() = default;

QRegularExpression AutoDownloadRule::cachedRegex(const QString &expression, const bool isRegex) const
{
    // Use a cache of regexes so we don't have to continually recompile - big performance increase.
    // The cache is cleared whenever the regex/wildcard, must or must not contain fields or
    // episode filter are modified.
    Q_ASSERT(!expression.isEmpty());

    QRegularExpression &regex = m_dataPtr->cachedRegexes[expression];
    if (regex.pattern().isEmpty())
    {
        const QString pattern = (isRegex ? expression : Utils::String::wildcardToRegexPattern(expression));
        regex = QRegularExpression {pattern, QRegularExpression::CaseInsensitiveOption};
    }

    return regex;
}

bool AutoDownloadRule::matchesExpression(const QString &articleTitle, const QString &expression) const
{
    const QRegularExpression whitespace {u"\\s+"_s};

    if (expression.isEmpty())
    {
        // A regex of the form "expr|" will always match, so do the same for wildcards
        return true;
    }

    if (m_dataPtr->useRegex)
    {
        const QRegularExpression reg(cachedRegex(expression));
        return reg.match(articleTitle).hasMatch();
    }

    // Only match if every wildcard token (separated by spaces) is present in the article name.
    // Order of wildcard tokens is unimportant (if order is important, they should have used *).
    const QStringList wildcards {expression.split(whitespace, Qt::SkipEmptyParts)};
    for (const QString &wildcard : wildcards)
    {
        const QRegularExpression reg {cachedRegex(wildcard, false)};
        if (!reg.match(articleTitle).hasMatch())
            return false;
    }

    return true;
}

bool AutoDownloadRule::matchesMustContainExpression(const QString &articleTitle) const
{
    if (m_dataPtr->mustContain.empty())
        return true;

    // Each expression is either a regex, or a set of wildcards separated by whitespace.
    // Accept if any complete expression matches.
    return std::any_of(m_dataPtr->mustContain.cbegin(), m_dataPtr->mustContain.cend(), [this, &articleTitle](const QString &expression)
    {
        // A regex of the form "expr|" will always match, so do the same for wildcards
        return matchesExpression(articleTitle, expression);
    });
}

bool AutoDownloadRule::matchesMustNotContainExpression(const QString &articleTitle) const
{
    if (m_dataPtr->mustNotContain.empty())
        return true;

    // Each expression is either a regex, or a set of wildcards separated by whitespace.
    // Reject if any complete expression matches.
    return std::none_of(m_dataPtr->mustNotContain.cbegin(), m_dataPtr->mustNotContain.cend(), [this, &articleTitle](const QString &expression)
    {
        // A regex of the form "expr|" will always match, so do the same for wildcards
        return matchesExpression(articleTitle, expression);
    });
}

bool AutoDownloadRule::matchesEpisodeFilterExpression(const QString &articleTitle) const
{
    // Reset the lastComputedEpisode, we don't want to leak it between matches
    m_dataPtr->lastComputedEpisodes.clear();

    if (m_dataPtr->episodeFilter.isEmpty())
        return true;

    const QRegularExpression filterRegex {cachedRegex(u"(^\\d{1,4})x(.*;$)"_s)};
    const QRegularExpressionMatch matcher {filterRegex.match(m_dataPtr->episodeFilter)};
    if (!matcher.hasMatch())
        return false;

    const QStringView season {matcher.capturedView(1)};
    const QList<QStringView> episodes {matcher.capturedView(2).split(u';')};
    const int seasonOurs {season.toInt()};

    for (QStringView episode : episodes)
    {
        if (episode.isEmpty())
            continue;

        // We need to trim leading zeroes, but if it's all zeros then we want episode zero.
        while ((episode.size() > 1) && episode.startsWith(u'0'))
        {
#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
            episode.slice(1);
#else
            episode = episode.sliced(1);
#endif
        }

        if (episode.contains(u'-'))
        { // Range detected
            const QString partialPattern1 {u"\\bs0?(\\d{1,4})[ -_\\.]?e(0?\\d{1,4})(?:\\D|\\b)"_s};
            const QString partialPattern2 {u"\\b(\\d{1,4})x(0?\\d{1,4})(?:\\D|\\b)"_s};

            // Extract partial match from article and compare as digits
            QRegularExpressionMatch matcher = cachedRegex(partialPattern1).match(articleTitle);
            bool matched = matcher.hasMatch();

            if (!matched)
            {
                matcher = cachedRegex(partialPattern2).match(articleTitle);
                matched = matcher.hasMatch();
            }

            if (matched)
            {
                const int seasonTheirs {matcher.capturedView(1).toInt()};
                const int episodeTheirs {matcher.capturedView(2).toInt()};

                if (episode.endsWith(u'-'))
                { // Infinite range
                    const int episodeOurs {QStringView(episode).chopped(1).toInt()};
                    if (((seasonTheirs == seasonOurs) && (episodeTheirs >= episodeOurs)) || (seasonTheirs > seasonOurs))
                        return true;
                }
                else
                { // Normal range
                    const QList<QStringView> range {episode.split(u'-')};
                    Q_ASSERT(range.size() == 2);

                    const int episodeOursFirst {range.first().toInt()};
                    const int episodeOursLast {range.last().toInt()};
                    if (episodeOursFirst > episodeOursLast)
                        continue; // Ignore this subrule completely

                    if ((seasonTheirs == seasonOurs) && ((episodeOursFirst <= episodeTheirs) && (episodeOursLast >= episodeTheirs)))
                        return true;
                }
            }
        }
        else
        { // Single number
            const QString expStr {u"\\b(?:s0?%1[ -_\\.]?e0?%2|%1x0?%2)(?:\\D|\\b)"_s.arg(season, episode)};
            if (cachedRegex(expStr).match(articleTitle).hasMatch())
                return true;
        }
    }

    return false;
}

bool AutoDownloadRule::matchesSmartEpisodeFilter(const QString &articleTitle) const
{
    if (!useSmartFilter())
        return true;

    const QString episodeStr = computeEpisodeName(articleTitle);
    if (episodeStr.isEmpty())
        return true;

    // See if this episode has been downloaded before
    const bool previouslyMatched = m_dataPtr->previouslyMatchedEpisodes.contains(episodeStr);
    if (previouslyMatched)
    {
        if (!AutoDownloader::instance()->downloadRepacks())
            return false;

        // Now see if we've downloaded this particular repack/proper combination
        const bool isRepack = articleTitle.contains(u"REPACK", Qt::CaseInsensitive);
        const bool isProper = articleTitle.contains(u"PROPER", Qt::CaseInsensitive);

        if (!isRepack && !isProper)
            return false;

        const QString fullEpisodeStr = u"%1%2%3"_s.arg(episodeStr,
                                                        isRepack ? u"-REPACK" : u"",
                                                        isProper ? u"-PROPER" : u"");
        const bool previouslyMatchedFull = m_dataPtr->previouslyMatchedEpisodes.contains(fullEpisodeStr);
        if (previouslyMatchedFull)
            return false;

        m_dataPtr->lastComputedEpisodes.append(fullEpisodeStr);

        // If this is a REPACK and PROPER download, add the individual entries to the list
        // so we don't download those
        if (isRepack && isProper)
        {
            m_dataPtr->lastComputedEpisodes.append(episodeStr + u"-REPACK");
            m_dataPtr->lastComputedEpisodes.append(episodeStr + u"-PROPER");
        }

        return true;
    }

    m_dataPtr->lastComputedEpisodes.append(episodeStr);
    return true;
}

bool AutoDownloadRule::matches(const QVariantHash &articleData) const
{
    const QDateTime articleDate {articleData[Article::KeyDate].toDateTime()};
    if (ignoreDays() > 0)
    {
        if (lastMatch().isValid() && (articleDate < lastMatch().addDays(ignoreDays())))
            return false;
    }

    const QString articleTitle {articleData[Article::KeyTitle].toString()};
    if (!matchesMustContainExpression(articleTitle))
        return false;
    if (!matchesMustNotContainExpression(articleTitle))
        return false;
    if (!matchesEpisodeFilterExpression(articleTitle))
        return false;
    if (!matchesSmartEpisodeFilter(articleTitle))
        return false;

    return true;
}

bool AutoDownloadRule::accepts(const QVariantHash &articleData)
{
    if (!matches(articleData))
        return false;

    setLastMatch(articleData[Article::KeyDate].toDateTime());

    // If there's a matched episode string, add that to the previously matched list
    if (!m_dataPtr->lastComputedEpisodes.isEmpty())
    {
        m_dataPtr->previouslyMatchedEpisodes.append(m_dataPtr->lastComputedEpisodes);
        m_dataPtr->lastComputedEpisodes.clear();
    }

    return true;
}

AutoDownloadRule &AutoDownloadRule::operator=(const AutoDownloadRule &other)
{
    if (this != &other)
    {
        m_dataPtr = other.m_dataPtr;
    }
    return *this;
}

QJsonObject AutoDownloadRule::toJsonObject() const
{
    const BitTorrent::AddTorrentParams &addTorrentParams = m_dataPtr->addTorrentParams;

    return {{S_ENABLED, isEnabled()}
        , {S_PRIORITY, priority()}
        , {S_USE_REGEX, useRegex()}
        , {S_MUST_CONTAIN, mustContain()}
        , {S_MUST_NOT_CONTAIN, mustNotContain()}
        , {S_EPISODE_FILTER, episodeFilter()}
        , {S_AFFECTED_FEEDS, QJsonArray::fromStringList(feedURLs())}
        , {S_LAST_MATCH, lastMatch().toString(Qt::RFC2822Date)}
        , {S_IGNORE_DAYS, ignoreDays()}
        , {S_SMART_FILTER, useSmartFilter()}
        , {S_PREVIOUSLY_MATCHED, QJsonArray::fromStringList(previouslyMatchedEpisodes())}

        // TODO: The following code is deprecated. Replace with the commented one after several releases in 4.6.x.
        // === BEGIN DEPRECATED CODE === //
        , {S_ADD_PAUSED, toJsonValue(addTorrentParams.addStopped)}
        , {S_CONTENT_LAYOUT, contentLayoutToJsonValue(addTorrentParams.contentLayout)}
        , {S_SAVE_PATH, addTorrentParams.savePath.toString()}
        , {S_ASSIGNED_CATEGORY, addTorrentParams.category}
        // === END DEPRECATED CODE === //

        , {S_TORRENT_PARAMS, BitTorrent::serializeAddTorrentParams(addTorrentParams)}
    };
}

AutoDownloadRule AutoDownloadRule::fromJsonObject(const QJsonObject &jsonObj, const QString &name)
{
    AutoDownloadRule rule {(name.isEmpty() ? jsonObj.value(S_NAME).toString() : name)};

    rule.setEnabled(jsonObj.value(S_ENABLED).toBool(true));
    rule.setPriority(jsonObj.value(S_PRIORITY).toInt(0));

    rule.setUseRegex(jsonObj.value(S_USE_REGEX).toBool(false));
    rule.setMustContain(jsonObj.value(S_MUST_CONTAIN).toString());
    rule.setMustNotContain(jsonObj.value(S_MUST_NOT_CONTAIN).toString());
    rule.setEpisodeFilter(jsonObj.value(S_EPISODE_FILTER).toString());
    rule.setLastMatch(QDateTime::fromString(jsonObj.value(S_LAST_MATCH).toString(), Qt::RFC2822Date));
    rule.setIgnoreDays(jsonObj.value(S_IGNORE_DAYS).toInt());
    rule.setUseSmartFilter(jsonObj.value(S_SMART_FILTER).toBool(false));

    const QJsonValue feedsVal = jsonObj.value(S_AFFECTED_FEEDS);
    QStringList feedURLs;
    if (feedsVal.isString())
        feedURLs << feedsVal.toString();
    else for (const QJsonValue &urlVal : asConst(feedsVal.toArray()))
        feedURLs << urlVal.toString();
    rule.setFeedURLs(feedURLs);

    const QJsonValue previouslyMatchedVal = jsonObj.value(S_PREVIOUSLY_MATCHED);
    QStringList previouslyMatched;
    if (previouslyMatchedVal.isString())
    {
        previouslyMatched << previouslyMatchedVal.toString();
    }
    else
    {
        for (const QJsonValue &val : asConst(previouslyMatchedVal.toArray()))
            previouslyMatched << val.toString();
    }
    rule.setPreviouslyMatchedEpisodes(previouslyMatched);

    // TODO: The following code is deprecated. Replace with the commented one after several releases in 4.6.x.
    // === BEGIN DEPRECATED CODE === //
    BitTorrent::AddTorrentParams addTorrentParams;
    if (auto it = jsonObj.find(S_TORRENT_PARAMS); it != jsonObj.end())
    {
        addTorrentParams = BitTorrent::parseAddTorrentParams(it->toObject());
    }
    else
    {
        addTorrentParams.savePath = Path(jsonObj.value(S_SAVE_PATH).toString());
        addTorrentParams.category = jsonObj.value(S_ASSIGNED_CATEGORY).toString();
        addTorrentParams.addStopped = toOptionalBool(jsonObj.value(S_ADD_PAUSED));
        if (!addTorrentParams.savePath.isEmpty())
            addTorrentParams.useAutoTMM = false;

        if (jsonObj.contains(S_CONTENT_LAYOUT))
        {
            addTorrentParams.contentLayout = jsonValueToContentLayout(jsonObj.value(S_CONTENT_LAYOUT));
        }
        else
        {
            const std::optional<bool> createSubfolder = toOptionalBool(jsonObj.value(u"createSubfolder"));
            std::optional<BitTorrent::TorrentContentLayout> contentLayout;
            if (createSubfolder.has_value())
            {
                contentLayout = (*createSubfolder
                        ? BitTorrent::TorrentContentLayout::Original
                        : BitTorrent::TorrentContentLayout::NoSubfolder);
            }

            addTorrentParams.contentLayout = contentLayout;
        }
    }
    rule.setAddTorrentParams(addTorrentParams);
    // === END DEPRECATED CODE === //
    // === BEGIN REPLACEMENT CODE === //
    //    rule.setAddTorrentParams(BitTorrent::parseAddTorrentParams(jsonObj.value(S_TORRENT_PARAMS).object()));
    // === END REPLACEMENT CODE === //

    return rule;
}

QVariantHash AutoDownloadRule::toLegacyDict() const
{
    const BitTorrent::AddTorrentParams &addTorrentParams = m_dataPtr->addTorrentParams;

    return {{u"name"_s, name()},
        {u"must_contain"_s, mustContain()},
        {u"must_not_contain"_s, mustNotContain()},
        {u"save_path"_s, addTorrentParams.savePath.toString()},
        {u"affected_feeds"_s, feedURLs()},
        {u"enabled"_s, isEnabled()},
        {u"category_assigned"_s, addTorrentParams.category},
        {u"use_regex"_s, useRegex()},
        {u"add_paused"_s, toAddPausedLegacy(addTorrentParams.addStopped)},
        {u"episode_filter"_s, episodeFilter()},
        {u"last_match"_s, lastMatch()},
        {u"ignore_days"_s, ignoreDays()}};
}

AutoDownloadRule AutoDownloadRule::fromLegacyDict(const QVariantHash &dict)
{
    BitTorrent::AddTorrentParams addTorrentParams;
    addTorrentParams.savePath = Path(dict.value(u"save_path"_s).toString());
    addTorrentParams.category = dict.value(u"category_assigned"_s).toString();
    addTorrentParams.addStopped = addPausedLegacyToOptionalBool(dict.value(u"add_paused"_s).toInt());
    if (!addTorrentParams.savePath.isEmpty())
        addTorrentParams.useAutoTMM = false;

    AutoDownloadRule rule {dict.value(u"name"_s).toString()};

    rule.setUseRegex(dict.value(u"use_regex"_s, false).toBool());
    rule.setMustContain(dict.value(u"must_contain"_s).toString());
    rule.setMustNotContain(dict.value(u"must_not_contain"_s).toString());
    rule.setEpisodeFilter(dict.value(u"episode_filter"_s).toString());
    rule.setFeedURLs(dict.value(u"affected_feeds"_s).toStringList());
    rule.setEnabled(dict.value(u"enabled"_s, false).toBool());
    rule.setLastMatch(dict.value(u"last_match"_s).toDateTime());
    rule.setIgnoreDays(dict.value(u"ignore_days"_s).toInt());
    rule.setAddTorrentParams(addTorrentParams);

    return rule;
}

void AutoDownloadRule::setMustContain(const QString &tokens)
{
    m_dataPtr->cachedRegexes.clear();

    if (m_dataPtr->useRegex)
        m_dataPtr->mustContain = QStringList() << tokens;
    else
        m_dataPtr->mustContain = tokens.split(u'|');

    // Check for single empty string - if so, no condition
    if ((m_dataPtr->mustContain.size() == 1) && m_dataPtr->mustContain[0].isEmpty())
        m_dataPtr->mustContain.clear();
}

void AutoDownloadRule::setMustNotContain(const QString &tokens)
{
    m_dataPtr->cachedRegexes.clear();

    if (m_dataPtr->useRegex)
        m_dataPtr->mustNotContain = QStringList() << tokens;
    else
        m_dataPtr->mustNotContain = tokens.split(u'|');

    // Check for single empty string - if so, no condition
    if ((m_dataPtr->mustNotContain.size() == 1) && m_dataPtr->mustNotContain[0].isEmpty())
        m_dataPtr->mustNotContain.clear();
}

QStringList AutoDownloadRule::feedURLs() const
{
    return m_dataPtr->feedURLs;
}

void AutoDownloadRule::setFeedURLs(const QStringList &urls)
{
    m_dataPtr->feedURLs = urls;
}

QString AutoDownloadRule::name() const
{
    return m_dataPtr->name;
}

void AutoDownloadRule::setName(const QString &name)
{
    m_dataPtr->name = name;
}

BitTorrent::AddTorrentParams AutoDownloadRule::addTorrentParams() const
{
    return m_dataPtr->addTorrentParams;
}

void AutoDownloadRule::setAddTorrentParams(BitTorrent::AddTorrentParams addTorrentParams)
{
    m_dataPtr->addTorrentParams = std::move(addTorrentParams);
}

bool AutoDownloadRule::isEnabled() const
{
    return m_dataPtr->enabled;
}

void AutoDownloadRule::setEnabled(const bool enable)
{
    m_dataPtr->enabled = enable;
}

int AutoDownloadRule::priority() const
{
    return m_dataPtr->priority;
}

void AutoDownloadRule::setPriority(const int value)
{
    m_dataPtr->priority = value;
}

QDateTime AutoDownloadRule::lastMatch() const
{
    return m_dataPtr->lastMatch;
}

void AutoDownloadRule::setLastMatch(const QDateTime &lastMatch)
{
    m_dataPtr->lastMatch = lastMatch;
}

void AutoDownloadRule::setIgnoreDays(const int d)
{
    m_dataPtr->ignoreDays = d;
}

int AutoDownloadRule::ignoreDays() const
{
    return m_dataPtr->ignoreDays;
}

QString AutoDownloadRule::mustContain() const
{
    return m_dataPtr->mustContain.join(u'|');
}

QString AutoDownloadRule::mustNotContain() const
{
    return m_dataPtr->mustNotContain.join(u'|');
}

bool AutoDownloadRule::useSmartFilter() const
{
    return m_dataPtr->smartFilter;
}

void AutoDownloadRule::setUseSmartFilter(const bool enabled)
{
    m_dataPtr->smartFilter = enabled;
}

bool AutoDownloadRule::useRegex() const
{
    return m_dataPtr->useRegex;
}

void AutoDownloadRule::setUseRegex(const bool enabled)
{
    m_dataPtr->useRegex = enabled;
    m_dataPtr->cachedRegexes.clear();
}

QStringList AutoDownloadRule::previouslyMatchedEpisodes() const
{
    return m_dataPtr->previouslyMatchedEpisodes;
}

void AutoDownloadRule::setPreviouslyMatchedEpisodes(const QStringList &previouslyMatchedEpisodes)
{
    m_dataPtr->previouslyMatchedEpisodes = previouslyMatchedEpisodes;
}

QString AutoDownloadRule::episodeFilter() const
{
    return m_dataPtr->episodeFilter;
}

void AutoDownloadRule::setEpisodeFilter(const QString &e)
{
    m_dataPtr->episodeFilter = e;
    m_dataPtr->cachedRegexes.clear();
}
</file>

<file path="base/rss/rss_autodownloadrule.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017-2023  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <optional>

#include <QSharedDataPointer>
#include <QVariant>

#include "base/global.h"
#include "base/bittorrent/addtorrentparams.h"
#include "base/pathfwd.h"

class QDateTime;
class QJsonObject;
class QRegularExpression;

namespace RSS
{
    struct AutoDownloadRuleData;

    class AutoDownloadRule
    {
    public:
        explicit AutoDownloadRule(const QString &name = {});
        AutoDownloadRule(const AutoDownloadRule &other);
        ~AutoDownloadRule();

        AutoDownloadRule &operator=(const AutoDownloadRule &other);

        QString name() const;
        void setName(const QString &name);

        bool isEnabled() const;
        void setEnabled(bool enable);

        int priority() const;
        void setPriority(int value);

        QString mustContain() const;
        void setMustContain(const QString &tokens);
        QString mustNotContain() const;
        void setMustNotContain(const QString &tokens);
        QStringList feedURLs() const;
        void setFeedURLs(const QStringList &urls);
        int ignoreDays() const;
        void setIgnoreDays(int d);
        QDateTime lastMatch() const;
        void setLastMatch(const QDateTime &lastMatch);
        bool useRegex() const;
        void setUseRegex(bool enabled);
        bool useSmartFilter() const;
        void setUseSmartFilter(bool enabled);
        QString episodeFilter() const;
        void setEpisodeFilter(const QString &e);

        QStringList previouslyMatchedEpisodes() const;
        void setPreviouslyMatchedEpisodes(const QStringList &previouslyMatchedEpisodes);

        BitTorrent::AddTorrentParams addTorrentParams() const;
        void setAddTorrentParams(BitTorrent::AddTorrentParams addTorrentParams);

        bool matches(const QVariantHash &articleData) const;
        bool accepts(const QVariantHash &articleData);

        friend bool operator==(const AutoDownloadRule &left, const AutoDownloadRule &right);

        QJsonObject toJsonObject() const;
        static AutoDownloadRule fromJsonObject(const QJsonObject &jsonObj, const QString &name = {});

        QVariantHash toLegacyDict() const;
        static AutoDownloadRule fromLegacyDict(const QVariantHash &dict);

    private:
        bool matchesMustContainExpression(const QString &articleTitle) const;
        bool matchesMustNotContainExpression(const QString &articleTitle) const;
        bool matchesEpisodeFilterExpression(const QString &articleTitle) const;
        bool matchesSmartEpisodeFilter(const QString &articleTitle) const;
        bool matchesExpression(const QString &articleTitle, const QString &expression) const;
        QRegularExpression cachedRegex(const QString &expression, bool isRegex = true) const;

        QSharedDataPointer<AutoDownloadRuleData> m_dataPtr;
    };
}
</file>

<file path="base/rss/rss_feed.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015-2025  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2024  Jonathan Ketchker
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "rss_feed.h"

#include <algorithm>
#include <utility>
#include <vector>

#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonValue>
#include <QList>
#include <QUrl>

#include "base/asyncfilestorage.h"
#include "base/global.h"
#include "base/logger.h"
#include "base/net/downloadmanager.h"
#include "base/preferences.h"
#include "base/profile.h"
#include "base/utils/fs.h"
#include "feed_serializer.h"
#include "rss_article.h"
#include "rss_parser.h"
#include "rss_session.h"

const QString KEY_UID = u"uid"_s;
const QString KEY_URL = u"url"_s;
const QString KEY_REFRESHINTERVAL = u"refreshInterval"_s;
const QString KEY_TITLE = u"title"_s;
const QString KEY_LASTBUILDDATE = u"lastBuildDate"_s;
const QString KEY_ISLOADING = u"isLoading"_s;
const QString KEY_HASERROR = u"hasError"_s;
const QString KEY_ARTICLES = u"articles"_s;

using namespace std::chrono_literals;
using namespace RSS;

Feed::Feed(Session *session, const QUuid &uid, const QString &url, const QString &path, const std::chrono::seconds refreshInterval)
    : Item(path)
    , m_session {session}
    , m_uid {uid}
    , m_url {url}
    , m_refreshInterval {refreshInterval}
{
    const auto uidHex = QString::fromLatin1(m_uid.toRfc4122().toHex());
    m_dataFileName = Path(uidHex + u".json");

    // Move to new file naming scheme (since v4.1.2)
    const QString legacyFilename = Utils::Fs::toValidFileName(m_url, u"_"_s) + u".json";
    const Path storageDir = m_session->dataFileStorage()->storageDir();
    const Path dataFilePath = storageDir / m_dataFileName;
    if (!dataFilePath.exists())
        Utils::Fs::renameFile((storageDir / Path(legacyFilename)), dataFilePath);

    m_iconPath = storageDir / Path(uidHex + u".ico");

    m_serializer = new Private::FeedSerializer;
    m_serializer->moveToThread(m_session->workingThread());
    connect(this, &Feed::destroyed, m_serializer, &Private::FeedSerializer::deleteLater);
    connect(m_serializer, &Private::FeedSerializer::loadingFinished, this, &Feed::handleArticleLoadFinished);

    m_parser = new Private::Parser(m_lastBuildDate);
    m_parser->moveToThread(m_session->workingThread());
    connect(this, &Feed::destroyed, m_parser, &Private::Parser::deleteLater);
    connect(m_parser, &Private::Parser::finished, this, &Feed::handleParsingFinished);

    connect(m_session, &Session::maxArticlesPerFeedChanged, this, &Feed::handleMaxArticlesPerFeedChanged);

    if (m_session->isProcessingEnabled())
        downloadIcon();
    else
        connect(m_session, &Session::processingStateChanged, this, &Feed::handleSessionProcessingEnabledChanged);

    Net::DownloadManager::instance()->registerSequentialService(Net::ServiceID::fromURL(m_url), m_session->fetchDelay());

    load();
}

Feed::~Feed()
{
    store();
    emit aboutToBeDestroyed(this);
}

QList<Article *> Feed::articles() const
{
    return m_articlesByDate;
}

void Feed::markAsRead()
{
    const int oldUnreadCount = m_unreadCount;
    for (Article *article : asConst(m_articles))
    {
        if (!article->isRead())
        {
            article->disconnect(this);
            article->markAsRead();
            --m_unreadCount;
            emit articleRead(article);
        }
    }

    if (m_unreadCount != oldUnreadCount)
    {
        m_dirty = true;
        store();
        emit unreadCountChanged(this);
    }
}

void Feed::refresh()
{
    if (!m_isInitialized)
    {
        m_pendingRefresh = true;
        return;
    }

    if (m_downloadHandler)
        m_downloadHandler->cancel();

    // NOTE: Should we allow manually refreshing for disabled session?

    m_downloadHandler = Net::DownloadManager::instance()->download(m_url, Preferences::instance()->useProxyForRSS());
    connect(m_downloadHandler, &Net::DownloadHandler::finished, this, &Feed::handleDownloadFinished);

    if (!m_iconPath.exists())
        downloadIcon();

    m_isLoading = true;
    emit stateChanged(this);
}

void Feed::updateFetchDelay()
{
    // Update delay values for registered sequential services
    Net::DownloadManager::instance()->registerSequentialService(Net::ServiceID::fromURL(m_url), m_session->fetchDelay());
}

QUuid Feed::uid() const
{
    return m_uid;
}

QString Feed::url() const
{
    return m_url;
}

QString Feed::title() const
{
    return m_title;
}

bool Feed::isLoading() const
{
    return m_isLoading || !m_isInitialized;
}

QString Feed::lastBuildDate() const
{
    return m_lastBuildDate;
}

int Feed::unreadCount() const
{
    return m_unreadCount;
}

Article *Feed::articleByGUID(const QString &guid) const
{
    return m_articles.value(guid);
}

void Feed::handleMaxArticlesPerFeedChanged(const int n)
{
    while (m_articlesByDate.size() > n)
        removeOldestArticle();
    // We don't need store articles here
}

void Feed::handleIconDownloadFinished(const Net::DownloadResult &result)
{
    if (result.status == Net::DownloadStatus::Success)
    {
        emit iconLoaded(this);
    }
}

bool Feed::hasError() const
{
    return m_hasError;
}

void Feed::handleDownloadFinished(const Net::DownloadResult &result)
{
    m_downloadHandler = nullptr; // will be deleted by DownloadManager later

    if (result.status == Net::DownloadStatus::Success)
    {
        LogMsg(tr("RSS feed at '%1' is successfully downloaded. Starting to parse it.")
                .arg(result.url));
        // Parse the download RSS
        QMetaObject::invokeMethod(m_parser, [this, data = result.data]()
        {
            m_parser->parse(data);
        });
    }
    else
    {
        m_isLoading = false;
        m_hasError = true;

        LogMsg(tr("Failed to download RSS feed at '%1'. Reason: %2")
               .arg(result.url, result.errorString), Log::WARNING);

        emit stateChanged(this);
    }
}

void Feed::handleParsingFinished(const RSS::Private::ParsingResult &result)
{
    m_hasError = !result.error.isEmpty();

    if (!result.title.isEmpty() && (title() != result.title))
    {
        m_title = result.title;
        m_dirty = true;
        emit titleChanged(this);
    }

    if (!result.lastBuildDate.isEmpty())
    {
        m_lastBuildDate = result.lastBuildDate;
        m_dirty = true;
    }

    // For some reason, the RSS feed may contain malformed XML data and it may not be
    // successfully parsed by the XML parser. We are still trying to load as many articles
    // as possible until we encounter corrupted data. So we can have some articles here
    // even in case of parsing error.
    const int newArticlesCount = updateArticles(result.articles);
    store();

    if (m_hasError)
    {
        LogMsg(tr("Failed to parse RSS feed at '%1'. Reason: %2").arg(m_url, result.error)
               , Log::WARNING);
    }
    LogMsg(tr("RSS feed at '%1' updated. Added %2 new articles.")
           .arg(url(), QString::number(newArticlesCount)));

    m_isLoading = false;
    emit stateChanged(this);
}

void Feed::load()
{
    QMetaObject::invokeMethod(m_serializer
            , [serializer = m_serializer, url = m_url
                , path = (m_session->dataFileStorage()->storageDir() / m_dataFileName)]
    {
        serializer->load(path, url);
    });
}

void Feed::store()
{
    if (!m_dirty)
        return;

    m_dirty = false;
    m_savingTimer.stop();

    QList<QVariantHash> articlesData;
    articlesData.reserve(m_articles.size());

    for (Article *article :asConst(m_articles))
        articlesData.push_back(article->data());

    QMetaObject::invokeMethod(m_serializer
            , [articlesData, serializer = m_serializer
                , path = (m_session->dataFileStorage()->storageDir() / m_dataFileName)]
    {
        serializer->store(path, articlesData);
    });
}

void Feed::storeDeferred()
{
    if (!m_savingTimer.isActive())
        m_savingTimer.start(5 * 1000, this);
}

bool Feed::addArticle(const QVariantHash &articleData)
{
    Q_ASSERT(!m_articles.contains(articleData.value(Article::KeyId).toString()));

    // Insertion sort
    const int maxArticles = m_session->maxArticlesPerFeed();
    const auto lowerBound = std::lower_bound(m_articlesByDate.cbegin(), m_articlesByDate.cend()
        , articleData.value(Article::KeyDate).toDateTime(), Article::articleDateRecentThan);
    if ((lowerBound - m_articlesByDate.cbegin()) >= maxArticles)
        return false; // we reach max articles

    auto *article = new Article(this, articleData);
    m_articles[article->guid()] = article;
    m_articlesByDate.insert(lowerBound, article);
    if (!article->isRead())
    {
        increaseUnreadCount();
        connect(article, &Article::read, this, &Feed::handleArticleRead);
    }

    m_dirty = true;
    emit newArticle(article);

    if (m_articlesByDate.size() > maxArticles)
        removeOldestArticle();

    return true;
}

void Feed::removeOldestArticle()
{
    auto *oldestArticle = m_articlesByDate.last();
    emit articleAboutToBeRemoved(oldestArticle);

    m_articles.remove(oldestArticle->guid());
    m_articlesByDate.removeLast();
    const bool isRead = oldestArticle->isRead();
    delete oldestArticle;

    if (!isRead)
        decreaseUnreadCount();
}

void Feed::increaseUnreadCount()
{
    ++m_unreadCount;
    emit unreadCountChanged(this);
}

void Feed::decreaseUnreadCount()
{
    Q_ASSERT(m_unreadCount > 0);

    --m_unreadCount;
    emit unreadCountChanged(this);
}

void Feed::downloadIcon()
{
    // Download the RSS Feed icon
    // XXX: This works for most sites but it is not perfect
    const QUrl url(m_url);
    const auto iconUrl = u"%1://%2/favicon.ico"_s.arg(url.scheme(), url.host());
    Net::DownloadManager::instance()->download(
            Net::DownloadRequest(iconUrl).saveToFile(true).destFileName(m_iconPath)
            , Preferences::instance()->useProxyForRSS(), this, &Feed::handleIconDownloadFinished);
}

int Feed::updateArticles(const QList<QVariantHash> &loadedArticles)
{
    if (loadedArticles.empty())
        return 0;

    QDateTime dummyPubDate {QDateTime::currentDateTime()};
    QList<QVariantHash> newArticles;
    newArticles.reserve(loadedArticles.size());
    for (QVariantHash article : loadedArticles)
    {
        // If article has no publication date we use feed update time as a fallback.
        // To prevent processing of "out-of-limit" articles we must not assign dates
        // that are earlier than the dates of existing articles.
        const Article *existingArticle = articleByGUID(article[Article::KeyId].toString());
        if (existingArticle)
        {
            dummyPubDate = existingArticle->date().addMSecs(-1);
            continue;
        }

        QVariant &articleDate = article[Article::KeyDate];
        if (!articleDate.toDateTime().isValid())
            articleDate = dummyPubDate;

        newArticles.append(article);
    }

    if (newArticles.empty())
        return 0;

    using ArticleSortAdaptor = std::pair<QDateTime, const QVariantHash *>;
    std::vector<ArticleSortAdaptor> sortData;
    const QList<Article *> existingArticles = articles();
    sortData.reserve(existingArticles.size() + newArticles.size());
    std::transform(existingArticles.begin(), existingArticles.end(), std::back_inserter(sortData)
                   , [](const Article *article)
    {
        return std::make_pair(article->date(), nullptr);
    });
    std::transform(newArticles.begin(), newArticles.end(), std::back_inserter(sortData)
                   , [](const QVariantHash &article)
    {
        return std::make_pair(article[Article::KeyDate].toDateTime(), &article);
    });

    // Sort article list in reverse chronological order
    std::sort(sortData.begin(), sortData.end()
              , [](const ArticleSortAdaptor &a1, const ArticleSortAdaptor &a2)
    {
        return (a1.first > a2.first);
    });

    if (sortData.size() > static_cast<uint>(m_session->maxArticlesPerFeed()))
        sortData.resize(m_session->maxArticlesPerFeed());

    int newArticlesCount = 0;
    std::for_each(sortData.crbegin(), sortData.crend(), [this, &newArticlesCount](const ArticleSortAdaptor &a)
    {
        if (a.second)
        {
            addArticle(*a.second);
            ++newArticlesCount;
        }
    });

    return newArticlesCount;
}

Path Feed::iconPath() const
{
    return m_iconPath;
}

std::chrono::seconds Feed::refreshInterval() const
{
    return m_refreshInterval;
}

void Feed::setRefreshInterval(const std::chrono::seconds refreshInterval)
{
    if (refreshInterval == m_refreshInterval)
        return;

    const std::chrono::seconds oldRefreshInterval = std::exchange(m_refreshInterval, refreshInterval);
    emit refreshIntervalChanged(oldRefreshInterval);
}

void Feed::setURL(const QString &url)
{
    const QString oldURL = m_url;
    m_url = url;
    emit urlChanged(oldURL);
}

QJsonValue Feed::toJsonValue(const bool withData) const
{
    QJsonObject jsonObj;
    jsonObj.insert(KEY_UID, uid().toString());
    jsonObj.insert(KEY_URL, url());
    if (refreshInterval() > 0s)
        jsonObj.insert(KEY_REFRESHINTERVAL, static_cast<qint64>(refreshInterval().count()));

    if (withData)
    {
        jsonObj.insert(KEY_TITLE, title());
        jsonObj.insert(KEY_LASTBUILDDATE, lastBuildDate());
        jsonObj.insert(KEY_ISLOADING, isLoading());
        jsonObj.insert(KEY_HASERROR, hasError());

        QJsonArray jsonArr;
        for (Article *article : asConst(m_articles))
        {
            auto articleObj = QJsonObject::fromVariantHash(article->data());
            // JSON object doesn't support DateTime so we need to convert it
            articleObj[Article::KeyDate] = article->date().toString(Qt::RFC2822Date);
            jsonArr.append(articleObj);
        }
        jsonObj.insert(KEY_ARTICLES, jsonArr);
    }

    return jsonObj;
}

void Feed::handleSessionProcessingEnabledChanged(const bool enabled)
{
    if (enabled)
    {
        downloadIcon();
        disconnect(m_session, &Session::processingStateChanged
                   , this, &Feed::handleSessionProcessingEnabledChanged);
    }
}

void Feed::handleArticleRead(Article *article)
{
    article->disconnect(this);
    decreaseUnreadCount();
    emit articleRead(article);
    // will be stored deferred
    m_dirty = true;
    storeDeferred();
}

void Feed::handleArticleLoadFinished(QList<QVariantHash> articles)
{
    Q_ASSERT(m_articles.isEmpty());
    Q_ASSERT(m_unreadCount == 0);

    const int maxArticles = m_session->maxArticlesPerFeed();
    if (articles.size() > maxArticles)
        articles.resize(maxArticles);

    m_articles.reserve(articles.size());
    m_articlesByDate.reserve(articles.size());

    for (const QVariantHash &articleData : articles)
    {
        const auto articleID = articleData.value(Article::KeyId).toString();
        if (m_articles.contains(articleID)) [[unlikely]]
            continue;

        auto *article = new Article(this, articleData);
        m_articles[articleID] = article;
        m_articlesByDate.append(article);
        if (!article->isRead())
        {
            ++m_unreadCount;
            connect(article, &Article::read, this, &Feed::handleArticleRead);
        }

        emit newArticle(article);
    }

    if (m_unreadCount > 0)
        emit unreadCountChanged(this);

    m_isInitialized = true;
    emit stateChanged(this);

    if (m_pendingRefresh)
    {
        m_pendingRefresh = false;
        refresh();
    }
}

void Feed::cleanup()
{
    m_dirty = false;
    m_savingTimer.stop();
    Utils::Fs::removeFile(m_session->dataFileStorage()->storageDir() / m_dataFileName);
    Utils::Fs::removeFile(m_iconPath);
}

void Feed::timerEvent([[maybe_unused]] QTimerEvent *event)
{
    store();
}
</file>

<file path="base/rss/rss_feed.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015-2025  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2024  Jonathan Ketchker
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <chrono>

#include <QtContainerFwd>
#include <QBasicTimer>
#include <QHash>
#include <QList>
#include <QUuid>
#include <QVariantHash>

#include "base/path.h"
#include "rss_item.h"

class AsyncFileStorage;

namespace Net
{
    class DownloadHandler;
    struct DownloadResult;
}

namespace RSS
{
    class Article;
    class Session;

    namespace Private
    {
        class FeedSerializer;
        class Parser;
        struct ParsingResult;
    }

    class Feed final : public Item
    {
        Q_OBJECT
        Q_DISABLE_COPY_MOVE(Feed)

        friend class Session;

        Feed(Session *session, const QUuid &uid, const QString &url, const QString &path, std::chrono::seconds refreshInterval);
        ~Feed() override;

    public:
        QList<Article *> articles() const override;
        int unreadCount() const override;
        void markAsRead() override;
        void refresh() override;
        void updateFetchDelay() override;

        QUuid uid() const;
        QString url() const;
        QString title() const;
        QString lastBuildDate() const;
        bool hasError() const;
        bool isLoading() const;
        Article *articleByGUID(const QString &guid) const;
        Path iconPath() const;

        std::chrono::seconds refreshInterval() const;
        void setRefreshInterval(std::chrono::seconds refreshInterval);

        QJsonValue toJsonValue(bool withData = false) const override;

    signals:
        void iconLoaded(Feed *feed = nullptr);
        void titleChanged(Feed *feed = nullptr);
        void stateChanged(Feed *feed = nullptr);
        void urlChanged(const QString &oldURL);
        void refreshIntervalChanged(std::chrono::seconds oldRefreshInterval);

    private slots:
        void handleSessionProcessingEnabledChanged(bool enabled);
        void handleMaxArticlesPerFeedChanged(int n);
        void handleIconDownloadFinished(const Net::DownloadResult &result);
        void handleDownloadFinished(const Net::DownloadResult &result);
        void handleParsingFinished(const Private::ParsingResult &result);
        void handleArticleRead(Article *article);
        void handleArticleLoadFinished(QList<QVariantHash> articles);

    private:
        void timerEvent(QTimerEvent *event) override;
        void cleanup() override;
        void load();
        void store();
        void storeDeferred();
        bool addArticle(const QVariantHash &articleData);
        void removeOldestArticle();
        void increaseUnreadCount();
        void decreaseUnreadCount();
        void downloadIcon();
        int updateArticles(const QList<QVariantHash> &loadedArticles);
        void setURL(const QString &url);

        Session *m_session = nullptr;
        Private::Parser *m_parser = nullptr;
        Private::FeedSerializer *m_serializer = nullptr;
        const QUuid m_uid;
        QString m_url;
        std::chrono::seconds m_refreshInterval;
        QString m_title;
        QString m_lastBuildDate;
        bool m_hasError = false;
        bool m_isLoading = false;
        bool m_isInitialized = false;
        bool m_pendingRefresh = false;
        QHash<QString, Article *> m_articles;
        QList<Article *> m_articlesByDate;
        int m_unreadCount = 0;
        Path m_iconPath;
        Path m_dataFileName;
        QBasicTimer m_savingTimer;
        bool m_dirty = false;
        Net::DownloadHandler *m_downloadHandler = nullptr;
    };
}
</file>

<file path="base/rss/rss_folder.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2024  Jonathan Ketchker
 * Copyright (C) 2017  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "rss_folder.h"

#include <algorithm>

#include <QJsonObject>
#include <QJsonValue>

#include "base/global.h"
#include "rss_article.h"

using namespace RSS;

Folder::Folder(const QString &path)
    : Item(path)
{
}

Folder::~Folder()
{
    emit aboutToBeDestroyed(this);

    for (auto *item : asConst(items()))
        delete item;
}

QList<Article *> Folder::articles() const
{
    QList<Article *> news;

    for (Item *item : asConst(items()))
    {
        int n = news.size();
        news << item->articles();
        std::inplace_merge(news.begin(), news.begin() + n, news.end()
                           , [](Article *a1, Article *a2)
        {
            return Article::articleDateRecentThan(a1, a2->date());
        });
    }
    return news;
}

int Folder::unreadCount() const
{
    const auto itemList = items();
    return std::accumulate(itemList.cbegin(), itemList.cend(), 0, [](const int acc, const Item *item)
    {
        return (acc + item->unreadCount());
    });
}

void Folder::markAsRead()
{
    for (Item *item : asConst(items()))
        item->markAsRead();
}

void Folder::refresh()
{
    for (Item *item : asConst(items()))
        item->refresh();
}

void Folder::updateFetchDelay()
{
    for (Item *item : asConst(items()))
        item->updateFetchDelay();
}

QList<Item *> Folder::items() const
{
    return m_items;
}

QJsonValue Folder::toJsonValue(bool withData) const
{
    QJsonObject jsonObj;
    for (Item *item : asConst(items()))
        jsonObj.insert(item->name(), item->toJsonValue(withData));

    return jsonObj;
}

void Folder::handleItemUnreadCountChanged()
{
    emit unreadCountChanged(this);
}

void Folder::cleanup()
{
    for (Item *item : asConst(items()))
        item->cleanup();
}

void Folder::addItem(Item *item)
{
    Q_ASSERT(item);
    Q_ASSERT(!m_items.contains(item));

    m_items.append(item);
    connect(item, &Item::newArticle, this, &Item::newArticle);
    connect(item, &Item::articleRead, this, &Item::articleRead);
    connect(item, &Item::articleAboutToBeRemoved, this, &Item::articleAboutToBeRemoved);
    connect(item, &Item::unreadCountChanged, this, &Folder::handleItemUnreadCountChanged);

    for (auto *article : asConst(item->articles()))
        emit newArticle(article);

    if (item->unreadCount() > 0)
        emit unreadCountChanged(this);
}

void Folder::removeItem(Item *item)
{
    Q_ASSERT(m_items.contains(item));

    for (auto *article : asConst(item->articles()))
        emit articleAboutToBeRemoved(article);

    item->disconnect(this);
    m_items.removeOne(item);
    if (item->unreadCount() > 0)
        emit unreadCountChanged(this);
}
</file>

<file path="base/rss/rss_folder.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2024  Jonathan Ketchker
 * Copyright (C) 2017  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QList>

#include "base/global.h"
#include "rss_item.h"

namespace RSS
{
    class Session;

    class Folder final : public Item
    {
        Q_OBJECT
        Q_DISABLE_COPY_MOVE(Folder)

        friend class Session;

        explicit Folder(const QString &path = {});
        ~Folder() override;

    public:
        QList<Article *> articles() const override;
        int unreadCount() const override;
        void markAsRead() override;
        void refresh() override;
        void updateFetchDelay() override;

        QList<Item *> items() const;

        QJsonValue toJsonValue(bool withData = false) const override;

    private slots:
        void handleItemUnreadCountChanged();

    private:
        void cleanup() override;
        void addItem(Item *item);
        void removeItem(Item *item);

        QList<Item *> m_items;
    };
}
</file>

<file path="base/rss/rss_item.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "rss_item.h"

#include <QDebug>
#include <QRegularExpression>
#include <QStringList>

#include "base/global.h"

using namespace RSS;

const QChar Item::PathSeparator = u'\\';

Item::Item(const QString &path)
    : m_path(path)
{
}

void Item::setPath(const QString &path)
{
    if (path != m_path)
    {
        m_path = path;
        emit pathChanged(this);
    }
}

QString Item::path() const
{
    return m_path;
}

QString Item::name() const
{
    return relativeName(path());
}

bool Item::isValidPath(const QString &path)
{
    const QRegularExpression re(
                uR"(\A[^\%1]+(\%1[^\%1]+)*\z)"_s.arg(Item::PathSeparator)
                , QRegularExpression::DontCaptureOption);

    if (path.isEmpty() || !re.match(path).hasMatch())
    {
        qDebug() << "Incorrect RSS Item path:" << path;
        return false;
    }

    return true;
}

QString Item::joinPath(const QString &path1, const QString &path2)
{
    if (path1.isEmpty())
        return path2;

    return (path1 + Item::PathSeparator + path2);
}

QStringList Item::expandPath(const QString &path)
{
    QStringList result;
    if (path.isEmpty()) return result;
    //    if (!isValidRSSFolderName(folder))
    //        return result;

    int index = 0;
    while ((index = path.indexOf(Item::PathSeparator, index)) >= 0)
    {
        result << path.first(index);
        ++index;
    }
    result << path;

    return result;
}

QString Item::parentPath(const QString &path)
{
    const int pos = path.lastIndexOf(Item::PathSeparator);
    return (pos >= 0) ? path.first(pos) : QString();
}

QString Item::relativeName(const QString &path)
{
    const int pos = path.lastIndexOf(Item::PathSeparator);
    return (pos >= 0) ? path.sliced(pos + 1) : path;
}
</file>

<file path="base/rss/rss_item.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2024  Jonathan Ketchker
 * Copyright (C) 2017  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QList>
#include <QObject>

namespace RSS
{
    class Article;
    class Folder;
    class Session;

    class Item : public QObject
    {
        Q_OBJECT
        Q_DISABLE_COPY_MOVE(Item)

        friend class Folder;
        friend class Session;

    public:
        virtual QList<Article *> articles() const = 0;
        virtual int unreadCount() const = 0;
        virtual void markAsRead() = 0;
        virtual void refresh() = 0;
        virtual void updateFetchDelay() = 0;

        QString path() const;
        QString name() const;

        virtual QJsonValue toJsonValue(bool withData = false) const = 0;

        static const QChar PathSeparator;

        static bool isValidPath(const QString &path);
        static QString joinPath(const QString &path1, const QString &path2);
        static QStringList expandPath(const QString &path);
        static QString parentPath(const QString &path);
        static QString relativeName(const QString &path);

    signals:
        void pathChanged(Item *item = nullptr);
        void unreadCountChanged(Item *item = nullptr);
        void aboutToBeDestroyed(Item *item = nullptr);
        void newArticle(Article *article);
        void articleRead(Article *article);
        void articleAboutToBeRemoved(Article *article);

    protected:
        explicit Item(const QString &path);
        ~Item() override = default;

        virtual void cleanup() = 0;

    private:
        void setPath(const QString &path);

        QString m_path;
    };
}
</file>

<file path="base/rss/rss_parser.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015-2025  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2012  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "rss_parser.h"

#include <QDebug>
#include <QHash>
#include <QRegularExpression>
#include <QStringList>
#include <QTimeZone>
#include <QVariant>
#include <QXmlStreamEntityResolver>
#include <QXmlStreamReader>

#include "base/global.h"
#include "rss_article.h"

namespace
{
    class XmlStreamEntityResolver final : public QXmlStreamEntityResolver
    {
    public:
        QString resolveUndeclaredEntity(const QString &name) override
        {
            // (X)HTML entities declared in:
            //     http://www.w3.org/TR/xhtml1/DTD/xhtml-lat1.ent
            //     http://www.w3.org/TR/xhtml1/DTD/xhtml-symbol.ent
            //     http://www.w3.org/TR/xhtml1/DTD/xhtml-special.ent
            static const QHash<QString, QString> HTMLEntities
            {
                {u"nbsp"_s,   u"&#160;"_s}, // no-break space = non-breaking space, U+00A0 ISOnum
                {u"iexcl"_s,  u"&#161;"_s}, // inverted exclamation mark, U+00A1 ISOnum
                {u"cent"_s,   u"&#162;"_s}, // cent sign, U+00A2 ISOnum
                {u"pound"_s,  u"&#163;"_s}, // pound sign, U+00A3 ISOnum
                {u"curren"_s, u"&#164;"_s}, // currency sign, U+00A4 ISOnum
                {u"yen"_s,    u"&#165;"_s}, // yen sign = yuan sign, U+00A5 ISOnum
                {u"brvbar"_s, u"&#166;"_s}, // broken bar = broken vertical bar, U+00A6 ISOnum
                {u"sect"_s,   u"&#167;"_s}, // section sign, U+00A7 ISOnum
                {u"uml"_s,    u"&#168;"_s}, // diaeresis = spacing diaeresis, U+00A8 ISOdia
                {u"copy"_s,   u"&#169;"_s}, // copyright sign, U+00A9 ISOnum
                {u"ordf"_s,   u"&#170;"_s}, // feminine ordinal indicator, U+00AA ISOnum
                {u"laquo"_s,  u"&#171;"_s}, // left-pointing double angle quotation mark = left pointing guillemet, U+00AB ISOnum
                {u"not"_s,    u"&#172;"_s}, // not sign = angled dash, U+00AC ISOnum
                {u"shy"_s,    u"&#173;"_s}, // soft hyphen = discretionary hyphen, U+00AD ISOnum
                {u"reg"_s,    u"&#174;"_s}, // registered sign = registered trade mark sign, U+00AE ISOnum
                {u"macr"_s,   u"&#175;"_s}, // macron = spacing macron = overline = APL overbar, U+00AF ISOdia
                {u"deg"_s,    u"&#176;"_s}, // degree sign, U+00B0 ISOnum
                {u"plusmn"_s, u"&#177;"_s}, // plus-minus sign = plus-or-minus sign, U+00B1 ISOnum
                {u"sup2"_s,   u"&#178;"_s}, // superscript two = superscript digit two = squared, U+00B2 ISOnum
                {u"sup3"_s,   u"&#179;"_s}, // superscript three = superscript digit three = cubed, U+00B3 ISOnum
                {u"acute"_s,  u"&#180;"_s}, // acute accent = spacing acute, U+00B4 ISOdia
                {u"micro"_s,  u"&#181;"_s}, // micro sign, U+00B5 ISOnum
                {u"para"_s,   u"&#182;"_s}, // pilcrow sign = paragraph sign, U+00B6 ISOnum
                {u"middot"_s, u"&#183;"_s}, // middle dot = Georgian comma = Greek middle dot, U+00B7 ISOnum
                {u"cedil"_s,  u"&#184;"_s}, // cedilla = spacing cedilla, U+00B8 ISOdia
                {u"sup1"_s,   u"&#185;"_s}, // superscript one = superscript digit one, U+00B9 ISOnum
                {u"ordm"_s,   u"&#186;"_s}, // masculine ordinal indicator, U+00BA ISOnum
                {u"raquo"_s,  u"&#187;"_s}, // right-pointing double angle quotation mark = right pointing guillemet, U+00BB ISOnum
                {u"frac14"_s, u"&#188;"_s}, // vulgar fraction one quarter = fraction one quarter, U+00BC ISOnum
                {u"frac12"_s, u"&#189;"_s}, // vulgar fraction one half = fraction one half, U+00BD ISOnum
                {u"frac34"_s, u"&#190;"_s}, // vulgar fraction three quarters = fraction three quarters, U+00BE ISOnum
                {u"iquest"_s, u"&#191;"_s}, // inverted question mark = turned question mark, U+00BF ISOnum
                {u"Agrave"_s, u"&#192;"_s}, // latin capital letter A with grave = latin capital letter A grave, U+00C0 ISOlat1
                {u"Aacute"_s, u"&#193;"_s}, // latin capital letter A with acute, U+00C1 ISOlat1
                {u"Acirc"_s,  u"&#194;"_s}, // latin capital letter A with circumflex, U+00C2 ISOlat1
                {u"Atilde"_s, u"&#195;"_s}, // latin capital letter A with tilde, U+00C3 ISOlat1
                {u"Auml"_s,   u"&#196;"_s}, // latin capital letter A with diaeresis, U+00C4 ISOlat1
                {u"Aring"_s,  u"&#197;"_s}, // latin capital letter A with ring above = latin capital letter A ring, U+00C5 ISOlat1
                {u"AElig"_s,  u"&#198;"_s}, // latin capital letter AE = latin capital ligature AE, U+00C6 ISOlat1
                {u"Ccedil"_s, u"&#199;"_s}, // latin capital letter C with cedilla, U+00C7 ISOlat1
                {u"Egrave"_s, u"&#200;"_s}, // latin capital letter E with grave, U+00C8 ISOlat1
                {u"Eacute"_s, u"&#201;"_s}, // latin capital letter E with acute, U+00C9 ISOlat1
                {u"Ecirc"_s,  u"&#202;"_s}, // latin capital letter E with circumflex, U+00CA ISOlat1
                {u"Euml"_s,   u"&#203;"_s}, // latin capital letter E with diaeresis, U+00CB ISOlat1
                {u"Igrave"_s, u"&#204;"_s}, // latin capital letter I with grave, U+00CC ISOlat1
                {u"Iacute"_s, u"&#205;"_s}, // latin capital letter I with acute, U+00CD ISOlat1
                {u"Icirc"_s,  u"&#206;"_s}, // latin capital letter I with circumflex, U+00CE ISOlat1
                {u"Iuml"_s,   u"&#207;"_s}, // latin capital letter I with diaeresis, U+00CF ISOlat1
                {u"ETH"_s,    u"&#208;"_s}, // latin capital letter ETH, U+00D0 ISOlat1
                {u"Ntilde"_s, u"&#209;"_s}, // latin capital letter N with tilde, U+00D1 ISOlat1
                {u"Ograve"_s, u"&#210;"_s}, // latin capital letter O with grave, U+00D2 ISOlat1
                {u"Oacute"_s, u"&#211;"_s}, // latin capital letter O with acute, U+00D3 ISOlat1
                {u"Ocirc"_s,  u"&#212;"_s}, // latin capital letter O with circumflex, U+00D4 ISOlat1
                {u"Otilde"_s, u"&#213;"_s}, // latin capital letter O with tilde, U+00D5 ISOlat1
                {u"Ouml"_s,   u"&#214;"_s}, // latin capital letter O with diaeresis, U+00D6 ISOlat1
                {u"times"_s,  u"&#215;"_s}, // multiplication sign, U+00D7 ISOnum
                {u"Oslash"_s, u"&#216;"_s}, // latin capital letter O with stroke = latin capital letter O slash, U+00D8 ISOlat1
                {u"Ugrave"_s, u"&#217;"_s}, // latin capital letter U with grave, U+00D9 ISOlat1
                {u"Uacute"_s, u"&#218;"_s}, // latin capital letter U with acute, U+00DA ISOlat1
                {u"Ucirc"_s,  u"&#219;"_s}, // latin capital letter U with circumflex, U+00DB ISOlat1
                {u"Uuml"_s,   u"&#220;"_s}, // latin capital letter U with diaeresis, U+00DC ISOlat1
                {u"Yacute"_s, u"&#221;"_s}, // latin capital letter Y with acute, U+00DD ISOlat1
                {u"THORN"_s,  u"&#222;"_s}, // latin capital letter THORN, U+00DE ISOlat1
                {u"szlig"_s,  u"&#223;"_s}, // latin small letter sharp s = ess-zed, U+00DF ISOlat1
                {u"agrave"_s, u"&#224;"_s}, // latin small letter a with grave = latin small letter a grave, U+00E0 ISOlat1
                {u"aacute"_s, u"&#225;"_s}, // latin small letter a with acute, U+00E1 ISOlat1
                {u"acirc"_s,  u"&#226;"_s}, // latin small letter a with circumflex, U+00E2 ISOlat1
                {u"atilde"_s, u"&#227;"_s}, // latin small letter a with tilde, U+00E3 ISOlat1
                {u"auml"_s,   u"&#228;"_s}, // latin small letter a with diaeresis, U+00E4 ISOlat1
                {u"aring"_s,  u"&#229;"_s}, // latin small letter a with ring above = latin small letter a ring, U+00E5 ISOlat1
                {u"aelig"_s,  u"&#230;"_s}, // latin small letter ae = latin small ligature ae, U+00E6 ISOlat1
                {u"ccedil"_s, u"&#231;"_s}, // latin small letter c with cedilla, U+00E7 ISOlat1
                {u"egrave"_s, u"&#232;"_s}, // latin small letter e with grave, U+00E8 ISOlat1
                {u"eacute"_s, u"&#233;"_s}, // latin small letter e with acute, U+00E9 ISOlat1
                {u"ecirc"_s,  u"&#234;"_s}, // latin small letter e with circumflex, U+00EA ISOlat1
                {u"euml"_s,   u"&#235;"_s}, // latin small letter e with diaeresis, U+00EB ISOlat1
                {u"igrave"_s, u"&#236;"_s}, // latin small letter i with grave, U+00EC ISOlat1
                {u"iacute"_s, u"&#237;"_s}, // latin small letter i with acute, U+00ED ISOlat1
                {u"icirc"_s,  u"&#238;"_s}, // latin small letter i with circumflex, U+00EE ISOlat1
                {u"iuml"_s,   u"&#239;"_s}, // latin small letter i with diaeresis, U+00EF ISOlat1
                {u"eth"_s,    u"&#240;"_s}, // latin small letter eth, U+00F0 ISOlat1
                {u"ntilde"_s, u"&#241;"_s}, // latin small letter n with tilde, U+00F1 ISOlat1
                {u"ograve"_s, u"&#242;"_s}, // latin small letter o with grave, U+00F2 ISOlat1
                {u"oacute"_s, u"&#243;"_s}, // latin small letter o with acute, U+00F3 ISOlat1
                {u"ocirc"_s,  u"&#244;"_s}, // latin small letter o with circumflex, U+00F4 ISOlat1
                {u"otilde"_s, u"&#245;"_s}, // latin small letter o with tilde, U+00F5 ISOlat1
                {u"ouml"_s,   u"&#246;"_s}, // latin small letter o with diaeresis, U+00F6 ISOlat1
                {u"divide"_s, u"&#247;"_s}, // division sign, U+00F7 ISOnum
                {u"oslash"_s, u"&#248;"_s}, // latin small letter o with stroke, = latin small letter o slash, U+00F8 ISOlat1
                {u"ugrave"_s, u"&#249;"_s}, // latin small letter u with grave, U+00F9 ISOlat1
                {u"uacute"_s, u"&#250;"_s}, // latin small letter u with acute, U+00FA ISOlat1
                {u"ucirc"_s,  u"&#251;"_s}, // latin small letter u with circumflex, U+00FB ISOlat1
                {u"uuml"_s,   u"&#252;"_s}, // latin small letter u with diaeresis, U+00FC ISOlat1
                {u"yacute"_s, u"&#253;"_s}, // latin small letter y with acute, U+00FD ISOlat1
                {u"thorn"_s,  u"&#254;"_s}, // latin small letter thorn, U+00FE ISOlat1
                {u"yuml"_s,   u"&#255;"_s}, // latin small letter y with diaeresis, U+00FF ISOlat1

                // Latin Extended-A
                {u"OElig"_s,   u"&#338;"_s}, //  latin capital ligature OE, U+0152 ISOlat2
                {u"oelig"_s,   u"&#339;"_s}, //  latin small ligature oe, U+0153 ISOlat2
                // ligature is a misnomer, this is a separate character in some languages
                {u"Scaron"_s,  u"&#352;"_s}, //  latin capital letter S with caron, U+0160 ISOlat2
                {u"scaron"_s,  u"&#353;"_s}, //  latin small letter s with caron, U+0161 ISOlat2
                {u"Yuml"_s,    u"&#376;"_s}, //  latin capital letter Y with diaeresis, U+0178 ISOlat2

                // Spacing Modifier Letters
                {u"circ"_s,    u"&#710;"_s}, //  modifier letter circumflex accent, U+02C6 ISOpub
                {u"tilde"_s,   u"&#732;"_s}, //  small tilde, U+02DC ISOdia

                // General Punctuation
                {u"ensp"_s,    u"&#8194;"_s}, // en space, U+2002 ISOpub
                {u"emsp"_s,    u"&#8195;"_s}, // em space, U+2003 ISOpub
                {u"thinsp"_s,  u"&#8201;"_s}, // thin space, U+2009 ISOpub
                {u"zwnj"_s,    u"&#8204;"_s}, // zero width non-joiner, U+200C NEW RFC 2070
                {u"zwj"_s,     u"&#8205;"_s}, // zero width joiner, U+200D NEW RFC 2070
                {u"lrm"_s,     u"&#8206;"_s}, // left-to-right mark, U+200E NEW RFC 2070
                {u"rlm"_s,     u"&#8207;"_s}, // right-to-left mark, U+200F NEW RFC 2070
                {u"ndash"_s,   u"&#8211;"_s}, // en dash, U+2013 ISOpub
                {u"mdash"_s,   u"&#8212;"_s}, // em dash, U+2014 ISOpub
                {u"lsquo"_s,   u"&#8216;"_s}, // left single quotation mark, U+2018 ISOnum
                {u"rsquo"_s,   u"&#8217;"_s}, // right single quotation mark, U+2019 ISOnum
                {u"sbquo"_s,   u"&#8218;"_s}, // single low-9 quotation mark, U+201A NEW
                {u"ldquo"_s,   u"&#8220;"_s}, // left double quotation mark, U+201C ISOnum
                {u"rdquo"_s,   u"&#8221;"_s}, // right double quotation mark, U+201D ISOnum
                {u"bdquo"_s,   u"&#8222;"_s}, // double low-9 quotation mark, U+201E NEW
                {u"dagger"_s,  u"&#8224;"_s}, // dagger, U+2020 ISOpub
                {u"Dagger"_s,  u"&#8225;"_s}, // double dagger, U+2021 ISOpub
                {u"permil"_s,  u"&#8240;"_s}, // per mille sign, U+2030 ISOtech
                {u"lsaquo"_s,  u"&#8249;"_s}, // single left-pointing angle quotation mark, U+2039 ISO proposed
                // lsaquo is proposed but not yet ISO standardized
                {u"rsaquo"_s,  u"&#8250;"_s}, // single right-pointing angle quotation mark, U+203A ISO proposed
                // rsaquo is proposed but not yet ISO standardized

                // Currency Symbols
                {u"euro"_s,   u"&#8364;"_s}, //  euro sign, U+20AC NEW

                // Latin Extended-B
                {u"fnof"_s,     u"&#402;"_s}, // latin small letter f with hook = function   = florin, U+0192 ISOtech

                // Greek
                {u"Alpha"_s,    u"&#913;"_s}, // greek capital letter alpha, U+0391
                {u"Beta"_s,     u"&#914;"_s}, // greek capital letter beta, U+0392
                {u"Gamma"_s,    u"&#915;"_s}, // greek capital letter gamma, U+0393 ISOgrk3
                {u"Delta"_s,    u"&#916;"_s}, // greek capital letter delta, U+0394 ISOgrk3
                {u"Epsilon"_s,  u"&#917;"_s}, // greek capital letter epsilon, U+0395
                {u"Zeta"_s,     u"&#918;"_s}, // greek capital letter zeta, U+0396
                {u"Eta"_s,      u"&#919;"_s}, // greek capital letter eta, U+0397
                {u"Theta"_s,    u"&#920;"_s}, // greek capital letter theta, U+0398 ISOgrk3
                {u"Iota"_s,     u"&#921;"_s}, // greek capital letter iota, U+0399
                {u"Kappa"_s,    u"&#922;"_s}, // greek capital letter kappa, U+039A
                {u"Lambda"_s,   u"&#923;"_s}, // greek capital letter lambda, U+039B ISOgrk3
                {u"Mu"_s,       u"&#924;"_s}, // greek capital letter mu, U+039C
                {u"Nu"_s,       u"&#925;"_s}, // greek capital letter nu, U+039D
                {u"Xi"_s,       u"&#926;"_s}, // greek capital letter xi, U+039E ISOgrk3
                {u"Omicron"_s,  u"&#927;"_s}, // greek capital letter omicron, U+039F
                {u"Pi"_s,       u"&#928;"_s}, // greek capital letter pi, U+03A0 ISOgrk3
                {u"Rho"_s,      u"&#929;"_s}, // greek capital letter rho, U+03A1
                {u"Sigma"_s,    u"&#931;"_s}, // greek capital letter sigma, U+03A3 ISOgrk3
                {u"Tau"_s,      u"&#932;"_s}, // greek capital letter tau, U+03A4
                {u"Upsilon"_s,  u"&#933;"_s}, // greek capital letter upsilon, U+03A5 ISOgrk3
                {u"Phi"_s,      u"&#934;"_s}, // greek capital letter phi, U+03A6 ISOgrk3
                {u"Chi"_s,      u"&#935;"_s}, // greek capital letter chi, U+03A7
                {u"Psi"_s,      u"&#936;"_s}, // greek capital letter psi, U+03A8 ISOgrk3
                {u"Omega"_s,    u"&#937;"_s}, // greek capital letter omega, U+03A9 ISOgrk3
                {u"alpha"_s,    u"&#945;"_s}, // greek small letter alpha, U+03B1 ISOgrk3
                {u"beta"_s,     u"&#946;"_s}, // greek small letter beta, U+03B2 ISOgrk3
                {u"gamma"_s,    u"&#947;"_s}, // greek small letter gamma, U+03B3 ISOgrk3
                {u"delta"_s,    u"&#948;"_s}, // greek small letter delta, U+03B4 ISOgrk3
                {u"epsilon"_s,  u"&#949;"_s}, // greek small letter epsilon, U+03B5 ISOgrk3
                {u"zeta"_s,     u"&#950;"_s}, // greek small letter zeta, U+03B6 ISOgrk3
                {u"eta"_s,      u"&#951;"_s}, // greek small letter eta, U+03B7 ISOgrk3
                {u"theta"_s,    u"&#952;"_s}, // greek small letter theta, U+03B8 ISOgrk3
                {u"iota"_s,     u"&#953;"_s}, // greek small letter iota, U+03B9 ISOgrk3
                {u"kappa"_s,    u"&#954;"_s}, // greek small letter kappa, U+03BA ISOgrk3
                {u"lambda"_s,   u"&#955;"_s}, // greek small letter lambda, U+03BB ISOgrk3
                {u"mu"_s,       u"&#956;"_s}, // greek small letter mu, U+03BC ISOgrk3
                {u"nu"_s,       u"&#957;"_s}, // greek small letter nu, U+03BD ISOgrk3
                {u"xi"_s,       u"&#958;"_s}, // greek small letter xi, U+03BE ISOgrk3
                {u"omicron"_s,  u"&#959;"_s}, // greek small letter omicron, U+03BF NEW
                {u"pi"_s,       u"&#960;"_s}, // greek small letter pi, U+03C0 ISOgrk3
                {u"rho"_s,      u"&#961;"_s}, // greek small letter rho, U+03C1 ISOgrk3
                {u"sigmaf"_s,   u"&#962;"_s}, // greek small letter final sigma, U+03C2 ISOgrk3
                {u"sigma"_s,    u"&#963;"_s}, // greek small letter sigma, U+03C3 ISOgrk3
                {u"tau"_s,      u"&#964;"_s}, // greek small letter tau, U+03C4 ISOgrk3
                {u"upsilon"_s,  u"&#965;"_s}, // greek small letter upsilon, U+03C5 ISOgrk3
                {u"phi"_s,      u"&#966;"_s}, // greek small letter phi, U+03C6 ISOgrk3
                {u"chi"_s,      u"&#967;"_s}, // greek small letter chi, U+03C7 ISOgrk3
                {u"psi"_s,      u"&#968;"_s}, // greek small letter psi, U+03C8 ISOgrk3
                {u"omega"_s,    u"&#969;"_s}, // greek small letter omega, U+03C9 ISOgrk3
                {u"thetasym"_s, u"&#977;"_s}, // greek theta symbol, U+03D1 NEW
                {u"upsih"_s,    u"&#978;"_s}, // greek upsilon with hook symbol, U+03D2 NEW
                {u"piv"_s,      u"&#982;"_s}, // greek pi symbol, U+03D6 ISOgrk3

                // General Punctuation
                {u"bull"_s,     u"&#8226;"_s}, // bullet = black small circle, U+2022 ISOpub
                // bullet is NOT the same as bullet operator, U+2219
                {u"hellip"_s,   u"&#8230;"_s}, // horizontal ellipsis = three dot leader, U+2026 ISOpub
                {u"prime"_s,    u"&#8242;"_s}, // prime = minutes = feet, U+2032 ISOtech
                {u"Prime"_s,    u"&#8243;"_s}, // double prime = seconds = inches, U+2033 ISOtech
                {u"oline"_s,    u"&#8254;"_s}, // overline = spacing overscore, U+203E NEW
                {u"frasl"_s,    u"&#8260;"_s}, // fraction slash, U+2044 NEW

                // Letterlike Symbols
                {u"weierp"_s,   u"&#8472;"_s}, // script capital P = power set = Weierstrass p, U+2118 ISOamso
                {u"image"_s,    u"&#8465;"_s}, // black-letter capital I = imaginary part, U+2111 ISOamso
                {u"real"_s,     u"&#8476;"_s}, // black-letter capital R = real part symbol, U+211C ISOamso
                {u"trade"_s,    u"&#8482;"_s}, // trade mark sign, U+2122 ISOnum
                {u"alefsym"_s,  u"&#8501;"_s}, // alef symbol = first transfinite cardinal, U+2135 NEW
                // alef symbol is NOT the same as hebrew letter alef,
                //     U+05D0 although the same glyph could be used to depict both characters

                // Arrows
                {u"larr"_s,     u"&#8592;"_s}, // leftwards arrow, U+2190 ISOnum
                {u"uarr"_s,     u"&#8593;"_s}, // upwards arrow, U+2191 ISOnum
                {u"rarr"_s,     u"&#8594;"_s}, // rightwards arrow, U+2192 ISOnum
                {u"darr"_s,     u"&#8595;"_s}, // downwards arrow, U+2193 ISOnum
                {u"harr"_s,     u"&#8596;"_s}, // left right arrow, U+2194 ISOamsa
                {u"crarr"_s,    u"&#8629;"_s}, // downwards arrow with corner leftwards = carriage return, U+21B5 NEW
                {u"lArr"_s,     u"&#8656;"_s}, // leftwards double arrow, U+21D0 ISOtech
                // Unicode does not say that lArr is the same as the 'is implied by' arrow
                //    but also does not have any other character for that function. So lArr can
                //    be used for 'is implied by' as ISOtech suggests
                {u"uArr"_s,     u"&#8657;"_s}, // upwards double arrow, U+21D1 ISOamsa
                {u"rArr"_s,     u"&#8658;"_s}, // rightwards double arrow, U+21D2 ISOtech
                // Unicode does not say this is the 'implies' character but does not have
                //     another character with this function so rArr can be used for 'implies'
                //     as ISOtech suggests
                {u"dArr"_s,     u"&#8659;"_s}, // downwards double arrow, U+21D3 ISOamsa
                {u"hArr"_s,     u"&#8660;"_s}, // left right double arrow, U+21D4 ISOamsa

                // Mathematical Operators
                {u"forall"_s,   u"&#8704;"_s}, // for all, U+2200 ISOtech
                {u"part"_s,     u"&#8706;"_s}, // partial differential, U+2202 ISOtech
                {u"exist"_s,    u"&#8707;"_s}, // there exists, U+2203 ISOtech
                {u"empty"_s,    u"&#8709;"_s}, // empty set = null set, U+2205 ISOamso
                {u"nabla"_s,    u"&#8711;"_s}, // nabla = backward difference, U+2207 ISOtech
                {u"isin"_s,     u"&#8712;"_s}, // element of, U+2208 ISOtech
                {u"notin"_s,    u"&#8713;"_s}, // not an element of, U+2209 ISOtech
                {u"ni"_s,       u"&#8715;"_s}, // contains as member, U+220B ISOtech
                {u"prod"_s,     u"&#8719;"_s}, // n-ary product = product sign, U+220F ISOamsb
                // prod is NOT the same character as U+03A0 'greek capital letter pi' though
                //     the same glyph might be used for both
                {u"sum"_s,      u"&#8721;"_s}, // n-ary summation, U+2211 ISOamsb
                // sum is NOT the same character as U+03A3 'greek capital letter sigma'
                //     though the same glyph might be used for both
                {u"minus"_s,    u"&#8722;"_s}, // minus sign, U+2212 ISOtech
                {u"lowast"_s,   u"&#8727;"_s}, // asterisk operator, U+2217 ISOtech
                {u"radic"_s,    u"&#8730;"_s}, // square root = radical sign, U+221A ISOtech
                {u"prop"_s,     u"&#8733;"_s}, // proportional to, U+221D ISOtech
                {u"infin"_s,    u"&#8734;"_s}, // infinity, U+221E ISOtech
                {u"ang"_s,      u"&#8736;"_s}, // angle, U+2220 ISOamso
                {u"and"_s,      u"&#8743;"_s}, // logical and = wedge, U+2227 ISOtech
                {u"or"_s,       u"&#8744;"_s}, // logical or = vee, U+2228 ISOtech
                {u"cap"_s,      u"&#8745;"_s}, // intersection = cap, U+2229 ISOtech
                {u"cup"_s,      u"&#8746;"_s}, // union = cup, U+222A ISOtech
                {u"int"_s,      u"&#8747;"_s}, // integral, U+222B ISOtech
                {u"there4"_s,   u"&#8756;"_s}, // therefore, U+2234 ISOtech
                {u"sim"_s,      u"&#8764;"_s}, // tilde operator = varies with = similar to, U+223C ISOtech
                // tilde operator is NOT the same character as the tilde, U+007E,
                //     although the same glyph might be used to represent both
                {u"cong"_s,     u"&#8773;"_s}, // approximately equal to, U+2245 ISOtech
                {u"asymp"_s,    u"&#8776;"_s}, // almost equal to = asymptotic to, U+2248 ISOamsr
                {u"ne"_s,       u"&#8800;"_s}, // not equal to, U+2260 ISOtech
                {u"equiv"_s,    u"&#8801;"_s}, // identical to, U+2261 ISOtech
                {u"le"_s,       u"&#8804;"_s}, // less-than or equal to, U+2264 ISOtech
                {u"ge"_s,       u"&#8805;"_s}, // greater-than or equal to, U+2265 ISOtech
                {u"sub"_s,      u"&#8834;"_s}, // subset of, U+2282 ISOtech
                {u"sup"_s,      u"&#8835;"_s}, // superset of, U+2283 ISOtech
                {u"nsub"_s,     u"&#8836;"_s}, // not a subset of, U+2284 ISOamsn
                {u"sube"_s,     u"&#8838;"_s}, // subset of or equal to, U+2286 ISOtech
                {u"supe"_s,     u"&#8839;"_s}, // superset of or equal to, U+2287 ISOtech
                {u"oplus"_s,    u"&#8853;"_s}, // circled plus = direct sum, U+2295 ISOamsb
                {u"otimes"_s,   u"&#8855;"_s}, // circled times = vector product, U+2297 ISOamsb
                {u"perp"_s,     u"&#8869;"_s}, // up tack = orthogonal to = perpendicular, U+22A5 ISOtech
                {u"sdot"_s,     u"&#8901;"_s}, // dot operator, U+22C5 ISOamsb
                // dot operator is NOT the same character as U+00B7 middle dot

                // Miscellaneous Technical
                {u"lceil"_s,    u"&#8968;"_s}, // left ceiling = APL upstile, U+2308 ISOamsc
                {u"rceil"_s,    u"&#8969;"_s}, // right ceiling, U+2309 ISOamsc
                {u"lfloor"_s,   u"&#8970;"_s}, // left floor = APL downstile, U+230A ISOamsc
                {u"rfloor"_s,   u"&#8971;"_s}, // right floor, U+230B ISOamsc
                {u"lang"_s,     u"&#9001;"_s}, // left-pointing angle bracket = bra, U+2329 ISOtech
                // lang is NOT the same character as U+003C 'less than sign'
                //     or U+2039 'single left-pointing angle quotation mark'
                {u"rang"_s,     u"&#9002;"_s}, // right-pointing angle bracket = ket, U+232A ISOtech
                // rang is NOT the same character as U+003E 'greater than sign'
                //     or U+203A 'single right-pointing angle quotation mark'

                // Geometric Shapes
                {u"loz"_s,      u"&#9674;"_s}, // lozenge, U+25CA ISOpub

                // Miscellaneous Symbols
                {u"spades"_s,   u"&#9824;"_s}, // black spade suit, U+2660 ISOpub
                {u"clubs"_s,    u"&#9827;"_s}, // black club suit = shamrock, U+2663 ISOpub
                {u"hearts"_s,   u"&#9829;"_s}, // black heart suit = valentine, U+2665 ISOpub
                {u"diams"_s,    u"&#9830;"_s}  // black diamond suit, U+2666 ISOpub
            };
            return HTMLEntities.value(name);
        }
    };

    // Ported to Qt from KDElibs4
    QDateTime parseDate(const QString &string, const QDateTime &fallbackDate)
    {
        const char16_t shortDay[][4] =
        {
            u"Mon", u"Tue", u"Wed",
            u"Thu", u"Fri", u"Sat",
            u"Sun"
        };
        const char16_t longDay[][10] =
        {
            u"Monday", u"Tuesday", u"Wednesday",
            u"Thursday", u"Friday", u"Saturday",
            u"Sunday"
        };
        const char16_t shortMonth[][4] =
        {
            u"Jan", u"Feb", u"Mar", u"Apr",
            u"May", u"Jun", u"Jul", u"Aug",
            u"Sep", u"Oct", u"Nov", u"Dec"
        };

        const QString str = string.trimmed();
        if (str.isEmpty())
            return fallbackDate;

        int nyear  = 6;   // indexes within string to values
        int nmonth = 4;
        int nday   = 2;
        int nwday  = 1;
        int nhour  = 7;
        int nmin   = 8;
        int nsec   = 9;
        // Also accept obsolete form "Weekday, DD-Mon-YY HH:MM:SS ±hhmm"
        QRegularExpression rx {u"^(?:([A-Z][a-z]+),\\s*)?(\\d{1,2})(\\s+|-)([^-\\s]+)(\\s+|-)(\\d{2,4})\\s+(\\d\\d):(\\d\\d)(?::(\\d\\d))?\\s+(\\S+)$"_s};
        QRegularExpressionMatch rxMatch;
        QStringList parts;
        if (str.indexOf(rx, 0, &rxMatch) == 0)
        {
            // Check that if date has '-' separators, both separators are '-'.
            parts = rxMatch.capturedTexts();
            const bool h1 = (parts[3] == u"-");
            const bool h2 = (parts[5] == u"-");
            if (h1 != h2)
                return fallbackDate;
        }
        else
        {
            // Check for the obsolete form "Wdy Mon DD HH:MM:SS YYYY"
            rx = QRegularExpression {u"^([A-Z][a-z]+)\\s+(\\S+)\\s+(\\d\\d)\\s+(\\d\\d):(\\d\\d):(\\d\\d)\\s+(\\d\\d\\d\\d)$"_s};
            if (str.indexOf(rx, 0, &rxMatch) != 0)
                return fallbackDate;

            nyear  = 7;
            nmonth = 2;
            nday   = 3;
            nwday  = 1;
            nhour  = 4;
            nmin   = 5;
            nsec   = 6;
            parts = rxMatch.capturedTexts();
        }

        bool ok[4];
        const int day = parts[nday].toInt(&ok[0]);
        int year = parts[nyear].toInt(&ok[1]);
        const int hour = parts[nhour].toInt(&ok[2]);
        const int minute = parts[nmin].toInt(&ok[3]);
        if (!ok[0] || !ok[1] || !ok[2] || !ok[3])
            return fallbackDate;

        int second = 0;
        if (!parts[nsec].isEmpty())
        {
            second = parts[nsec].toInt(&ok[0]);
            if (!ok[0])
                return fallbackDate;
        }

        const bool leapSecond = (second == 60);
        if (leapSecond)
            second = 59;   // apparently a leap second - validate below, once time zone is known
        int month = 0;
        for ( ; (month < 12) && (parts[nmonth] != shortMonth[month]); ++month);
        int dayOfWeek = -1;
        if (!parts[nwday].isEmpty())
        {
            // Look up the weekday name
            while ((++dayOfWeek < 7) && (shortDay[dayOfWeek] != parts[nwday]));
            if (dayOfWeek >= 7)
                for (dayOfWeek = 0; (dayOfWeek < 7) && (longDay[dayOfWeek] != parts[nwday]); ++dayOfWeek);
        }

        //       if (month >= 12 || dayOfWeek >= 7
        //       ||  (dayOfWeek < 0  &&  format == RFCDateDay))
        //         return QDateTime;
        const int i = parts[nyear].size();
        if (i < 4)
        {
            // It's an obsolete year specification with less than 4 digits
            year += ((i == 2) && (year < 50)) ? 2000 : 1900;
        }

        // Parse the UTC offset part
        int offset = 0;           // set default to '-0000'
        bool negOffset = false;
        if (parts.count() > 10)
        {
            rx = QRegularExpression {u"^([+-])(\\d\\d)(\\d\\d)$"_s};
            if (parts[10].indexOf(rx, 0, &rxMatch) == 0)
            {
                // It's a UTC offset ±hhmm
                parts = rxMatch.capturedTexts();
                offset = parts[2].toInt(&ok[0]) * 3600;
                const int offsetMin = parts[3].toInt(&ok[1]);
                if (!ok[0] || !ok[1] || offsetMin > 59)
                    return {};
                offset += offsetMin * 60;
                negOffset = (parts[1] == u"-");
                if (negOffset)
                    offset = -offset;
            }
            else
            {
                // Check for an obsolete time zone name
                const QByteArray zone = parts[10].toLatin1();
                if ((zone.length() == 1) && (isalpha(zone[0])) && (toupper(zone[0]) != 'J'))
                {
                    negOffset = true;    // military zone: RFC 2822 treats as '-0000'
                }
                else if ((zone != "UT") && (zone != "GMT"))
                { // treated as '+0000'
                    offset = (zone == "EDT")
                            ? -4 * 3600
                            : ((zone == "EST") || (zone == "CDT"))
                              ? -5 * 3600
                              : ((zone == "CST") || (zone == "MDT"))
                                ? -6 * 3600
                                : ((zone == "MST") || (zone == "PDT"))
                                  ? -7 * 3600
                                  : (zone == "PST")
                                    ? -8 * 3600
                                    : 0;
                    if (!offset)
                    {
                        // Check for any other alphabetic time zone
                        bool nonalpha = false;
                        for (int i = 0, end = zone.size(); (i < end) && !nonalpha; ++i)
                            nonalpha = !isalpha(zone[i]);
                        if (nonalpha)
                            return {};
                        // TODO: Attempt to recognize the time zone abbreviation?
                        negOffset = true;    // unknown time zone: RFC 2822 treats as '-0000'
                    }
                }
            }
        }

        const QDate qDate(year, month + 1, day);   // convert date, and check for out-of-range
        if (!qDate.isValid())
            return fallbackDate;

        const QTime qTime(hour, minute, second);
        QDateTime result(qDate, qTime, QTimeZone::UTC);
        if (offset)
            result = result.addSecs(-offset);
        if (!result.isValid())
            return fallbackDate;    // invalid date/time

        if (leapSecond)
        {
            // Validate a leap second time. Leap seconds are inserted after 23:59:59 UTC.
            // Convert the time to UTC and check that it is 00:00:00.
            if ((hour*3600 + minute*60 + 60 - offset + 86400*5) % 86400)   // (max abs(offset) is 100 hours)
                return fallbackDate;    // the time isn't the last second of the day
        }

        return result;
    }
}

const int PARSINGRESULT_TYPEID = qRegisterMetaType<RSS::Private::ParsingResult>();

RSS::Private::Parser::Parser(const QString &lastBuildDate)
{
    m_result.lastBuildDate = lastBuildDate;
}

// read and create items from a rss document
void RSS::Private::Parser::parse(const QByteArray &feedData)
{
    QXmlStreamReader xml {feedData};
    m_fallbackDate = QDateTime::currentDateTime();
    XmlStreamEntityResolver resolver;
    xml.setEntityResolver(&resolver);
    bool foundChannel = false;

    while (xml.readNextStartElement())
    {
        if (xml.name() == u"rss")
        {
            // Find channels
            while (xml.readNextStartElement())
            {
                if (xml.name() == u"channel")
                {
                    parseRSSChannel(xml);
                    foundChannel = true;
                    break;
                }

                qDebug() << "Skip rss item: " << xml.name();
                xml.skipCurrentElement();
            }
            break;
        }
        if (xml.name() == u"feed")
        { // Atom feed
            parseAtomChannel(xml);
            foundChannel = true;
            break;
        }

        qDebug() << "Skip root item: " << xml.name();
        xml.skipCurrentElement();
    }

    if (xml.hasError())
    {
        m_result.error = tr("%1 (line: %2, column: %3, offset: %4).")
                .arg(xml.errorString()).arg(xml.lineNumber())
                .arg(xml.columnNumber()).arg(xml.characterOffset());
    }
    else if (!foundChannel)
    {
        m_result.error = tr("Invalid RSS feed.");
    }

    emit finished(m_result);
    m_result.articles.clear();
    m_result.error.clear();
    m_articleIDs.clear();
}

void RSS::Private::Parser::parseRssArticle(QXmlStreamReader &xml)
{
    QVariantHash article;
    QString altTorrentUrl;

    while (!xml.atEnd())
    {
        xml.readNext();
        const QString name(xml.name().toString());

        if (xml.isEndElement() && (name == u"item"))
            break;

        if (xml.isStartElement())
        {
            if (name == u"title")
            {
                article[Article::KeyTitle] = xml.readElementText().trimmed();
            }
            else if (name == u"enclosure")
            {
                if (xml.attributes().value(u"type"_s) == u"application/x-bittorrent")
                    article[Article::KeyTorrentURL] = xml.attributes().value(u"url"_s).toString();
                else if (xml.attributes().value(u"type"_s).isEmpty())
                    altTorrentUrl = xml.attributes().value(u"url"_s).toString();
            }
            else if (name == u"link")
            {
                const QString text {xml.readElementText().trimmed()};
                if (text.startsWith(u"magnet:", Qt::CaseInsensitive))
                    article[Article::KeyTorrentURL] = text; // magnet link instead of a news URL
                else
                    article[Article::KeyLink] = text;
            }
            else if (name == u"description")
            {
                article[Article::KeyDescription] = xml.readElementText(QXmlStreamReader::IncludeChildElements);
            }
            else if (name == u"pubDate")
            {
                article[Article::KeyDate] = parseDate(xml.readElementText().trimmed(), m_fallbackDate);
            }
            else if (name == u"author")
            {
                article[Article::KeyAuthor] = xml.readElementText().trimmed();
            }
            else if (name == u"guid")
            {
                article[Article::KeyId] = xml.readElementText().trimmed();
            }
            else
            {
                article[name] = xml.readElementText(QXmlStreamReader::IncludeChildElements);
            }
        }
    }

    if (article[Article::KeyTorrentURL].toString().isEmpty())
        article[Article::KeyTorrentURL] = altTorrentUrl;

    addArticle(article);
}

void RSS::Private::Parser::parseRSSChannel(QXmlStreamReader &xml)
{
    while (!xml.atEnd())
    {
        xml.readNext();

        if (xml.isStartElement())
        {
            if (xml.name() == u"title")
            {
                m_result.title = xml.readElementText();
            }
            else if (xml.name() == u"lastBuildDate")
            {
                const QString lastBuildDate = xml.readElementText();
                if (!lastBuildDate.isEmpty())
                {
                    if (m_result.lastBuildDate == lastBuildDate)
                    {
                        qDebug() << "The RSS feed has not changed since last time, aborting parsing.";
                        return;
                    }
                    m_result.lastBuildDate = lastBuildDate;
                }
            }
            else if (xml.name() == u"item")
            {
                parseRssArticle(xml);
            }
        }
    }
}

void RSS::Private::Parser::parseAtomArticle(QXmlStreamReader &xml)
{
    QVariantHash article;
    bool doubleContent = false;

    while (!xml.atEnd())
    {
        xml.readNext();
        const QString name(xml.name().toString());

        if (xml.isEndElement() && (name == u"entry"))
            break;

        if (xml.isStartElement())
        {
            if (name == u"title")
            {
                article[Article::KeyTitle] = xml.readElementText().trimmed();
            }
            else if (name == u"link")
            {
                const QString link = (xml.attributes().isEmpty()
                                ? xml.readElementText().trimmed()
                                : xml.attributes().value(u"href"_s).toString());

                if (link.startsWith(u"magnet:", Qt::CaseInsensitive))
                {
                    article[Article::KeyTorrentURL] = link; // magnet link instead of a news URL
                }
                else
                {
                    // Atom feeds can have relative links, work around this and
                    // take the stress of figuring article full URI from UI
                    // Assemble full URI
                    article[Article::KeyLink] = (m_baseUrl.isEmpty() ? link : m_baseUrl + link);
                }
            }
            else if ((name == u"summary") || (name == u"content"))
            {
                if (doubleContent)
                { // Duplicate content -> ignore
                    xml.skipCurrentElement();
                    continue;
                }

                // Try to also parse broken articles, which don't use html '&' escapes
                // Actually works great for non-broken content too
                const QString feedText = xml.readElementText(QXmlStreamReader::IncludeChildElements).trimmed();
                if (!feedText.isEmpty())
                {
                    article[Article::KeyDescription] = feedText;
                    doubleContent = true;
                }
            }
            else if (name == u"updated")
            {
                // ATOM uses standard compliant date, don't do fancy stuff
                const QDateTime articleDate = QDateTime::fromString(xml.readElementText().trimmed(), Qt::ISODate);
                article[Article::KeyDate] = (articleDate.isValid() ? articleDate : m_fallbackDate);
            }
            else if (name == u"author")
            {
                while (xml.readNextStartElement())
                {
                    if (xml.name() == u"name")
                        article[Article::KeyAuthor] = xml.readElementText().trimmed();
                    else
                        xml.skipCurrentElement();
                }
            }
            else if (name == u"id")
            {
                article[Article::KeyId] = xml.readElementText().trimmed();
            }
            else
            {
                article[name] = xml.readElementText(QXmlStreamReader::IncludeChildElements);
            }
        }
    }

    addArticle(article);
}

void RSS::Private::Parser::parseAtomChannel(QXmlStreamReader &xml)
{
    m_baseUrl = xml.attributes().value(u"xml:base"_s).toString();

    while (!xml.atEnd())
    {
        xml.readNext();

        if (xml.isStartElement())
        {
            if (xml.name() == u"title")
            {
                m_result.title = xml.readElementText();
            }
            else if (xml.name() == u"updated")
            {
                const QString lastBuildDate = xml.readElementText();
                if (!lastBuildDate.isEmpty())
                {
                    if (m_result.lastBuildDate == lastBuildDate)
                    {
                        qDebug() << "The RSS feed has not changed since last time, aborting parsing.";
                        return;
                    }
                    m_result.lastBuildDate = lastBuildDate;
                }
            }
            else if (xml.name() == u"entry")
            {
                parseAtomArticle(xml);
            }
        }
    }
}

void RSS::Private::Parser::addArticle(QVariantHash article)
{
    QVariant &torrentURL = article[Article::KeyTorrentURL];
    if (torrentURL.toString().isEmpty())
        torrentURL = article.value(Article::KeyLink);

    // If item does not have an ID, fall back to some other identifier.
    QVariant &localId = article[Article::KeyId];
    if (localId.toString().isEmpty())
    {
        localId = article.value(Article::KeyTorrentURL);
        if (localId.toString().isEmpty())
        {
            localId = article.value(Article::KeyTitle);
            if (localId.toString().isEmpty())
            {
                // The article could not be uniquely identified
                // since it has no appropriate data.
                // Just ignore it.
                return;
            }
        }
    }

    if (m_articleIDs.contains(localId.toString()))
    {
        // The article could not be uniquely identified
        // since the Feed has duplicate identifiers.
        // Just ignore it.
        return;
    }

    m_articleIDs.insert(localId.toString());
    m_result.articles.prepend(article);
}
</file>

<file path="base/rss/rss_parser.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015-2025  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2012  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QDateTime>
#include <QList>
#include <QObject>
#include <QSet>
#include <QString>
#include <QVariantHash>

class QXmlStreamReader;

namespace RSS::Private
{
    struct ParsingResult
    {
        QString error;
        QString lastBuildDate;
        QString title;
        QList<QVariantHash> articles;
    };

    class Parser final : public QObject
    {
        Q_OBJECT
        Q_DISABLE_COPY_MOVE(Parser)

    public:
        explicit Parser(const QString &lastBuildDate);
        void parse(const QByteArray &feedData);

    signals:
        void finished(const RSS::Private::ParsingResult &result);

    private:
        void parseRssArticle(QXmlStreamReader &xml);
        void parseRSSChannel(QXmlStreamReader &xml);
        void parseAtomArticle(QXmlStreamReader &xml);
        void parseAtomChannel(QXmlStreamReader &xml);
        void addArticle(QVariantHash article);

        QDateTime m_fallbackDate;
        QString m_baseUrl;
        ParsingResult m_result;
        QSet<QString> m_articleIDs;
    };
}

Q_DECLARE_METATYPE(RSS::Private::ParsingResult)
</file>

<file path="base/rss/rss_session.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017-2025  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2024  Jonathan Ketchker
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "rss_session.h"

#include <chrono>

#include <QDebug>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonValue>
#include <QString>
#include <QThread>

#include "../asyncfilestorage.h"
#include "../global.h"
#include "../logger.h"
#include "../profile.h"
#include "../settingsstorage.h"
#include "../utils/fs.h"
#include "../utils/io.h"
#include "rss_article.h"
#include "rss_feed.h"
#include "rss_folder.h"
#include "rss_item.h"

const QString CONF_FOLDER_NAME = u"rss"_s;
const QString DATA_FOLDER_NAME = u"rss/articles"_s;
const QString FEEDS_FILE_NAME = u"feeds.json"_s;

using namespace std::chrono_literals;
using namespace RSS;

QPointer<Session> Session::m_instance = nullptr;

Session::Session()
    : m_storeProcessingEnabled(u"RSS/Session/EnableProcessing"_s)
    , m_storeRefreshInterval(u"RSS/Session/RefreshInterval"_s, 30)
    , m_storeFetchDelay(u"RSS/Session/FetchDelay"_s, 2)
    , m_storeMaxArticlesPerFeed(u"RSS/Session/MaxArticlesPerFeed"_s, 50)
    , m_workingThread(new QThread)
{
    Q_ASSERT(!m_instance); // only one instance is allowed
    m_instance = this;

    m_confFileStorage = new AsyncFileStorage(specialFolderLocation(SpecialFolder::Config) / Path(CONF_FOLDER_NAME));
    m_confFileStorage->moveToThread(m_workingThread.get());
    connect(m_workingThread.get(), &QThread::finished, m_confFileStorage, &AsyncFileStorage::deleteLater);
    connect(m_confFileStorage, &AsyncFileStorage::failed, [](const Path &fileName, const QString &errorString)
    {
        LogMsg(tr("Couldn't save RSS session configuration. File: \"%1\". Error: \"%2\"")
               .arg(fileName.toString(), errorString), Log::WARNING);
    });

    m_dataFileStorage = new AsyncFileStorage(specialFolderLocation(SpecialFolder::Data) / Path(DATA_FOLDER_NAME));
    m_dataFileStorage->moveToThread(m_workingThread.get());
    connect(m_workingThread.get(), &QThread::finished, m_dataFileStorage, &AsyncFileStorage::deleteLater);
    connect(m_dataFileStorage, &AsyncFileStorage::failed, [](const Path &fileName, const QString &errorString)
    {
        LogMsg(tr("Couldn't save RSS session data. File: \"%1\". Error: \"%2\"")
               .arg(fileName.toString(), errorString), Log::WARNING);
    });

    m_itemsByPath.insert(u""_s, new Folder); // root folder

    m_workingThread->setObjectName("RSS::Session m_workingThread");
    m_workingThread->start();
    load();

    m_refreshTimer.setSingleShot(true);
    connect(&m_refreshTimer, &QTimer::timeout, this, &Session::refresh);
    if (isProcessingEnabled())
        refresh();

    // Remove legacy/corrupted settings
    // (at least on Windows, QSettings is case-insensitive and it can get
    // confused when asked about settings that differ only in their case)
    auto *settingsStorage = SettingsStorage::instance();
    settingsStorage->removeValue(u"Rss/streamList"_s);
    settingsStorage->removeValue(u"Rss/streamAlias"_s);
    settingsStorage->removeValue(u"Rss/open_folders"_s);
    settingsStorage->removeValue(u"Rss/qt5/splitter_h"_s);
    settingsStorage->removeValue(u"Rss/qt5/splitterMain"_s);
    settingsStorage->removeValue(u"Rss/hosts_cookies"_s);
    settingsStorage->removeValue(u"RSS/streamList"_s);
    settingsStorage->removeValue(u"RSS/streamAlias"_s);
    settingsStorage->removeValue(u"RSS/open_folders"_s);
    settingsStorage->removeValue(u"RSS/qt5/splitter_h"_s);
    settingsStorage->removeValue(u"RSS/qt5/splitterMain"_s);
    settingsStorage->removeValue(u"RSS/hosts_cookies"_s);
    settingsStorage->removeValue(u"Rss/Session/EnableProcessing"_s);
    settingsStorage->removeValue(u"Rss/Session/RefreshInterval"_s);
    settingsStorage->removeValue(u"Rss/Session/MaxArticlesPerFeed"_s);
    settingsStorage->removeValue(u"Rss/AutoDownloader/EnableProcessing"_s);
}

Session::~Session()
{
    qDebug() << "Deleting RSS Session...";

    //store();
    delete m_itemsByPath[u""_s]; // deleting root folder

    qDebug() << "RSS Session deleted.";
}

Session *Session::instance()
{
    return m_instance;
}

nonstd::expected<Folder *, QString> Session::addFolder(const QString &path)
{
    const nonstd::expected<Folder *, QString> result = prepareItemDest(path);
    if (!result)
        return result.get_unexpected();

    auto *destFolder = result.value();
    auto *folder = new Folder(path);
    addItem(folder, destFolder);
    store();
    return folder;
}

nonstd::expected<Feed *, QString> Session::addFeed(const QString &url, const QString &path, const std::chrono::seconds refreshInterval)
{
    if (m_feedsByURL.contains(url))
        return nonstd::make_unexpected(tr("RSS feed with given URL already exists: %1.").arg(url));

    const nonstd::expected<Folder *, QString> result = prepareItemDest(path);
    if (!result)
        return result.get_unexpected();

    auto *destFolder = result.value();
    auto *feed = new Feed(this, generateUID(), url, path, refreshInterval);
    addItem(feed, destFolder);
    store();
    if (isProcessingEnabled())
        refreshFeed(feed, std::chrono::system_clock::now());

    return feed;
}

nonstd::expected<void, QString> Session::setFeedURL(const QString &path, const QString &url)
{
    auto *feed = qobject_cast<Feed *>(m_itemsByPath.value(path));
    if (!feed)
        return nonstd::make_unexpected(tr("Feed doesn't exist: %1.").arg(path));

    return setFeedURL(feed, url);
}

nonstd::expected<void, QString> Session::setFeedURL(Feed *feed, const QString &url)
{
    Q_ASSERT(feed);

    if (url == feed->url())
        return {};

    if (m_feedsByURL.contains(url))
        return nonstd::make_unexpected(tr("RSS feed with given URL already exists: %1.").arg(url));

    m_feedsByURL[url] = m_feedsByURL.take(feed->url());
    feed->setURL(url);
    store();
    if (isProcessingEnabled())
        refreshFeed(feed, std::chrono::system_clock::now());

    return {};
}

nonstd::expected<void, QString> Session::moveItem(const QString &itemPath, const QString &destPath)
{
    if (itemPath.isEmpty())
        return nonstd::make_unexpected(tr("Cannot move root folder."));

    auto *item = m_itemsByPath.value(itemPath);
    if (!item)
        return nonstd::make_unexpected(tr("Item doesn't exist: %1.").arg(itemPath));

    return moveItem(item, destPath);
}

nonstd::expected<void, QString> Session::moveItem(Item *item, const QString &destPath)
{
    Q_ASSERT(item);
    Q_ASSERT(item != rootFolder());

    if (item->path() == destPath)
        return {};

    if (auto *folder = static_cast<Folder *>(item)) // if `item` is a `Folder`
    {
        if (destPath.startsWith(folder->path() + Item::PathSeparator))
            return nonstd::make_unexpected(tr("Can't move a folder into itself or its subfolders."));
    }

    const nonstd::expected<Folder *, QString> result = prepareItemDest(destPath);
    if (!result)
        return result.get_unexpected();

    auto *destFolder = result.value();
    auto *srcFolder = static_cast<Folder *>(m_itemsByPath.value(Item::parentPath(item->path())));
    if (srcFolder != destFolder)
    {
        srcFolder->removeItem(item);
        destFolder->addItem(item);
    }
    m_itemsByPath.insert(destPath, m_itemsByPath.take(item->path()));
    item->setPath(destPath);
    store();
    return {};
}

nonstd::expected<void, QString> Session::removeItem(const QString &itemPath)
{
    if (itemPath.isEmpty())
        return nonstd::make_unexpected(tr("Cannot delete root folder."));

    auto *item = m_itemsByPath.value(itemPath);
    if (!item)
        return nonstd::make_unexpected(tr("Item doesn't exist: %1.").arg(itemPath));

    emit itemAboutToBeRemoved(item);
    item->cleanup();

    auto *folder = static_cast<Folder *>(m_itemsByPath.value(Item::parentPath(item->path())));
    folder->removeItem(item);
    delete item;
    store();
    return {};
}

QList<Item *> Session::items() const
{
    return m_itemsByPath.values();
}

Item *Session::itemByPath(const QString &path) const
{
    return m_itemsByPath.value(path);
}

void Session::load()
{
    const int fileMaxSize = 10 * 1024 * 1024;
    const Path path = m_confFileStorage->storageDir() / Path(FEEDS_FILE_NAME);

    const auto readResult = Utils::IO::readFile(path, fileMaxSize);
    if (!readResult)
    {
        if (readResult.error().status == Utils::IO::ReadError::NotExist)
        {
            loadLegacy();
            store(); // convert to new format
            return;
        }

        LogMsg(tr("Failed to read RSS session data. %1").arg(readResult.error().message), Log::WARNING);
        return;
    }

    QJsonParseError jsonError;
    const QJsonDocument jsonDoc = QJsonDocument::fromJson(readResult.value(), &jsonError);
    if (jsonError.error != QJsonParseError::NoError)
    {
        LogMsg(tr("Failed to parse RSS session data. File: \"%1\". Error: \"%2\"")
            .arg(path.toString(), jsonError.errorString()), Log::WARNING);
        return;
    }

    if (!jsonDoc.isObject())
    {
        LogMsg(tr("Failed to load RSS session data. File: \"%1\". Error: \"Invalid data format.\"")
            .arg(path.toString()), Log::WARNING);
        return;
    }

    if (loadFolder(jsonDoc.object(), rootFolder()))
        store(); // convert to updated format
}

bool Session::loadFolder(const QJsonObject &jsonObj, Folder *folder)
{
    bool updated = false;
    for (const QString &key : asConst(jsonObj.keys()))
    {
        const QJsonValue val {jsonObj[key]};
        if (val.isString())
        {
            // previous format (reduced form) doesn't contain UID
            QString url = val.toString();
            if (url.isEmpty())
                url = key;
            addFeedToFolder(generateUID(), url, key, folder, 0s);
            updated = true;
        }
        else if (val.isObject())
        {
            const QJsonObject valObj {val.toObject()};
            if (valObj.contains(u"url"))
            {
                if (!valObj[u"url"].isString())
                {
                    LogMsg(tr("Couldn't load RSS feed. Feed: \"%1\". Reason: URL is required.")
                           .arg(u"%1\\%2"_s.arg(folder->path(), key)), Log::WARNING);
                    continue;
                }

                QUuid uid;
                if (valObj.contains(u"uid"))
                {
                    uid = QUuid {valObj[u"uid"].toString()};
                    if (uid.isNull())
                    {
                        LogMsg(tr("Couldn't load RSS feed. Feed: \"%1\". Reason: UID is invalid.")
                               .arg(u"%1\\%2"_s.arg(folder->path(), key)), Log::WARNING);
                        continue;
                    }

                    if (m_feedsByUID.contains(uid))
                    {
                        LogMsg(tr("Duplicate RSS feed found. UID: \"%1\". Error: Configuration seems to be corrupted.")
                               .arg(uid.toString()), Log::WARNING);
                        continue;
                    }
                }
                else
                {
                    // previous format doesn't contain UID
                    uid = generateUID();
                    updated = true;
                }

                const auto refreshInterval = std::chrono::seconds(valObj[u"refreshInterval"].toInteger());

                addFeedToFolder(uid, valObj[u"url"].toString(), key, folder, refreshInterval);
            }
            else
            {
                if (loadFolder(valObj, addSubfolder(key, folder)))
                    updated = true;
            }
        }
        else
        {
            LogMsg(tr("Couldn't load RSS item. Item: \"%1\". Invalid data format.")
                   .arg(u"%1\\%2"_s.arg(folder->path(), key)), Log::WARNING);
        }
    }

    return updated;
}

void Session::loadLegacy()
{
    const auto legacyFeedPaths = SettingsStorage::instance()->loadValue<QStringList>(u"Rss/streamList"_s);
    const auto feedAliases = SettingsStorage::instance()->loadValue<QStringList>(u"Rss/streamAlias"_s);
    if (legacyFeedPaths.size() != feedAliases.size())
    {
        LogMsg(tr("Corrupted RSS list, not loading it."), Log::WARNING);
        return;
    }

    uint i = 0;
    for (QString legacyPath : legacyFeedPaths)
    {
        if (legacyPath.startsWith(Item::PathSeparator))
        {
#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
            legacyPath.slice(1);
#else
            legacyPath.remove(0, 1);
#endif
        }
        const QString parentFolderPath = Item::parentPath(legacyPath);
        const QString feedUrl = Item::relativeName(legacyPath);

        for (const QString &folderPath : asConst(Item::expandPath(parentFolderPath)))
            addFolder(folderPath);

        const QString feedPath = feedAliases[i].isEmpty()
                ? legacyPath
                : Item::joinPath(parentFolderPath, feedAliases[i]);
        addFeed(feedUrl, feedPath);
        ++i;
    }
}

void Session::store()
{
    m_confFileStorage->store(Path(FEEDS_FILE_NAME)
            , QJsonDocument(rootFolder()->toJsonValue().toObject()).toJson());
}

nonstd::expected<Folder *, QString> Session::prepareItemDest(const QString &path)
{
    if (!Item::isValidPath(path))
        return nonstd::make_unexpected(tr("Incorrect RSS Item path: %1.").arg(path));

    if (m_itemsByPath.contains(path))
        return nonstd::make_unexpected(tr("RSS item with given path already exists: %1.").arg(path));

    const QString destFolderPath = Item::parentPath(path);
    auto *destFolder = qobject_cast<Folder *>(m_itemsByPath.value(destFolderPath));
    if (!destFolder)
        return nonstd::make_unexpected(tr("Parent folder doesn't exist: %1.").arg(destFolderPath));

    return destFolder;
}

Folder *Session::addSubfolder(const QString &name, Folder *parentFolder)
{
    auto *folder = new Folder(Item::joinPath(parentFolder->path(), name));
    addItem(folder, parentFolder);
    return folder;
}

Feed *Session::addFeedToFolder(const QUuid &uid, const QString &url, const QString &name, Folder *parentFolder, const std::chrono::seconds refreshInterval)
{
    auto *feed = new Feed(this, uid, url, Item::joinPath(parentFolder->path(), name), refreshInterval);
    addItem(feed, parentFolder);
    return feed;
}

void Session::addItem(Item *item, Folder *destFolder)
{
    if (auto *feed = qobject_cast<Feed *>(item))
    {
        connect(feed, &Feed::titleChanged, this, &Session::handleFeedTitleChanged);
        connect(feed, &Feed::iconLoaded, this, &Session::feedIconLoaded);
        connect(feed, &Feed::stateChanged, this, &Session::feedStateChanged);
        connect(feed, &Feed::urlChanged, this, [this, feed](const QString &oldURL)
        {
            if (feed->name() == oldURL)
            {
                // If feed still use an URL as a name trying to rename it to match new URL...
                moveItem(feed, Item::joinPath(Item::parentPath(feed->path()), feed->url()));
            }

            emit feedURLChanged(feed, oldURL);
        });
        connect(feed, &Feed::refreshIntervalChanged, this, [this, feed](const std::chrono::seconds oldRefreshInterval)
        {
            store();

            std::chrono::system_clock::time_point &nextRefresh = m_refreshTimepoints[feed];
            if (nextRefresh > std::chrono::system_clock::time_point())
                nextRefresh += feed->refreshInterval() - oldRefreshInterval;

            if (isProcessingEnabled())
            {
                const std::chrono::seconds oldEffectiveRefreshInterval = (oldRefreshInterval > 0s)
                        ? oldRefreshInterval : std::chrono::minutes(refreshInterval());
                if (feed->refreshInterval() < oldEffectiveRefreshInterval)
                    refresh();
            }
        });
        m_feedsByUID[feed->uid()] = feed;
        m_feedsByURL[feed->url()] = feed;
        m_refreshTimepoints.emplace(feed, std::chrono::system_clock::time_point());
    }

    connect(item, &Item::pathChanged, this, &Session::itemPathChanged);
    connect(item, &Item::aboutToBeDestroyed, this, &Session::handleItemAboutToBeDestroyed);
    m_itemsByPath[item->path()] = item;
    destFolder->addItem(item);
    emit itemAdded(item);
}

bool Session::isProcessingEnabled() const
{
    return m_storeProcessingEnabled;
}

void Session::setProcessingEnabled(const bool enabled)
{
    if (m_storeProcessingEnabled != enabled)
    {
        m_storeProcessingEnabled = enabled;
        if (enabled)
            refresh();
        else
            m_refreshTimer.stop();

        emit processingStateChanged(enabled);
    }
}

AsyncFileStorage *Session::confFileStorage() const
{
    return m_confFileStorage;
}

AsyncFileStorage *Session::dataFileStorage() const
{
    return m_dataFileStorage;
}

Folder *Session::rootFolder() const
{
    return static_cast<Folder *>(m_itemsByPath.value(u""_s));
}

QList<Feed *> Session::feeds() const
{
    return m_feedsByURL.values();
}

Feed *Session::feedByURL(const QString &url) const
{
    return m_feedsByURL.value(url);
}

int Session::refreshInterval() const
{
    return m_storeRefreshInterval;
}

void Session::setRefreshInterval(const int refreshInterval)
{
    if (m_storeRefreshInterval != refreshInterval)
    {
        m_storeRefreshInterval = refreshInterval;
        m_refreshTimer.start(std::chrono::minutes(m_storeRefreshInterval));
    }
}

std::chrono::seconds Session::fetchDelay() const
{
    return std::chrono::seconds(m_storeFetchDelay);
}

void Session::setFetchDelay(const std::chrono::seconds delay)
{
    if (delay == fetchDelay())
        return;
    m_storeFetchDelay = static_cast<qint64>(delay.count());
    rootFolder()->updateFetchDelay();
}

QThread *Session::workingThread() const
{
    return m_workingThread.get();
}

void Session::handleItemAboutToBeDestroyed(Item *item)
{
    m_itemsByPath.remove(item->path());
    auto *feed = qobject_cast<Feed *>(item);
    if (feed)
    {
        m_feedsByUID.remove(feed->uid());
        m_feedsByURL.remove(feed->url());
        m_refreshTimepoints.remove(feed);
    }
}

void Session::handleFeedTitleChanged(Feed *feed)
{
    if (feed->name() == feed->url())
    {
        // Now we have something better than a URL.
        // Trying to rename feed...
        moveItem(feed, Item::joinPath(Item::parentPath(feed->path()), feed->title()));
    }
}

QUuid Session::generateUID() const
{
    QUuid uid = QUuid::createUuid();
    while (m_feedsByUID.contains(uid))
        uid = QUuid::createUuid();

    return uid;
}

int Session::maxArticlesPerFeed() const
{
    return m_storeMaxArticlesPerFeed;
}

void Session::setMaxArticlesPerFeed(const int n)
{
    if (m_storeMaxArticlesPerFeed != n)
    {
        m_storeMaxArticlesPerFeed = n;
        emit maxArticlesPerFeedChanged(n);
    }
}

void Session::refresh()
{
    const auto currentTimepoint = std::chrono::system_clock::now();
    std::chrono::seconds nextRefreshInterval = 0s;
    for (auto it = m_refreshTimepoints.begin(); it != m_refreshTimepoints.end(); ++it)
    {
        Feed *feed = it.key();
        std::chrono::system_clock::time_point &timepoint = it.value();

        if (timepoint <= currentTimepoint)
            timepoint = refreshFeed(feed, currentTimepoint);

        const auto interval = std::chrono::duration_cast<std::chrono::seconds>(timepoint - currentTimepoint);
        if ((interval < nextRefreshInterval) || (nextRefreshInterval == 0s))
            nextRefreshInterval = interval;
    }

    m_refreshTimer.start(nextRefreshInterval);
}

std::chrono::system_clock::time_point Session::refreshFeed(Feed *feed, const std::chrono::system_clock::time_point &currentTimepoint)
{
    feed->refresh();
    const std::chrono::seconds feedRefreshInterval = feed->refreshInterval();
    const std::chrono::seconds effectiveRefreshInterval = (feedRefreshInterval > 0s) ? feedRefreshInterval : std::chrono::minutes(refreshInterval());
    return currentTimepoint + effectiveRefreshInterval;
}
</file>

<file path="base/rss/rss_session.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017-2025  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2024  Jonathan Ketchker
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2010  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

/*
 * RSS Session configuration file format (JSON):
 *
 * =============== BEGIN ===============
 * {
 *     "folder1": {
 *         "subfolder1": {
 *             "Feed name 1 (Alias)": {
 *                 "uid": "feed unique identifier",
 *                 "url": "http://some-feed-url1"
 *             }
 *             "Feed name 2 (Alias)": {
 *                 "uid": "feed unique identifier",
 *                 "url": "http://some-feed-url2"
 *             }
 *         },
 *         "subfolder2": {},
 *         "Feed name 3 (Alias)": {
 *             "uid": "feed unique identifier",
 *             "url": "http://some-feed-url3"
 *         }
 *     },
 *     "folder2": {},
 *     "folder3": {}
 * }
 * ================ END ================
 *
 * 1.   Document is JSON object (the same as Folder)
 * 2.   Folder is JSON object (keys are Item names, values are Items)
 * 3.   Feed is JSON object (keys are property names, values are property values; 'uid' and 'url' are required)
 */

#include <chrono>

#include <QHash>
#include <QObject>
#include <QPointer>
#include <QTimer>

#include "base/3rdparty/expected.hpp"
#include "base/settingvalue.h"
#include "base/utils/thread.h"

class QThread;

class Application;
class AsyncFileStorage;

namespace RSS
{
    class Feed;
    class Folder;
    class Item;

    class Session final : public QObject
    {
        Q_OBJECT
        Q_DISABLE_COPY_MOVE(Session)

        friend class ::Application;

        Session();
        ~Session() override;

    public:
        static Session *instance();

        bool isProcessingEnabled() const;
        void setProcessingEnabled(bool enabled);

        QThread *workingThread() const;
        AsyncFileStorage *confFileStorage() const;
        AsyncFileStorage *dataFileStorage() const;

        int maxArticlesPerFeed() const;
        void setMaxArticlesPerFeed(int n);

        int refreshInterval() const;
        void setRefreshInterval(int refreshInterval);

        std::chrono::seconds fetchDelay() const;
        void setFetchDelay(std::chrono::seconds delay);

        nonstd::expected<Folder *, QString> addFolder(const QString &path);
        nonstd::expected<Feed *, QString> addFeed(const QString &url, const QString &path, std::chrono::seconds refreshInterval = {});
        nonstd::expected<void, QString> setFeedURL(const QString &path, const QString &url);
        nonstd::expected<void, QString> setFeedURL(Feed *feed, const QString &url);
        nonstd::expected<void, QString> moveItem(const QString &itemPath, const QString &destPath);
        nonstd::expected<void, QString> moveItem(Item *item, const QString &destPath);
        nonstd::expected<void, QString> removeItem(const QString &itemPath);

        QList<Item *> items() const;
        Item *itemByPath(const QString &path) const;
        QList<Feed *> feeds() const;
        Feed *feedByURL(const QString &url) const;

        Folder *rootFolder() const;

    signals:
        void processingStateChanged(bool enabled);
        void maxArticlesPerFeedChanged(int n);
        void itemAdded(Item *item);
        void itemPathChanged(Item *item);
        void itemAboutToBeRemoved(Item *item);
        void feedIconLoaded(Feed *feed);
        void feedStateChanged(Feed *feed);
        void feedURLChanged(Feed *feed, const QString &oldURL);

    private slots:
        void handleItemAboutToBeDestroyed(Item *item);
        void handleFeedTitleChanged(Feed *feed);

    private:
        QUuid generateUID() const;
        void load();
        bool loadFolder(const QJsonObject &jsonObj, Folder *folder);
        void loadLegacy();
        void store();
        nonstd::expected<Folder *, QString> prepareItemDest(const QString &path);
        Folder *addSubfolder(const QString &name, Folder *parentFolder);
        Feed *addFeedToFolder(const QUuid &uid, const QString &url, const QString &name, Folder *parentFolder, std::chrono::seconds refreshInterval);
        void addItem(Item *item, Folder *destFolder);
        void refresh();
        std::chrono::system_clock::time_point refreshFeed(Feed *feed, const std::chrono::system_clock::time_point &currentTimepoint);

        static QPointer<Session> m_instance;

        CachedSettingValue<bool> m_storeProcessingEnabled;
        CachedSettingValue<int> m_storeRefreshInterval;
        CachedSettingValue<qint64> m_storeFetchDelay;
        CachedSettingValue<int> m_storeMaxArticlesPerFeed;
        Utils::Thread::UniquePtr m_workingThread;
        AsyncFileStorage *m_confFileStorage = nullptr;
        AsyncFileStorage *m_dataFileStorage = nullptr;
        QTimer m_refreshTimer;
        QHash<QString, Item *> m_itemsByPath;
        QHash<QUuid, Feed *> m_feedsByUID;
        QHash<QString, Feed *> m_feedsByURL;
        QHash<Feed *, std::chrono::system_clock::time_point> m_refreshTimepoints;
    };
}
</file>

<file path="base/search/searchdownloadhandler.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2018-2024  Vladimir Golovnev <glassez@yandex.ru>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "searchdownloadhandler.h"

#include <QProcess>

#include "base/global.h"
#include "base/path.h"
#include "base/utils/foreignapps.h"
#include "base/utils/fs.h"
#include "searchpluginmanager.h"

SearchDownloadHandler::SearchDownloadHandler(const QString &pluginName, const QString &url, SearchPluginManager *manager)
    : QObject(manager)
    , m_manager {manager}
    , m_downloadProcess {new QProcess(this)}
{
    m_downloadProcess->setProcessEnvironment(m_manager->proxyEnvironment());
#ifdef Q_OS_UNIX
    m_downloadProcess->setUnixProcessParameters(QProcess::UnixProcessFlag::CloseFileDescriptors);
#endif
    connect(m_downloadProcess, qOverload<int, QProcess::ExitStatus>(&QProcess::finished)
            , this, &SearchDownloadHandler::downloadProcessFinished);
    const QStringList params
    {
        Utils::ForeignApps::PYTHON_ISOLATE_MODE_FLAG,
        (SearchPluginManager::engineLocation() / Path(u"nova2dl.py"_s)).toString(),
        pluginName,
        url
    };
    // Launch search
    m_downloadProcess->start(Utils::ForeignApps::pythonInfo().executablePath.data(), params, QIODevice::ReadOnly);
}

void SearchDownloadHandler::downloadProcessFinished(int exitcode)
{
    QString path;

    if ((exitcode == 0) && (m_downloadProcess->exitStatus() == QProcess::NormalExit))
    {
        const QString line = QString::fromUtf8(m_downloadProcess->readAllStandardOutput()).trimmed();
        const QList<QStringView> parts = QStringView(line).split(u' ');
        if (parts.size() == 2)
            path = parts[0].toString();
    }

    emit downloadFinished(path);
}
</file>

<file path="base/search/searchdownloadhandler.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2018-2024  Vladimir Golovnev <glassez@yandex.ru>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QObject>

class QProcess;

class SearchPluginManager;

class SearchDownloadHandler : public QObject
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(SearchDownloadHandler)

    friend class SearchPluginManager;

    SearchDownloadHandler(const QString &pluginName, const QString &url, SearchPluginManager *manager);

signals:
    void downloadFinished(const QString &path);

private:
    void downloadProcessFinished(int exitcode);

    SearchPluginManager *m_manager = nullptr;
    QProcess *m_downloadProcess = nullptr;
};
</file>

<file path="base/search/searchhandler.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015-2024  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "searchhandler.h"

#include <chrono>

#include <QList>
#include <QMetaObject>
#include <QProcess>
#include <QTimer>

#include "base/global.h"
#include "base/path.h"
#include "base/utils/foreignapps.h"
#include "base/utils/fs.h"
#include "searchpluginmanager.h"

using namespace std::chrono_literals;

namespace
{
    enum SearchResultColumn
    {
        PL_DL_LINK,
        PL_NAME,
        PL_SIZE,
        PL_SEEDS,
        PL_LEECHS,
        PL_ENGINE_URL,
        PL_DESC_LINK,
        PL_PUB_DATE,
        NB_PLUGIN_COLUMNS
    };
}

SearchHandler::SearchHandler(const QString &pattern, const QString &category, const QStringList &usedPlugins, SearchPluginManager *manager)
    : QObject(manager)
    , m_pattern {pattern}
    , m_category {category}
    , m_usedPlugins {usedPlugins}
    , m_manager {manager}
    , m_searchProcess {new QProcess(this)}
    , m_searchTimeout {new QTimer(this)}
{
    // Load environment variables (proxy)
    m_searchProcess->setProcessEnvironment(m_manager->proxyEnvironment());
    m_searchProcess->setProgram(Utils::ForeignApps::pythonInfo().executablePath.data());
#ifdef Q_OS_UNIX
    m_searchProcess->setUnixProcessParameters(QProcess::UnixProcessFlag::CloseFileDescriptors);
#endif

    const QStringList params
    {
        Utils::ForeignApps::PYTHON_ISOLATE_MODE_FLAG,
        (SearchPluginManager::engineLocation() / Path(u"nova2.py"_s)).toString(),
        m_usedPlugins.join(u','),
        m_category
    };
    m_searchProcess->setArguments(params + m_pattern.split(u' '));

    connect(m_searchProcess, &QProcess::errorOccurred, this, &SearchHandler::processFailed);
    connect(m_searchProcess, &QProcess::readyReadStandardOutput, this, &SearchHandler::readSearchOutput);
    connect(m_searchProcess, qOverload<int, QProcess::ExitStatus>(&QProcess::finished)
            , this, &SearchHandler::processFinished);

    m_searchTimeout->setSingleShot(true);
    connect(m_searchTimeout, &QTimer::timeout, this, &SearchHandler::cancelSearch);
    m_searchTimeout->start(3min);

    // Launch search
    // deferred start allows clients to handle starting-related signals
    QMetaObject::invokeMethod(this, [this]() { m_searchProcess->start(QIODevice::ReadOnly); }
        , Qt::QueuedConnection);
}

bool SearchHandler::isActive() const
{
    return (m_searchProcess->state() != QProcess::NotRunning);
}

void SearchHandler::cancelSearch()
{
    if ((m_searchProcess->state() == QProcess::NotRunning) || m_searchCancelled)
        return;

#ifdef Q_OS_WIN
    m_searchProcess->kill();
#else
    m_searchProcess->terminate();
#endif
    m_searchCancelled = true;
    m_searchTimeout->stop();
}

// Slot called when QProcess is Finished
// QProcess can be finished for 3 reasons:
// Error | Stopped by user | Finished normally
void SearchHandler::processFinished(const int exitcode)
{
    m_searchTimeout->stop();

    if (m_searchCancelled)
        emit searchFinished(true);
    else if ((m_searchProcess->exitStatus() == QProcess::NormalExit) && (exitcode == 0))
        emit searchFinished(false);
    else
        emit searchFailed();
}

// search QProcess return output as soon as it gets new
// stuff to read. We split it into lines and parse each
// line to SearchResult calling parseSearchResult().
void SearchHandler::readSearchOutput()
{
    QByteArray output = m_searchProcess->readAllStandardOutput();
    output.replace('\r', "");

    QList<QByteArray> lines = output.split('\n');
    if (!m_searchResultLineTruncated.isEmpty())
        lines.prepend(m_searchResultLineTruncated + lines.takeFirst());
    m_searchResultLineTruncated = lines.takeLast().trimmed();

    QList<SearchResult> searchResultList;
    searchResultList.reserve(lines.size());

    for (const QByteArray &line : asConst(lines))
    {
        SearchResult searchResult;
        if (parseSearchResult(QString::fromUtf8(line), searchResult))
            searchResultList << searchResult;
    }

    if (!searchResultList.isEmpty())
    {
        for (const SearchResult &result : searchResultList)
            m_results.append(result);
        emit newSearchResults(searchResultList);
    }
}

void SearchHandler::processFailed()
{
    if (!m_searchCancelled)
        emit searchFailed();
}

// Parse one line of search results list
// Line is in the following form:
// file url | file name | file size | nb seeds | nb leechers | Search engine url
bool SearchHandler::parseSearchResult(const QStringView line, SearchResult &searchResult)
{
    const QList<QStringView> parts = line.split(u'|');
    const int nbFields = parts.size();

    if (nbFields <= PL_ENGINE_URL)
        return false; // Anything after ENGINE_URL is optional

    searchResult = SearchResult();
    searchResult.fileUrl = parts.at(PL_DL_LINK).trimmed().toString(); // download URL
    searchResult.fileName = parts.at(PL_NAME).trimmed().toString(); // Name
    searchResult.fileSize = parts.at(PL_SIZE).trimmed().toLongLong(); // Size

    bool ok = false;

    searchResult.nbSeeders = parts.at(PL_SEEDS).trimmed().toLongLong(&ok); // Seeders
    if (!ok || (searchResult.nbSeeders < 0))
        searchResult.nbSeeders = -1;

    searchResult.nbLeechers = parts.at(PL_LEECHS).trimmed().toLongLong(&ok); // Leechers
    if (!ok || (searchResult.nbLeechers < 0))
        searchResult.nbLeechers = -1;

    searchResult.siteUrl = parts.at(PL_ENGINE_URL).trimmed().toString(); // Search engine site URL
    searchResult.engineName = m_manager->pluginNameBySiteURL(searchResult.siteUrl); // Search engine name

    if (nbFields > PL_DESC_LINK)
        searchResult.descrLink = parts.at(PL_DESC_LINK).trimmed().toString(); // Description Link

    if (nbFields > PL_PUB_DATE)
    {
        const qint64 secs = parts.at(PL_PUB_DATE).trimmed().toLongLong(&ok);
        if (ok && (secs > 0))
            searchResult.pubDate = QDateTime::fromSecsSinceEpoch(secs); // Date
    }

    return true;
}

SearchPluginManager *SearchHandler::manager() const
{
    return m_manager;
}

QList<SearchResult> SearchHandler::results() const
{
    return m_results;
}

QString SearchHandler::pattern() const
{
    return m_pattern;
}
</file>

<file path="base/search/searchhandler.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015-2024 Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QByteArray>
#include <QDateTime>
#include <QList>
#include <QObject>
#include <QString>
#include <QtContainerFwd>

class QProcess;
class QTimer;

struct SearchResult
{
    QString fileName;
    QString fileUrl;
    qlonglong fileSize = 0;
    qlonglong nbSeeders = 0;
    qlonglong nbLeechers = 0;
    QString engineName;
    QString siteUrl;
    QString descrLink;
    QDateTime pubDate;
};

class SearchPluginManager;

class SearchHandler : public QObject
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(SearchHandler)

    friend class SearchPluginManager;

    SearchHandler(const QString &pattern, const QString &category
                  , const QStringList &usedPlugins, SearchPluginManager *manager);

public:
    bool isActive() const;
    QString pattern() const;
    SearchPluginManager *manager() const;
    QList<SearchResult> results() const;

    void cancelSearch();

signals:
    void searchFinished(bool cancelled = false);
    void searchFailed();
    void newSearchResults(const QList<SearchResult> &results);

private:
    void readSearchOutput();
    void processFailed();
    void processFinished(int exitcode);
    bool parseSearchResult(QStringView line, SearchResult &searchResult);

    const QString m_pattern;
    const QString m_category;
    const QStringList m_usedPlugins;
    SearchPluginManager *m_manager = nullptr;
    QProcess *m_searchProcess = nullptr;
    QTimer *m_searchTimeout = nullptr;
    QByteArray m_searchResultLineTruncated;
    bool m_searchCancelled = false;
    QList<SearchResult> m_results;
};
</file>

<file path="base/search/searchpluginmanager.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015-2024  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "searchpluginmanager.h"

#include <memory>

#include <QDir>
#include <QDirIterator>
#include <QDomDocument>
#include <QDomElement>
#include <QDomNode>
#include <QFile>
#include <QPointer>
#include <QProcess>
#include <QUrl>

#include "base/global.h"
#include "base/logger.h"
#include "base/net/downloadmanager.h"
#include "base/net/proxyconfigurationmanager.h"
#include "base/preferences.h"
#include "base/profile.h"
#include "base/utils/bytearray.h"
#include "base/utils/foreignapps.h"
#include "base/utils/fs.h"
#include "searchdownloadhandler.h"
#include "searchhandler.h"

namespace
{
    void clearPythonCache(const Path &path)
    {
        // remove python cache artifacts in `path` and subdirs

        PathList dirs = {path};
        QDirIterator iter {path.data(), (QDir::AllDirs | QDir::NoDotAndDotDot), QDirIterator::Subdirectories};
        while (iter.hasNext())
            dirs += Path(iter.next());

        for (const Path &dir : asConst(dirs))
        {
            // python 3: remove "__pycache__" folders
            if (dir.filename() == u"__pycache__")
            {
                Utils::Fs::removeDirRecursively(dir);
                continue;
            }

            // python 2: remove "*.pyc" files
            QDirIterator it {dir.data(), {u"*.pyc"_s}, QDir::Files};
            while (it.hasNext())
            {
                const QString filePath = it.next();
                Utils::Fs::removeFile(Path(filePath));
            }
        }
    }
}

QPointer<SearchPluginManager> SearchPluginManager::m_instance = nullptr;

SearchPluginManager::SearchPluginManager()
    : m_updateUrl(u"https://searchplugins.qbittorrent.org/nova3/engines/"_s)
    , m_proxyEnv {QProcessEnvironment::systemEnvironment()}
{
    Q_ASSERT(!m_instance); // only one instance is allowed
    m_instance = this;

    connect(Net::ProxyConfigurationManager::instance(), &Net::ProxyConfigurationManager::proxyConfigurationChanged
            , this, &SearchPluginManager::applyProxySettings);
    connect(Preferences::instance(), &Preferences::changed
            , this, &SearchPluginManager::applyProxySettings);
    applyProxySettings();

    updateNova();
    update();
}

SearchPluginManager::~SearchPluginManager()
{
    qDeleteAll(m_plugins);
}

SearchPluginManager *SearchPluginManager::instance()
{
    if (!m_instance)
        m_instance = new SearchPluginManager;
    return m_instance;
}

void SearchPluginManager::freeInstance()
{
    delete m_instance;
}

QStringList SearchPluginManager::allPlugins() const
{
    return m_plugins.keys();
}

QStringList SearchPluginManager::enabledPlugins() const
{
    QStringList plugins;
    for (const PluginInfo *plugin : asConst(m_plugins))
    {
        if (plugin->enabled)
            plugins << plugin->name;
    }

    return plugins;
}

QStringList SearchPluginManager::supportedCategories() const
{
    QStringList result;
    for (const PluginInfo *plugin : asConst(m_plugins))
    {
        if (plugin->enabled)
        {
            for (const QString &cat : plugin->supportedCategories)
            {
                if (!result.contains(cat))
                    result << cat;
            }
        }
    }

    return result;
}

QStringList SearchPluginManager::getPluginCategories(const QString &pluginName) const
{
    QStringList plugins;
    if (pluginName == u"all")
        plugins = allPlugins();
    else if ((pluginName == u"enabled") || (pluginName == u"multi"))
        plugins = enabledPlugins();
    else
        plugins << pluginName.trimmed();

    QSet<QString> categories;
    for (const QString &name : asConst(plugins))
    {
        const PluginInfo *plugin = pluginInfo(name);
        if (!plugin) continue; // plugin wasn't found
        for (const QString &category : plugin->supportedCategories)
            categories << category;
    }

    return categories.values();
}

PluginInfo *SearchPluginManager::pluginInfo(const QString &name) const
{
    return m_plugins.value(name);
}

QString SearchPluginManager::pluginNameBySiteURL(const QString &siteURL) const
{
    for (const PluginInfo *plugin : asConst(m_plugins))
    {
        if (plugin->url == siteURL)
            return plugin->name;
    }

    return {};
}

void SearchPluginManager::enablePlugin(const QString &name, const bool enabled)
{
    PluginInfo *plugin = m_plugins.value(name, nullptr);
    if (plugin)
    {
        plugin->enabled = enabled;
        // Save to Hard disk
        Preferences *const pref = Preferences::instance();
        QStringList disabledPlugins = pref->getSearchEngDisabled();
        if (enabled)
            disabledPlugins.removeAll(name);
        else if (!disabledPlugins.contains(name))
            disabledPlugins.append(name);
        pref->setSearchEngDisabled(disabledPlugins);

        emit pluginEnabled(name, enabled);
    }
}

// Updates shipped plugin
void SearchPluginManager::updatePlugin(const QString &name)
{
    installPlugin(u"%1%2.py"_s.arg(m_updateUrl, name));
}

// Install or update plugin from file or url
void SearchPluginManager::installPlugin(const QString &source)
{
    clearPythonCache(engineLocation());

    if (Net::DownloadManager::hasSupportedScheme(source))
    {
        using namespace Net;
        DownloadManager::instance()->download(DownloadRequest(source).saveToFile(true)
                , Preferences::instance()->useProxyForGeneralPurposes()
                , this, &SearchPluginManager::pluginDownloadFinished);
    }
    else
    {
        const Path path {source.startsWith(u"file:", Qt::CaseInsensitive) ? QUrl(source).toLocalFile() : source};

        QString pluginName = path.filename();
        if (pluginName.endsWith(u".py", Qt::CaseInsensitive))
        {
            pluginName.chop(pluginName.size() - pluginName.lastIndexOf(u'.'));
            installPlugin_impl(pluginName, path);
        }
        else
        {
            emit pluginInstallationFailed(pluginName, tr("Unknown search engine plugin file format."));
        }
    }
}

void SearchPluginManager::installPlugin_impl(const QString &name, const Path &path)
{
    const PluginVersion newVersion = getPluginVersion(path);
    const PluginInfo *plugin = pluginInfo(name);
    if (plugin && !(plugin->version < newVersion))
    {
        LogMsg(tr("Plugin already at version %1, which is greater than %2").arg(plugin->version.toString(), newVersion.toString()), Log::INFO);
        emit pluginUpdateFailed(name, tr("A more recent version of this plugin is already installed."));
        return;
    }

    // Process with install
    const Path destPath = pluginPath(name);
    const Path backupPath = destPath + u".bak";
    bool updated = false;
    if (destPath.exists())
    {
        // Backup in case install fails
        Utils::Fs::copyFile(destPath, backupPath);
        Utils::Fs::removeFile(destPath);
        updated = true;
    }
    // Copy the plugin
    Utils::Fs::copyFile(path, destPath);
    // Update supported plugins
    update();
    // Check if this was correctly installed
    if (!m_plugins.contains(name))
    {
        // Remove broken file
        Utils::Fs::removeFile(destPath);
        LogMsg(tr("Plugin %1 is not supported.").arg(name), Log::INFO);
        if (updated)
        {
            // restore backup
            Utils::Fs::copyFile(backupPath, destPath);
            Utils::Fs::removeFile(backupPath);
            // Update supported plugins
            update();
            emit pluginUpdateFailed(name, tr("Plugin is not supported."));
        }
        else
        {
            emit pluginInstallationFailed(name, tr("Plugin is not supported."));
        }
    }
    else
    {
        // Install was successful, remove backup
        if (updated)
        {
            LogMsg(tr("Plugin %1 has been successfully updated.").arg(name), Log::INFO);
            Utils::Fs::removeFile(backupPath);
        }
    }
}

bool SearchPluginManager::uninstallPlugin(const QString &name)
{
    clearPythonCache(engineLocation());

    // remove it from hard drive
    QDirIterator iter {pluginsLocation().data(), {name + u".*"}, QDir::Files};
    while (iter.hasNext())
    {
        const QString filePath = iter.next();
        Utils::Fs::removeFile(Path(filePath));
    }

    // Remove it from supported engines
    delete m_plugins.take(name);

    emit pluginUninstalled(name);
    return true;
}

void SearchPluginManager::updateIconPath(PluginInfo *const plugin)
{
    if (!plugin) return;

    const Path pluginsPath = pluginsLocation();
    Path iconPath = pluginsPath / Path(plugin->name + u".png");
    if (iconPath.exists())
    {
        plugin->iconPath = iconPath;
    }
    else
    {
        iconPath = pluginsPath / Path(plugin->name + u".ico");
        if (iconPath.exists())
            plugin->iconPath = iconPath;
    }
}

void SearchPluginManager::checkForUpdates()
{
    // Download version file from update server
    using namespace Net;
    DownloadManager::instance()->download({m_updateUrl + u"versions.txt"}
            , Preferences::instance()->useProxyForGeneralPurposes()
            , this, &SearchPluginManager::versionInfoDownloadFinished);
}

SearchDownloadHandler *SearchPluginManager::downloadTorrent(const QString &pluginName, const QString &url)
{
    return new SearchDownloadHandler(pluginName, url, this);
}

SearchHandler *SearchPluginManager::startSearch(const QString &pattern, const QString &category, const QStringList &usedPlugins)
{
    // No search pattern entered
    Q_ASSERT(!pattern.isEmpty());

    return new SearchHandler(pattern, category, usedPlugins, this);
}

QProcessEnvironment SearchPluginManager::proxyEnvironment() const
{
    return m_proxyEnv;
}

QString SearchPluginManager::categoryFullName(const QString &categoryName)
{
    const QHash<QString, QString> categoryTable
    {
        {u"all"_s, tr("All categories")},
        {u"anime"_s, tr("Anime")},
        {u"books"_s, tr("Books")},
        {u"games"_s, tr("Games")},
        {u"movies"_s, tr("Movies")},
        {u"music"_s, tr("Music")},
        {u"pictures"_s, tr("Pictures")},
        {u"software"_s, tr("Software")},
        {u"tv"_s, tr("TV shows")}
    };
    return categoryTable.value(categoryName);
}

QString SearchPluginManager::pluginFullName(const QString &pluginName) const
{
    return pluginInfo(pluginName) ? pluginInfo(pluginName)->fullName : QString();
}

Path SearchPluginManager::pluginsLocation()
{
    return (engineLocation() / Path(u"engines"_s));
}

Path SearchPluginManager::engineLocation()
{
    static Path location;
    if (location.isEmpty())
    {
        location = specialFolderLocation(SpecialFolder::Data) / Path(u"nova3"_s);
        Utils::Fs::mkpath(location);
    }

    return location;
}

void SearchPluginManager::applyProxySettings()
{
    // for python `urllib`: https://docs.python.org/3/library/urllib.request.html#urllib.request.ProxyHandler
    const QString HTTP_PROXY = u"http_proxy"_s;
    const QString HTTPS_PROXY = u"https_proxy"_s;
    // for `helpers.setupSOCKSProxy()`: https://everything.curl.dev/usingcurl/proxies/socks.html
    const QString SOCKS_PROXY = u"qbt_socks_proxy"_s;

    if (!Preferences::instance()->useProxyForGeneralPurposes())
    {
        m_proxyEnv.remove(HTTP_PROXY);
        m_proxyEnv.remove(HTTPS_PROXY);
        m_proxyEnv.remove(SOCKS_PROXY);
        return;
    }

    const Net::ProxyConfiguration proxyConfig = Net::ProxyConfigurationManager::instance()->proxyConfiguration();
    switch (proxyConfig.type)
    {
    case Net::ProxyType::None:
        m_proxyEnv.remove(HTTP_PROXY);
        m_proxyEnv.remove(HTTPS_PROXY);
        m_proxyEnv.remove(SOCKS_PROXY);
        break;

    case Net::ProxyType::HTTP:
        {
            const QString credential = proxyConfig.authEnabled
                ? (proxyConfig.username + u':' + proxyConfig.password + u'@')
                : QString();
            const QString proxyURL = u"http://%1%2:%3"_s
                .arg(credential, proxyConfig.ip, QString::number(proxyConfig.port));

            m_proxyEnv.insert(HTTP_PROXY, proxyURL);
            m_proxyEnv.insert(HTTPS_PROXY, proxyURL);
            m_proxyEnv.remove(SOCKS_PROXY);
        }
        break;

    case Net::ProxyType::SOCKS5:
        {
            const QString scheme = proxyConfig.hostnameLookupEnabled ? u"socks5h"_s : u"socks5"_s;
            const QString credential = proxyConfig.authEnabled
                ? (proxyConfig.username + u':' + proxyConfig.password + u'@')
                : QString();
            const QString proxyURL = u"%1://%2%3:%4"_s
                .arg(scheme, credential, proxyConfig.ip, QString::number(proxyConfig.port));

            m_proxyEnv.remove(HTTP_PROXY);
            m_proxyEnv.remove(HTTPS_PROXY);
            m_proxyEnv.insert(SOCKS_PROXY, proxyURL);
        }
        break;

    case Net::ProxyType::SOCKS4:
        {
            const QString scheme = proxyConfig.hostnameLookupEnabled ? u"socks4a"_s : u"socks4"_s;
            const QString proxyURL = u"%1://%2:%3"_s
                .arg(scheme, proxyConfig.ip, QString::number(proxyConfig.port));

            m_proxyEnv.remove(HTTP_PROXY);
            m_proxyEnv.remove(HTTPS_PROXY);
            m_proxyEnv.insert(SOCKS_PROXY, proxyURL);
        }
        break;
    }
}

void SearchPluginManager::versionInfoDownloadFinished(const Net::DownloadResult &result)
{
    if (result.status == Net::DownloadStatus::Success)
        parseVersionInfo(result.data);
    else
        emit checkForUpdatesFailed(tr("Update server is temporarily unavailable. %1").arg(result.errorString));
}

void SearchPluginManager::pluginDownloadFinished(const Net::DownloadResult &result)
{
    if (result.status == Net::DownloadStatus::Success)
    {
        const Path filePath = result.filePath;

        const auto pluginPath = Path(QUrl(result.url).path()).removedExtension();
        installPlugin_impl(pluginPath.filename(), filePath);
        Utils::Fs::removeFile(filePath);
    }
    else
    {
        const QString &url = result.url;
        const QString pluginName = url.sliced(url.lastIndexOf(u'/') + 1)
            .replace(u".py"_s, u""_s, Qt::CaseInsensitive);

        if (pluginInfo(pluginName))
            emit pluginUpdateFailed(pluginName, tr("Failed to download the plugin file. %1").arg(result.errorString));
        else
            emit pluginInstallationFailed(pluginName, tr("Failed to download the plugin file. %1").arg(result.errorString));
    }
}

// Update nova.py search plugin if necessary
void SearchPluginManager::updateNova()
{
    // create nova directory if necessary
    const Path enginePath = engineLocation();

    QFile packageFile {(enginePath / Path(u"__init__.py"_s)).data()};
    packageFile.open(QIODevice::WriteOnly);
    packageFile.close();

    Utils::Fs::mkdir(enginePath / Path(u"engines"_s));

    QFile packageFile2 {(enginePath / Path(u"engines/__init__.py"_s)).data()};
    packageFile2.open(QIODevice::WriteOnly);
    packageFile2.close();

    // Copy search plugin files (if necessary)
    const auto updateFile = [&enginePath](const Path &filename)
    {
        const Path filePathBundled = Path(u":/searchengine/nova3"_s) / filename;
        const Path filePathDisk = enginePath / filename;

        if (getPluginVersion(filePathBundled) <= getPluginVersion(filePathDisk))
            return;

        Utils::Fs::removeFile(filePathDisk);
        Utils::Fs::copyFile(filePathBundled, filePathDisk);
    };

    updateFile(Path(u"helpers.py"_s));
    updateFile(Path(u"nova2.py"_s));
    updateFile(Path(u"nova2dl.py"_s));
    updateFile(Path(u"novaprinter.py"_s));
    updateFile(Path(u"socks.py"_s));
}

void SearchPluginManager::update()
{
    QProcess nova;
    nova.setProcessEnvironment(proxyEnvironment());
#ifdef Q_OS_UNIX
    nova.setUnixProcessParameters(QProcess::UnixProcessFlag::CloseFileDescriptors);
#endif

    const QStringList params
    {
        Utils::ForeignApps::PYTHON_ISOLATE_MODE_FLAG,
        (engineLocation() / Path(u"/nova2.py"_s)).toString(),
        u"--capabilities"_s
    };
    nova.start(Utils::ForeignApps::pythonInfo().executablePath.data(), params, QIODevice::ReadOnly);
    nova.waitForFinished();

    const auto capabilities = QString::fromUtf8(nova.readAllStandardOutput());
    QDomDocument xmlDoc;
    if (!xmlDoc.setContent(capabilities))
    {
        qWarning() << "Could not parse Nova search engine capabilities, msg: " << capabilities.toLocal8Bit().data();
        qWarning() << "Error: " << nova.readAllStandardError().constData();
        return;
    }

    const QDomElement root = xmlDoc.documentElement();
    if (root.tagName() != u"capabilities")
    {
        qWarning() << "Invalid XML file for Nova search engine capabilities, msg: " << capabilities.toLocal8Bit().data();
        return;
    }

    for (QDomNode engineNode = root.firstChild(); !engineNode.isNull(); engineNode = engineNode.nextSibling())
    {
        const QDomElement engineElem = engineNode.toElement();
        if (!engineElem.isNull())
        {
            const QString pluginName = engineElem.tagName();

            auto plugin = std::make_unique<PluginInfo>();
            plugin->name = pluginName;
            plugin->version = getPluginVersion(pluginPath(pluginName));
            plugin->fullName = engineElem.elementsByTagName(u"name"_s).at(0).toElement().text();
            plugin->url = engineElem.elementsByTagName(u"url"_s).at(0).toElement().text();

            const QStringList categories = engineElem.elementsByTagName(u"categories"_s).at(0).toElement().text().split(u' ');
            for (QString cat : categories)
            {
                cat = cat.trimmed();
                if (!cat.isEmpty())
                    plugin->supportedCategories << cat;
            }

            const QStringList disabledEngines = Preferences::instance()->getSearchEngDisabled();
            plugin->enabled = !disabledEngines.contains(pluginName);

            updateIconPath(plugin.get());

            if (!m_plugins.contains(pluginName))
            {
                m_plugins[pluginName] = plugin.release();
                emit pluginInstalled(pluginName);
            }
            else if (m_plugins[pluginName]->version != plugin->version)
            {
                delete m_plugins.take(pluginName);
                m_plugins[pluginName] = plugin.release();
                emit pluginUpdated(pluginName);
            }
        }
    }
}

void SearchPluginManager::parseVersionInfo(const QByteArray &info)
{
    QHash<QString, PluginVersion> updateInfo;
    int numCorrectData = 0;

    const QList<QByteArrayView> lines = Utils::ByteArray::splitToViews(info, "\n");
    for (QByteArrayView line : lines)
    {
        line = line.trimmed();
        if (line.isEmpty()) continue;
        if (line.startsWith('#')) continue;

        const QList<QByteArrayView> list = Utils::ByteArray::splitToViews(line, ":");
        if (list.size() != 2) continue;

        const auto pluginName = QString::fromUtf8(list.first().trimmed());
        const auto version = PluginVersion::fromString(QString::fromLatin1(list.last().trimmed()));

        if (!version.isValid()) continue;

        ++numCorrectData;
        if (isUpdateNeeded(pluginName, version))
        {
            LogMsg(tr("Plugin \"%1\" is outdated, updating to version %2").arg(pluginName, version.toString()), Log::INFO);
            updateInfo[pluginName] = version;
        }
    }

    if (numCorrectData < lines.size())
    {
        emit checkForUpdatesFailed(tr("Incorrect update info received for %1 out of %2 plugins.")
            .arg(QString::number(lines.size() - numCorrectData), QString::number(lines.size())));
    }
    else
    {
        emit checkForUpdatesFinished(updateInfo);
    }
}

bool SearchPluginManager::isUpdateNeeded(const QString &pluginName, const PluginVersion &newVersion) const
{
    const PluginInfo *plugin = pluginInfo(pluginName);
    if (!plugin) return true;

    PluginVersion oldVersion = plugin->version;
    return (newVersion > oldVersion);
}

Path SearchPluginManager::pluginPath(const QString &name)
{
    return (pluginsLocation() / Path(name + u".py"));
}

PluginVersion SearchPluginManager::getPluginVersion(const Path &filePath)
{
    const int lineMaxLength = 16;

    QFile pluginFile {filePath.data()};
    if (!pluginFile.open(QIODevice::ReadOnly | QIODevice::Text))
        return {};

    while (!pluginFile.atEnd())
    {
        const auto line = QString::fromUtf8(pluginFile.readLine(lineMaxLength)).remove(u' ');
        if (!line.startsWith(u"#VERSION:", Qt::CaseInsensitive))
            continue;

        const QString versionStr = line.sliced(9);
        const auto version = PluginVersion::fromString(versionStr);
        if (version.isValid())
            return version;

        LogMsg(tr("Search plugin '%1' contains invalid version string ('%2')")
            .arg(filePath.filename(), versionStr), Log::MsgType::WARNING);
        break;
    }

    return {};
}
</file>

<file path="base/search/searchpluginmanager.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015-2024  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QHash>
#include <QMetaType>
#include <QObject>
#include <QProcessEnvironment>

#include "base/path.h"
#include "base/utils/version.h"

using PluginVersion = Utils::Version<2>;
Q_DECLARE_METATYPE(PluginVersion)

namespace Net
{
    struct DownloadResult;
}

struct PluginInfo
{
    QString name;
    PluginVersion version;
    QString fullName;
    QString url;
    QStringList supportedCategories;
    Path iconPath;
    bool enabled = false;
};

class SearchDownloadHandler;
class SearchHandler;

class SearchPluginManager final : public QObject
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(SearchPluginManager)

public:
    SearchPluginManager();
    ~SearchPluginManager() override;

    static SearchPluginManager *instance();
    static void freeInstance();

    QStringList allPlugins() const;
    QStringList enabledPlugins() const;
    QStringList supportedCategories() const;
    QStringList getPluginCategories(const QString &pluginName) const;
    PluginInfo *pluginInfo(const QString &name) const;
    QString pluginNameBySiteURL(const QString &siteURL) const;

    void enablePlugin(const QString &name, bool enabled = true);
    void updatePlugin(const QString &name);
    void installPlugin(const QString &source);
    bool uninstallPlugin(const QString &name);
    static void updateIconPath(PluginInfo *plugin);
    void checkForUpdates();

    SearchHandler *startSearch(const QString &pattern, const QString &category, const QStringList &usedPlugins);
    SearchDownloadHandler *downloadTorrent(const QString &pluginName, const QString &url);

    QProcessEnvironment proxyEnvironment() const;

    static PluginVersion getPluginVersion(const Path &filePath);
    static QString categoryFullName(const QString &categoryName);
    QString pluginFullName(const QString &pluginName) const;
    static Path pluginsLocation();
    static Path engineLocation();

signals:
    void pluginEnabled(const QString &name, bool enabled);
    void pluginInstalled(const QString &name);
    void pluginInstallationFailed(const QString &name, const QString &reason);
    void pluginUninstalled(const QString &name);
    void pluginUpdated(const QString &name);
    void pluginUpdateFailed(const QString &name, const QString &reason);

    void checkForUpdatesFinished(const QHash<QString, PluginVersion> &updateInfo);
    void checkForUpdatesFailed(const QString &reason);

private:
    void applyProxySettings();
    void update();
    void updateNova();
    void parseVersionInfo(const QByteArray &info);
    void installPlugin_impl(const QString &name, const Path &path);
    bool isUpdateNeeded(const QString &pluginName, const PluginVersion &newVersion) const;

    void versionInfoDownloadFinished(const Net::DownloadResult &result);
    void pluginDownloadFinished(const Net::DownloadResult &result);

    static Path pluginPath(const QString &name);

    static QPointer<SearchPluginManager> m_instance;

    const QString m_updateUrl;

    QHash<QString, PluginInfo*> m_plugins;
    QProcessEnvironment m_proxyEnv;
};
</file>

<file path="gui/rss/articlelistwidget.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017-2024  Vladimir Golovnev <glassez@yandex.ru>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "articlelistwidget.h"

#include <QApplication>
#include <QListWidgetItem>

#include "base/global.h"
#include "base/rss/rss_article.h"
#include "base/rss/rss_item.h"
#include "gui/uithememanager.h"

ArticleListWidget::ArticleListWidget(QWidget *parent)
    : QListWidget(parent)
{
    setContextMenuPolicy(Qt::CustomContextMenu);
    setSelectionMode(QAbstractItemView::ExtendedSelection);

    checkInvariant();

    connect(UIThemeManager::instance(), &UIThemeManager::themeChanged, this, [this]
    {
        for (int row = 0; row < count(); ++row)
            applyUITheme(item(row));
    });
}

RSS::Article *ArticleListWidget::getRSSArticle(QListWidgetItem *item) const
{
    Q_ASSERT(item);
    return item->data(Qt::UserRole).value<RSS::Article *>();
}

QListWidgetItem *ArticleListWidget::mapRSSArticle(RSS::Article *rssArticle) const
{
    return m_rssArticleToListItemMapping.value(rssArticle);
}

void ArticleListWidget::setRSSItem(RSS::Item *rssItem, bool unreadOnly)
{
    // Clear the list first
    clear();
    m_rssArticleToListItemMapping.clear();
    if (m_rssItem)
        m_rssItem->disconnect(this);

    m_unreadOnly = unreadOnly;
    m_rssItem = rssItem;
    if (m_rssItem)
    {
        connect(m_rssItem, &RSS::Item::newArticle, this, &ArticleListWidget::handleArticleAdded);
        connect(m_rssItem, &RSS::Item::articleRead, this, &ArticleListWidget::handleArticleRead);
        connect(m_rssItem, &RSS::Item::articleAboutToBeRemoved, this, &ArticleListWidget::handleArticleAboutToBeRemoved);

        for (auto *article : asConst(rssItem->articles()))
        {
            if (!(m_unreadOnly && article->isRead()))
            {
                auto *item = createItem(article);
                addItem(item);
                m_rssArticleToListItemMapping.insert(article, item);
            }
        }
    }

    checkInvariant();
}

void ArticleListWidget::handleArticleAdded(RSS::Article *rssArticle)
{
    if (!(m_unreadOnly && rssArticle->isRead()))
    {
        auto *item = createItem(rssArticle);
        insertItem(0, item);
        m_rssArticleToListItemMapping.insert(rssArticle, item);
    }

    checkInvariant();
}

void ArticleListWidget::handleArticleRead(RSS::Article *rssArticle)
{
    auto *item = mapRSSArticle(rssArticle);
    if (!item)
        return;

    applyUITheme(item);

    checkInvariant();
}

void ArticleListWidget::handleArticleAboutToBeRemoved(RSS::Article *rssArticle)
{
    delete m_rssArticleToListItemMapping.take(rssArticle);
    checkInvariant();
}

void ArticleListWidget::checkInvariant() const
{
    Q_ASSERT(count() == m_rssArticleToListItemMapping.count());
}

QListWidgetItem *ArticleListWidget::createItem(RSS::Article *article) const
{
    Q_ASSERT(article);
    auto *item = new QListWidgetItem;

    item->setData(Qt::DisplayRole, article->title());
    item->setData(Qt::UserRole, QVariant::fromValue(article));
    applyUITheme(item);

    return item;
}

void ArticleListWidget::applyUITheme(QListWidgetItem *item) const
{
    const bool isRead = getRSSArticle(item)->isRead();
    const auto *themeManager = UIThemeManager::instance();
    if (isRead)
    {
        const QColor color = themeManager->getColor(u"RSS.ReadArticle"_s);
        item->setData(Qt::ForegroundRole, (color.isValid() ? color : QApplication::palette().color(QPalette::Inactive, QPalette::WindowText)));
        item->setData(Qt::DecorationRole, themeManager->getIcon(u"rss_read_article"_s, u"sphere"_s));
    }
    else
    {
        const QColor color = themeManager->getColor(u"RSS.UnreadArticle"_s);
        item->setData(Qt::ForegroundRole, (color.isValid() ? color : QApplication::palette().color(QPalette::Active, QPalette::Link)));
        item->setData(Qt::DecorationRole, themeManager->getIcon(u"rss_unread_article"_s, u"sphere"_s));
    }
}
</file>

<file path="gui/rss/articlelistwidget.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017-2024  Vladimir Golovnev <glassez@yandex.ru>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QHash>
#include <QListWidget>

namespace RSS
{
    class Article;
    class Item;
}

class ArticleListWidget : public QListWidget
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(ArticleListWidget)

public:
    explicit ArticleListWidget(QWidget *parent);

    RSS::Article *getRSSArticle(QListWidgetItem *item) const;
    QListWidgetItem *mapRSSArticle(RSS::Article *rssArticle) const;

    void setRSSItem(RSS::Item *rssItem, bool unreadOnly = false);

private slots:
    void handleArticleAdded(RSS::Article *rssArticle);
    void handleArticleRead(RSS::Article *rssArticle);
    void handleArticleAboutToBeRemoved(RSS::Article *rssArticle);

private:
    void checkInvariant() const;
    QListWidgetItem *createItem(RSS::Article *article) const;
    void applyUITheme(QListWidgetItem *item) const;

    RSS::Item *m_rssItem = nullptr;
    bool m_unreadOnly = false;
    QHash<RSS::Article *, QListWidgetItem *> m_rssArticleToListItemMapping;
};
</file>

<file path="gui/rss/automatedrssdownloader.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017, 2023  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "automatedrssdownloader.h"

#include <QtVersionChecks>
#include <QCursor>
#include <QFileDialog>
#include <QMenu>
#include <QMessageBox>
#include <QRegularExpression>
#include <QShortcut>
#include <QSignalBlocker>
#include <QString>

#include "base/bittorrent/session.h"
#include "base/global.h"
#include "base/path.h"
#include "base/rss/rss_article.h"
#include "base/rss/rss_autodownloader.h"
#include "base/rss/rss_feed.h"
#include "base/rss/rss_folder.h"
#include "base/rss/rss_session.h"
#include "base/utils/compare.h"
#include "base/utils/io.h"
#include "base/utils/string.h"
#include "gui/addtorrentparamswidget.h"
#include "gui/autoexpandabledialog.h"
#include "gui/torrentcategorydialog.h"
#include "gui/uithememanager.h"
#include "gui/utils.h"
#include "gui/utils/keysequence.h"
#include "ui_automatedrssdownloader.h"

const QString EXT_JSON = u".json"_s;
const QString EXT_LEGACY = u".rssrules"_s;

AutomatedRssDownloader::AutomatedRssDownloader(QWidget *parent)
    : QDialog(parent)
    , m_formatFilterJSON {u"%1 (*%2)"_s.arg(tr("Rules"), EXT_JSON)}
    , m_formatFilterLegacy {u"%1 (*%2)"_s.arg(tr("Rules (legacy)"), EXT_LEGACY)}
    , m_ui {new Ui::AutomatedRssDownloader}
    , m_addTorrentParamsWidget {new AddTorrentParamsWidget}
    , m_storeDialogSize {u"RssFeedDownloader/geometrySize"_s}
    , m_storeMainSplitterState {u"GUI/Qt6/RSSFeedDownloader/HSplitterSizes"_s}
    , m_storeRuleDefSplitterState {u"GUI/Qt6/RSSFeedDownloader/RuleDefSplitterState"_s}
{
    m_ui->setupUi(this);

    connect(m_ui->buttonBox, &QDialogButtonBox::accepted, this, &QDialog::accept);
    connect(m_ui->buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);

    m_ui->torrentParametersGroupBox->layout()->addWidget(m_addTorrentParamsWidget);

    m_ui->prioritySpinBox->setMinimum(std::numeric_limits<int>::min());
    m_ui->prioritySpinBox->setMaximum(std::numeric_limits<int>::max());

    connect(m_ui->addRuleBtn, &QPushButton::clicked, this, &AutomatedRssDownloader::onAddRuleBtnClicked);
    connect(m_ui->removeRuleBtn, &QPushButton::clicked, this, &AutomatedRssDownloader::onRemoveRuleBtnClicked);
    connect(m_ui->exportBtn, &QPushButton::clicked, this, &AutomatedRssDownloader::onExportBtnClicked);
    connect(m_ui->importBtn, &QPushButton::clicked, this, &AutomatedRssDownloader::onImportBtnClicked);
    connect(m_ui->renameRuleBtn, &QPushButton::clicked, this, &AutomatedRssDownloader::onRenameRuleBtnClicked);

    // Icons
    m_ui->renameRuleBtn->setIcon(UIThemeManager::instance()->getIcon(u"edit-rename"_s));
    m_ui->removeRuleBtn->setIcon(UIThemeManager::instance()->getIcon(u"edit-clear"_s, u"list-remove"_s));
    m_ui->addRuleBtn->setIcon(UIThemeManager::instance()->getIcon(u"list-add"_s));

    // Ui Settings
    m_ui->ruleList->setSortingEnabled(true);
    m_ui->ruleList->setSelectionMode(QAbstractItemView::ExtendedSelection);
    m_ui->matchingArticlesTree->setSortingEnabled(true);
    m_ui->matchingArticlesTree->sortByColumn(0, Qt::AscendingOrder);
    m_ui->mainSplitter->setCollapsible(0, false);
    m_ui->mainSplitter->setCollapsible(1, false);
    m_ui->mainSplitter->setCollapsible(2, true); // Only the preview list is collapsible

    connect(m_ui->checkRegex, &QAbstractButton::toggled, this, &AutomatedRssDownloader::updateFieldsToolTips);
    connect(m_ui->ruleList, &QWidget::customContextMenuRequested, this, &AutomatedRssDownloader::displayRulesListMenu);

    m_episodeRegex = new QRegularExpression(u"^(^\\d{1,4}x(\\d{1,4}(-(\\d{1,4})?)?;){1,}){1,1}"_s
                                            , QRegularExpression::CaseInsensitiveOption);
    const QString tip = u"<p>" + tr("Matches articles based on episode filter.") + u"</p><p><b>" + tr("Example: ")
        + u"1x2;8-15;5;30-;</b>" + tr(" will match 2, 5, 8 through 15, 30 and onward episodes of season one", "example X will match") + u"</p>"
        + u"<p>" + tr("Episode filter rules: ") + u"</p><ul><li>" + tr("Season number is a mandatory non-zero value") + u"</li>"
        + u"<li>" + tr("Episode number is a mandatory positive value") + u"</li>"
        + u"<li>" + tr("Filter must end with semicolon") + u"</li>"
        + u"<li>" + tr("Three range types for episodes are supported: ") + u"</li>" + u"<li><ul>"
        + u"<li>" + tr("Single number: <b>1x25;</b> matches episode 25 of season one") + u"</li>"
        + u"<li>" + tr("Normal range: <b>1x25-40;</b> matches episodes 25 through 40 of season one") + u"</li>"
        + u"<li>" + tr("Infinite range: <b>1x25-;</b> matches episodes 25 and upward of season one, and all episodes of later seasons") + u"</li>" + u"</ul></li></ul>";
    m_ui->lineEFilter->setToolTip(tip);

    loadSettings();

    connect(RSS::AutoDownloader::instance(), &RSS::AutoDownloader::ruleAdded, this, &AutomatedRssDownloader::handleRuleAdded);
    connect(RSS::AutoDownloader::instance(), &RSS::AutoDownloader::ruleRenamed, this, &AutomatedRssDownloader::handleRuleRenamed);
    connect(RSS::AutoDownloader::instance(), &RSS::AutoDownloader::ruleChanged, this, &AutomatedRssDownloader::handleRuleChanged);
    connect(RSS::AutoDownloader::instance(), &RSS::AutoDownloader::ruleAboutToBeRemoved, this, &AutomatedRssDownloader::handleRuleAboutToBeRemoved);

    // Update matching articles when necessary
    connect(m_ui->lineContains, &QLineEdit::textEdited, this, &AutomatedRssDownloader::handleRuleDefinitionChanged);
    connect(m_ui->lineContains, &QLineEdit::textEdited, this, &AutomatedRssDownloader::updateMustLineValidity);
    connect(m_ui->lineNotContains, &QLineEdit::textEdited, this, &AutomatedRssDownloader::handleRuleDefinitionChanged);
    connect(m_ui->lineNotContains, &QLineEdit::textEdited, this, &AutomatedRssDownloader::updateMustNotLineValidity);
    connect(m_ui->lineEFilter, &QLineEdit::textEdited, this, &AutomatedRssDownloader::handleRuleDefinitionChanged);
    connect(m_ui->lineEFilter, &QLineEdit::textEdited, this, &AutomatedRssDownloader::updateEpisodeFilterValidity);
#if QT_VERSION >= QT_VERSION_CHECK(6, 7, 0)
    connect(m_ui->checkRegex, &QCheckBox::checkStateChanged, this, &AutomatedRssDownloader::handleRuleDefinitionChanged);
    connect(m_ui->checkRegex, &QCheckBox::checkStateChanged, this, &AutomatedRssDownloader::updateMustLineValidity);
    connect(m_ui->checkRegex, &QCheckBox::checkStateChanged, this, &AutomatedRssDownloader::updateMustNotLineValidity);
    connect(m_ui->checkSmart, &QCheckBox::checkStateChanged, this, &AutomatedRssDownloader::handleRuleDefinitionChanged);
#else
    connect(m_ui->checkRegex, &QCheckBox::stateChanged, this, &AutomatedRssDownloader::handleRuleDefinitionChanged);
    connect(m_ui->checkRegex, &QCheckBox::stateChanged, this, &AutomatedRssDownloader::updateMustLineValidity);
    connect(m_ui->checkRegex, &QCheckBox::stateChanged, this, &AutomatedRssDownloader::updateMustNotLineValidity);
    connect(m_ui->checkSmart, &QCheckBox::stateChanged, this, &AutomatedRssDownloader::handleRuleDefinitionChanged);
#endif
    connect(m_ui->spinIgnorePeriod, qOverload<int>(&QSpinBox::valueChanged)
            , this, &AutomatedRssDownloader::handleRuleDefinitionChanged);

    connect(m_ui->listFeeds, &QListWidget::itemChanged, this, &AutomatedRssDownloader::handleFeedCheckStateChange);

    connect(m_ui->ruleList, &QListWidget::itemSelectionChanged, this, &AutomatedRssDownloader::updateRuleDefinitionBox);
    connect(m_ui->ruleList, &QListWidget::itemChanged, this, &AutomatedRssDownloader::handleRuleCheckStateChange);

    const auto *editHotkey = new QShortcut(Qt::Key_F2, m_ui->ruleList, nullptr, nullptr, Qt::WidgetShortcut);
    connect(editHotkey, &QShortcut::activated, this, &AutomatedRssDownloader::renameSelectedRule);
    const auto *deleteHotkey = new QShortcut(Utils::KeySequence::deleteItem(), m_ui->ruleList, nullptr, nullptr, Qt::WidgetShortcut);
    connect(deleteHotkey, &QShortcut::activated, this, &AutomatedRssDownloader::onRemoveRuleBtnClicked);

    connect(m_ui->ruleList, &QAbstractItemView::doubleClicked, this, &AutomatedRssDownloader::renameSelectedRule);

    loadFeedList();

    m_ui->ruleList->blockSignals(true);
    for (const RSS::AutoDownloadRule &rule : asConst(RSS::AutoDownloader::instance()->rules()))
        createRuleItem(rule);
    m_ui->ruleList->blockSignals(false);

    updateRuleDefinitionBox();

    if (RSS::AutoDownloader::instance()->isProcessingEnabled())
        m_ui->labelWarn->hide();

    connect(RSS::AutoDownloader::instance(), &RSS::AutoDownloader::processingStateChanged
            , this, &AutomatedRssDownloader::handleProcessingStateChanged);
}

AutomatedRssDownloader::~AutomatedRssDownloader()
{
    // Save current item on exit
    saveEditedRule();
    saveSettings();

    delete m_ui;
    delete m_episodeRegex;
}

void AutomatedRssDownloader::loadSettings()
{
    if (const QSize dialogSize = m_storeDialogSize; dialogSize.isValid())
        resize(dialogSize);

    if (const QByteArray mainSplitterSize = m_storeMainSplitterState; !mainSplitterSize.isEmpty())
        m_ui->mainSplitter->restoreState(mainSplitterSize);

    if (const QByteArray ruleDefSplitterSize = m_storeRuleDefSplitterState; !ruleDefSplitterSize.isEmpty())
        m_ui->ruleDefSplitter->restoreState(ruleDefSplitterSize);
}

void AutomatedRssDownloader::saveSettings()
{
    m_storeDialogSize = size();
    m_storeMainSplitterState = m_ui->mainSplitter->saveState();
    m_storeRuleDefSplitterState = m_ui->ruleDefSplitter->saveState();
}

void AutomatedRssDownloader::createRuleItem(const RSS::AutoDownloadRule &rule)
{
    QListWidgetItem *item = new QListWidgetItem(rule.name(), m_ui->ruleList);
    m_itemsByRuleName.insert(rule.name(), item);
    item->setFlags(item->flags() | Qt::ItemIsUserCheckable);
    item->setCheckState(rule.isEnabled() ? Qt::Checked : Qt::Unchecked);
}

void AutomatedRssDownloader::loadFeedList()
{
    const QSignalBlocker feedListSignalBlocker(m_ui->listFeeds);

    for (const auto *feed : asConst(RSS::Session::instance()->feeds()))
    {
        QListWidgetItem *item = new QListWidgetItem(feed->name(), m_ui->listFeeds);
        item->setData(Qt::UserRole, feed->url());
        item->setFlags(item->flags() | Qt::ItemIsUserCheckable | Qt::ItemIsAutoTristate);
    }

    updateFeedList();
}

void AutomatedRssDownloader::updateFeedList()
{
    const QSignalBlocker feedListSignalBlocker(m_ui->listFeeds);

    QList<QListWidgetItem *> selection;

    if (m_currentRuleItem)
        selection << m_currentRuleItem;
    else
        selection = m_ui->ruleList->selectedItems();

    bool enable = !selection.isEmpty();

    for (int i = 0; i < m_ui->listFeeds->count(); ++i)
    {
        QListWidgetItem *item = m_ui->listFeeds->item(i);
        const QString feedURL = item->data(Qt::UserRole).toString();
        item->setHidden(!enable);

        bool allEnabled = true;
        bool anyEnabled = false;

        for (const QListWidgetItem *ruleItem : asConst(selection))
        {
            const auto rule = RSS::AutoDownloader::instance()->ruleByName(ruleItem->text());
            if (rule.feedURLs().contains(feedURL))
                anyEnabled = true;
            else
                allEnabled = false;
        }

        if (anyEnabled && allEnabled)
            item->setCheckState(Qt::Checked);
        else if (anyEnabled)
            item->setCheckState(Qt::PartiallyChecked);
        else
            item->setCheckState(Qt::Unchecked);
    }

    m_ui->listFeeds->sortItems();
    m_ui->lblListFeeds->setEnabled(enable);
    m_ui->listFeeds->setEnabled(enable);
}

void AutomatedRssDownloader::updateRuleDefinitionBox()
{
    const QList<QListWidgetItem *> selection = m_ui->ruleList->selectedItems();
    QListWidgetItem *currentRuleItem = ((selection.count() == 1) ? selection.first() : nullptr);

    // Enable the edit rule button but only if we have 1 rule selected
    if (selection.count() == 1)
        m_ui->renameRuleBtn->setEnabled(true);
    else
        m_ui->renameRuleBtn->setEnabled(false);

    if (m_currentRuleItem != currentRuleItem)
    {
        saveEditedRule(); // Save previous rule first
        m_currentRuleItem = currentRuleItem;
        //m_ui->ruleList->setCurrentItem(m_currentRuleItem);
    }

    // Update rule definition box
    if (m_currentRuleItem)
    {
        m_currentRule = RSS::AutoDownloader::instance()->ruleByName(m_currentRuleItem->text());

        m_ui->prioritySpinBox->setValue(m_currentRule.priority());

        m_addTorrentParamsWidget->setAddTorrentParams(m_currentRule.addTorrentParams());

        m_ui->lineContains->setText(m_currentRule.mustContain());
        m_ui->lineNotContains->setText(m_currentRule.mustNotContain());
        if (!m_currentRule.episodeFilter().isEmpty())
            m_ui->lineEFilter->setText(m_currentRule.episodeFilter());
        else
            m_ui->lineEFilter->clear();
        m_ui->checkRegex->blockSignals(true);
        m_ui->checkRegex->setChecked(m_currentRule.useRegex());
        m_ui->checkRegex->blockSignals(false);
        m_ui->checkSmart->blockSignals(true);
        m_ui->checkSmart->setChecked(m_currentRule.useSmartFilter());
        m_ui->checkSmart->blockSignals(false);
        m_ui->spinIgnorePeriod->setValue(m_currentRule.ignoreDays());
        QDateTime dateTime = m_currentRule.lastMatch();
        QString lMatch;
        if (dateTime.isValid())
            lMatch = tr("Last Match: %1 days ago").arg(dateTime.daysTo(QDateTime::currentDateTime()));
        else
            lMatch = tr("Last Match: Unknown");
        m_ui->lblLastMatch->setText(lMatch);
        updateMustLineValidity();
        updateMustNotLineValidity();
        updateEpisodeFilterValidity();

        updateFieldsToolTips(m_ui->checkRegex->isChecked());
        m_ui->ruleScrollArea->setEnabled(true);
    }
    else
    {
        m_currentRule = RSS::AutoDownloadRule();
        clearRuleDefinitionBox();
        m_ui->ruleScrollArea->setEnabled(false);
    }

    updateFeedList();
    updateMatchingArticles();
}

void AutomatedRssDownloader::clearRuleDefinitionBox()
{
    m_addTorrentParamsWidget->setAddTorrentParams({});
    m_ui->prioritySpinBox->setValue(0);
    m_ui->lineContains->clear();
    m_ui->lineNotContains->clear();
    m_ui->lineEFilter->clear();
    m_ui->checkRegex->setChecked(false);
    m_ui->checkSmart->setChecked(false);
    m_ui->spinIgnorePeriod->setValue(0);
    updateFieldsToolTips(m_ui->checkRegex->isChecked());
    updateMustLineValidity();
    updateMustNotLineValidity();
    updateEpisodeFilterValidity();
}

void AutomatedRssDownloader::updateEditedRule()
{
    if (!m_currentRuleItem || !m_ui->ruleScrollArea->isEnabled())
        return;

    m_currentRule.setEnabled(m_currentRuleItem->checkState() != Qt::Unchecked);
    m_currentRule.setPriority(m_ui->prioritySpinBox->value());
    m_currentRule.setUseRegex(m_ui->checkRegex->isChecked());
    m_currentRule.setUseSmartFilter(m_ui->checkSmart->isChecked());
    m_currentRule.setMustContain(m_ui->lineContains->text());
    m_currentRule.setMustNotContain(m_ui->lineNotContains->text());
    m_currentRule.setEpisodeFilter(m_ui->lineEFilter->text());
    m_currentRule.setIgnoreDays(m_ui->spinIgnorePeriod->value());

    m_currentRule.setAddTorrentParams(m_addTorrentParamsWidget->addTorrentParams());
}

void AutomatedRssDownloader::saveEditedRule()
{
    if (!m_currentRuleItem || !m_ui->ruleScrollArea->isEnabled()) return;

    updateEditedRule();
    RSS::AutoDownloader::instance()->setRule(m_currentRule);
}

void AutomatedRssDownloader::onAddRuleBtnClicked()
{
//    saveEditedRule();

    // Ask for a rule name
    const QString ruleName = AutoExpandableDialog::getText(
                this, tr("New rule name"), tr("Please type the name of the new download rule."));
    if (ruleName.isEmpty()) return;

    // Check if this rule name already exists
    if (RSS::AutoDownloader::instance()->hasRule(ruleName))
    {
        QMessageBox::warning(this, tr("Rule name conflict")
                             , tr("A rule with this name already exists, please choose another name."));
        return;
    }

    RSS::AutoDownloader::instance()->setRule(RSS::AutoDownloadRule(ruleName));
}

void AutomatedRssDownloader::onRemoveRuleBtnClicked()
{
    const QList<QListWidgetItem *> selection = m_ui->ruleList->selectedItems();
    if (selection.isEmpty()) return;

    // Ask for confirmation
    const QString confirmText = ((selection.count() == 1)
                                 ? tr("Are you sure you want to remove the download rule named '%1'?")
                                   .arg(selection.first()->text())
                                 : tr("Are you sure you want to remove the selected download rules?"));
    if (QMessageBox::question(this, tr("Rule deletion confirmation"), confirmText, QMessageBox::Yes, QMessageBox::No) != QMessageBox::Yes)
        return;

    for (const QListWidgetItem *item : selection)
        RSS::AutoDownloader::instance()->removeRule(item->text());
}

void AutomatedRssDownloader::onRenameRuleBtnClicked()
{
    renameSelectedRule();
}

void AutomatedRssDownloader::onExportBtnClicked()
{
    if (RSS::AutoDownloader::instance()->rules().isEmpty())
    {
        QMessageBox::warning(this, tr("Invalid action")
                             , tr("The list is empty, there is nothing to export."));
        return;
    }

    QString selectedFilter {m_formatFilterJSON};
    Path path {QFileDialog::getSaveFileName(
                this, tr("Export RSS rules"), QDir::homePath()
                , u"%1;;%2"_s.arg(m_formatFilterJSON, m_formatFilterLegacy), &selectedFilter)};

    if (path.isEmpty()) return;

    const RSS::AutoDownloader::RulesFileFormat format
    {
        (selectedFilter == m_formatFilterJSON)
                ? RSS::AutoDownloader::RulesFileFormat::JSON
                : RSS::AutoDownloader::RulesFileFormat::Legacy
    };

    if (format == RSS::AutoDownloader::RulesFileFormat::JSON)
    {
        if (!path.hasExtension(EXT_JSON))
            path += EXT_JSON;
    }
    else
    {
        if (!path.hasExtension(EXT_LEGACY))
            path += EXT_LEGACY;
    }

    const QByteArray rules = RSS::AutoDownloader::instance()->exportRules(format);
    const nonstd::expected<void, QString> result = Utils::IO::saveToFile(path, rules);
    if (!result)
    {
        QMessageBox::critical(this, tr("I/O Error")
            , tr("Failed to create the destination file. Reason: %1").arg(result.error()));
    }
}

void AutomatedRssDownloader::onImportBtnClicked()
{
    QString selectedFilter {m_formatFilterJSON};
    const Path path {QFileDialog::getOpenFileName(
                    this, tr("Import RSS rules"), QDir::homePath()
                    , u"%1;;%2"_s.arg(m_formatFilterJSON, m_formatFilterLegacy), &selectedFilter)};

    const int fileMaxSize = 10 * 1024 * 1024;
    const auto readResult = Utils::IO::readFile(path, fileMaxSize);
    if (!readResult)
    {
        if (readResult.error().status == Utils::IO::ReadError::NotExist)
            return;

        QMessageBox::critical(this, tr("Import error")
            , tr("Failed to read the file. %1").arg(readResult.error().message));
        return;
    }

    const RSS::AutoDownloader::RulesFileFormat format
    {
        (selectedFilter == m_formatFilterJSON)
                ? RSS::AutoDownloader::RulesFileFormat::JSON
                : RSS::AutoDownloader::RulesFileFormat::Legacy
    };

    try
    {
        RSS::AutoDownloader::instance()->importRules(readResult.value(), format);
    }
    catch (const RSS::ParsingError &error)
    {
        QMessageBox::critical(this, tr("Import error")
            , tr("Failed to import the selected rules file. Reason: %1").arg(error.message()));
    }
}

void AutomatedRssDownloader::displayRulesListMenu()
{
    QMenu *menu = new QMenu(this);
    menu->setAttribute(Qt::WA_DeleteOnClose);

    menu->addAction(UIThemeManager::instance()->getIcon(u"list-add"_s), tr("Add new rule...")
                    , this, &AutomatedRssDownloader::onAddRuleBtnClicked);

    const QList<QListWidgetItem *> selection = m_ui->ruleList->selectedItems();

    if (!selection.isEmpty())
    {
        if (selection.count() == 1)
        {
            menu->addAction(UIThemeManager::instance()->getIcon(u"edit-clear"_s, u"list-remove"_s), tr("Delete rule")
                            , this, &AutomatedRssDownloader::onRemoveRuleBtnClicked);
            menu->addSeparator();
            menu->addAction(UIThemeManager::instance()->getIcon(u"edit-rename"_s), tr("Rename rule...")
                , this, &AutomatedRssDownloader::renameSelectedRule);
        }
        else
        {
            menu->addAction(UIThemeManager::instance()->getIcon(u"edit-clear"_s, u"list-remove"_s), tr("Delete selected rules")
                            , this, &AutomatedRssDownloader::onRemoveRuleBtnClicked);
        }

        menu->addSeparator();
        menu->addAction(UIThemeManager::instance()->getIcon(u"edit-clear"_s), tr("Clear downloaded episodes...")
            , this, &AutomatedRssDownloader::clearSelectedRuleDownloadedEpisodeList);
    }

    menu->popup(QCursor::pos());
}

void AutomatedRssDownloader::renameSelectedRule()
{
    const QList<QListWidgetItem *> selection = m_ui->ruleList->selectedItems();
    if (selection.isEmpty()) return;

    QListWidgetItem *item = selection.first();
    forever
    {
        QString newName = AutoExpandableDialog::getText(
                    this, tr("Rule renaming"), tr("Please type the new rule name")
                    , QLineEdit::Normal, item->text());
        newName = newName.trimmed();
        if (newName.isEmpty()) return;

        if (RSS::AutoDownloader::instance()->hasRule(newName))
        {
            QMessageBox::warning(this, tr("Rule name conflict")
                                 , tr("A rule with this name already exists, please choose another name."));
        }
        else
        {
            // Rename the rule
            RSS::AutoDownloader::instance()->renameRule(item->text(), newName);
            return;
        }
    }
}

void AutomatedRssDownloader::handleRuleCheckStateChange(QListWidgetItem *ruleItem)
{
    m_ui->ruleList->setCurrentItem(ruleItem);
}

void AutomatedRssDownloader::clearSelectedRuleDownloadedEpisodeList()
{
    const QMessageBox::StandardButton reply = QMessageBox::question(
                this,
                tr("Clear downloaded episodes"),
                tr("Are you sure you want to clear the list of downloaded episodes for the selected rule?"),
                QMessageBox::Yes | QMessageBox::No);

    if (reply == QMessageBox::Yes)
    {
        m_currentRule.setPreviouslyMatchedEpisodes(QStringList());
        handleRuleDefinitionChanged();
    }
}

void AutomatedRssDownloader::handleFeedCheckStateChange(QListWidgetItem *feedItem)
{
    const QString feedURL = feedItem->data(Qt::UserRole).toString();
    for (QListWidgetItem *ruleItem : asConst(m_ui->ruleList->selectedItems()))
    {
        RSS::AutoDownloadRule rule = (ruleItem == m_currentRuleItem
                                       ? m_currentRule
                                       : RSS::AutoDownloader::instance()->ruleByName(ruleItem->text()));
        QStringList affectedFeeds = rule.feedURLs();
        if ((feedItem->checkState() == Qt::Checked) && !affectedFeeds.contains(feedURL))
            affectedFeeds << feedURL;
        else if ((feedItem->checkState() == Qt::Unchecked) && affectedFeeds.contains(feedURL))
            affectedFeeds.removeOne(feedURL);

        rule.setFeedURLs(affectedFeeds);
        if (ruleItem != m_currentRuleItem)
            RSS::AutoDownloader::instance()->setRule(rule);
        else
            m_currentRule = rule;
    }

    handleRuleDefinitionChanged();
}

void AutomatedRssDownloader::updateMatchingArticles()
{
    m_ui->matchingArticlesTree->clear();

    for (const QListWidgetItem *ruleItem : asConst(m_ui->ruleList->selectedItems()))
    {
        RSS::AutoDownloadRule rule = (ruleItem == m_currentRuleItem
                                       ? m_currentRule
                                       : RSS::AutoDownloader::instance()->ruleByName(ruleItem->text()));
        for (const QString &feedURL : asConst(rule.feedURLs()))
        {
            auto *feed = RSS::Session::instance()->feedByURL(feedURL);
            if (!feed) continue; // feed doesn't exist

            QStringList matchingArticles;
            for (const auto *article : asConst(feed->articles()))
                if (rule.matches(article->data()))
                    matchingArticles << article->title();
            if (!matchingArticles.isEmpty())
                addFeedArticlesToTree(feed, matchingArticles);
        }
    }

    m_treeListEntries.clear();
}

void AutomatedRssDownloader::addFeedArticlesToTree(RSS::Feed *feed, const QStringList &articles)
{
    // Turn off sorting while inserting
    m_ui->matchingArticlesTree->setSortingEnabled(false);

    // Check if this feed is already in the tree
    QTreeWidgetItem *treeFeedItem = nullptr;
    for (int i = 0; i < m_ui->matchingArticlesTree->topLevelItemCount(); ++i)
    {
        QTreeWidgetItem *item = m_ui->matchingArticlesTree->topLevelItem(i);
        if (item->data(0, Qt::UserRole).toString() == feed->url())
        {
            treeFeedItem = item;
            break;
        }
    }

    // If there is none, create it
    if (!treeFeedItem)
    {
        treeFeedItem = new QTreeWidgetItem(QStringList() << feed->name());
        treeFeedItem->setToolTip(0, feed->name());
        QFont f = treeFeedItem->font(0);
        f.setBold(true);
        treeFeedItem->setFont(0, f);
        treeFeedItem->setData(0, Qt::DecorationRole, UIThemeManager::instance()->getIcon(u"directory"_s));
        treeFeedItem->setData(0, Qt::UserRole, feed->url());
        m_ui->matchingArticlesTree->addTopLevelItem(treeFeedItem);
    }

    // Insert the articles
    for (const QString &article : articles)
    {
        const std::pair<QString, QString> key(feed->name(), article);

        if (!m_treeListEntries.contains(key))
        {
            m_treeListEntries << key;
            QTreeWidgetItem *item = new QTreeWidgetItem(QStringList() << article);
            item->setToolTip(0, article);
            treeFeedItem->addChild(item);
        }
    }

    m_ui->matchingArticlesTree->expandItem(treeFeedItem);
    m_ui->matchingArticlesTree->sortItems(0, Qt::AscendingOrder);
    m_ui->matchingArticlesTree->setSortingEnabled(true);
}

void AutomatedRssDownloader::updateFieldsToolTips(bool regex)
{
    QString tip;
    if (regex)
    {
        tip = u"<p>" + tr("Regex mode: use Perl-compatible regular expressions") + u"</p>";
    }
    else
    {
        tip = u"<p>" + tr("Wildcard mode: you can use") + u"<ul>"
              + u"<li>" + tr("? to match any single character") + u"</li>"
              + u"<li>" + tr("* to match zero or more of any characters") + u"</li>"
              + u"<li>" + tr("Whitespaces count as AND operators (all words, any order)") + u"</li>"
              + u"<li>" + tr("| is used as OR operator") + u"</li></ul></p>"
              + u"<p>" + tr("If word order is important use * instead of whitespace.") + u"</p>";
    }

    // Whether regex or wildcard, warn about a potential gotcha for users.
    // Explanatory string broken over multiple lines for readability (and multiple
    // statements to prevent uncrustify indenting excessively.
    tip += u"<p>";
    tip += tr("An expression with an empty %1 clause (e.g. %2)",
              "We talk about regex/wildcards in the RSS filters section here."
              " So a valid sentence would be: An expression with an empty | clause (e.g. expr|)"
              ).arg(u"<tt>|</tt>"_s, u"<tt>expr|</tt>"_s);
    m_ui->lineContains->setToolTip(tip + tr(" will match all articles.") + u"</p>");
    m_ui->lineNotContains->setToolTip(tip + tr(" will exclude all articles.") + u"</p>");
}

void AutomatedRssDownloader::updateMustLineValidity()
{
    const QString text = m_ui->lineContains->text();
    bool isRegex = m_ui->checkRegex->isChecked();
    bool valid = true;
    QString error;

    if (!text.isEmpty())
    {
        QStringList tokens;
        if (isRegex)
        {
            tokens << text;
        }
        else
        {
            for (const QString &token : asConst(text.split(u'|')))
                tokens << Utils::String::wildcardToRegexPattern(token);
        }

        for (const QString &token : asConst(tokens))
        {
            QRegularExpression reg(token, QRegularExpression::CaseInsensitiveOption);
            if (!reg.isValid())
            {
                if (isRegex)
                    error = tr("Position %1: %2").arg(reg.patternErrorOffset()).arg(reg.errorString());
                valid = false;
                break;
            }
        }
    }

    if (valid)
    {
        m_ui->lineContains->setStyleSheet({});
        m_ui->labelMustStat->setPixmap(QPixmap());
        m_ui->labelMustStat->setToolTip({});
    }
    else
    {
        m_ui->lineContains->setStyleSheet(u"QLineEdit { color: #ff0000; }"_s);
        m_ui->labelMustStat->setPixmap(UIThemeManager::instance()->getIcon(u"dialog-warning"_s, u"task-attention"_s).pixmap(16, 16));
        m_ui->labelMustStat->setToolTip(error);
    }
}

void AutomatedRssDownloader::updateMustNotLineValidity()
{
    const QString text = m_ui->lineNotContains->text();
    bool isRegex = m_ui->checkRegex->isChecked();
    bool valid = true;
    QString error;

    if (!text.isEmpty())
    {
        QStringList tokens;
        if (isRegex)
        {
            tokens << text;
        }
        else
        {
            for (const QString &token : asConst(text.split(u'|')))
                tokens << Utils::String::wildcardToRegexPattern(token);
        }

        for (const QString &token : asConst(tokens))
        {
            QRegularExpression reg(token, QRegularExpression::CaseInsensitiveOption);
            if (!reg.isValid())
            {
                if (isRegex)
                    error = tr("Position %1: %2").arg(reg.patternErrorOffset()).arg(reg.errorString());
                valid = false;
                break;
            }
        }
    }

    if (valid)
    {
        m_ui->lineNotContains->setStyleSheet({});
        m_ui->labelMustNotStat->setPixmap(QPixmap());
        m_ui->labelMustNotStat->setToolTip({});
    }
    else
    {
        m_ui->lineNotContains->setStyleSheet(u"QLineEdit { color: #ff0000; }"_s);
        m_ui->labelMustNotStat->setPixmap(UIThemeManager::instance()->getIcon(u"dialog-warning"_s, u"task-attention"_s).pixmap(16, 16));
        m_ui->labelMustNotStat->setToolTip(error);
    }
}

void AutomatedRssDownloader::updateEpisodeFilterValidity()
{
    const QString text = m_ui->lineEFilter->text();
    bool valid = text.isEmpty() || m_episodeRegex->match(text).hasMatch();

    if (valid)
    {
        m_ui->lineEFilter->setStyleSheet({});
        m_ui->labelEpFilterStat->setPixmap({});
    }
    else
    {
        m_ui->lineEFilter->setStyleSheet(u"QLineEdit { color: #ff0000; }"_s);
        m_ui->labelEpFilterStat->setPixmap(UIThemeManager::instance()->getIcon(u"dialog-warning"_s, u"task-attention"_s).pixmap(16, 16));
    }
}

void AutomatedRssDownloader::handleRuleDefinitionChanged()
{
    updateEditedRule();
    updateMatchingArticles();
}

void AutomatedRssDownloader::handleRuleAdded(const QString &ruleName)
{
    createRuleItem(RSS::AutoDownloadRule(ruleName));
}

void AutomatedRssDownloader::handleRuleRenamed(const QString &ruleName, const QString &oldRuleName)
{
    auto *item = m_itemsByRuleName.take(oldRuleName);
    m_itemsByRuleName.insert(ruleName, item);
    if (m_currentRule.name() == oldRuleName)
        m_currentRule.setName(ruleName);
    item->setText(ruleName);
}

void AutomatedRssDownloader::handleRuleChanged(const QString &ruleName)
{
    auto *item = m_itemsByRuleName.value(ruleName);
    if (item && (item != m_currentRuleItem))
        item->setCheckState(RSS::AutoDownloader::instance()->ruleByName(ruleName).isEnabled() ? Qt::Checked : Qt::Unchecked);
}

void AutomatedRssDownloader::handleRuleAboutToBeRemoved(const QString &ruleName)
{
    m_currentRuleItem = nullptr;
    delete m_itemsByRuleName.take(ruleName);
}

void AutomatedRssDownloader::handleProcessingStateChanged(bool enabled)
{
    m_ui->labelWarn->setVisible(!enabled);
}
</file>

<file path="gui/rss/automatedrssdownloader.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017, 2023  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <utility>

#include <QDialog>
#include <QHash>
#include <QSet>

#include "base/rss/rss_autodownloadrule.h"
#include "base/settingvalue.h"

class QListWidgetItem;
class QRegularExpression;

namespace RSS
{
    class Feed;
}

namespace Ui
{
    class AutomatedRssDownloader;
}

class AddTorrentParamsWidget;

class AutomatedRssDownloader : public QDialog
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(AutomatedRssDownloader)

public:
    explicit AutomatedRssDownloader(QWidget *parent = nullptr);
    ~AutomatedRssDownloader() override;

private slots:
    void onAddRuleBtnClicked();
    void onRemoveRuleBtnClicked();
    void onExportBtnClicked();
    void onImportBtnClicked();
    void onRenameRuleBtnClicked();
    void handleRuleCheckStateChange(QListWidgetItem *ruleItem);
    void handleFeedCheckStateChange(QListWidgetItem *feedItem);
    void displayRulesListMenu();
    void renameSelectedRule();
    void updateRuleDefinitionBox();
    void clearSelectedRuleDownloadedEpisodeList();
    void updateFieldsToolTips(bool regex);
    void updateMustLineValidity();
    void updateMustNotLineValidity();
    void updateEpisodeFilterValidity();
    void handleRuleDefinitionChanged();
    void handleRuleAdded(const QString &ruleName);
    void handleRuleRenamed(const QString &ruleName, const QString &oldRuleName);
    void handleRuleChanged(const QString &ruleName);
    void handleRuleAboutToBeRemoved(const QString &ruleName);

    void handleProcessingStateChanged(bool enabled);

private:
    void loadSettings();
    void saveSettings();
    void createRuleItem(const RSS::AutoDownloadRule &rule);
    void clearRuleDefinitionBox();
    void updateEditedRule();
    void updateMatchingArticles();
    void saveEditedRule();
    void loadFeedList();
    void updateFeedList();
    void addFeedArticlesToTree(RSS::Feed *feed, const QStringList &articles);

    const QString m_formatFilterJSON;
    const QString m_formatFilterLegacy;

    Ui::AutomatedRssDownloader *m_ui = nullptr;
    AddTorrentParamsWidget *m_addTorrentParamsWidget = nullptr;
    QListWidgetItem *m_currentRuleItem = nullptr;
    QSet<std::pair<QString, QString>> m_treeListEntries;
    RSS::AutoDownloadRule m_currentRule;
    QHash<QString, QListWidgetItem *> m_itemsByRuleName;
    QRegularExpression *m_episodeRegex = nullptr;

    SettingValue<QSize> m_storeDialogSize;
    SettingValue<QByteArray> m_storeMainSplitterState;
    SettingValue<QByteArray> m_storeRuleDefSplitterState;
};
</file>

<file path="gui/rss/automatedrssdownloader.ui">
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>AutomatedRssDownloader</class>
 <widget class="QDialog" name="AutomatedRssDownloader">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>818</width>
    <height>588</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>RSS Downloader</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_4">
   <item>
    <widget class="QLabel" name="labelWarn">
     <property name="font">
      <font>
       <italic>true</italic>
      </font>
     </property>
     <property name="styleSheet">
      <string notr="true">color: red;</string>
     </property>
     <property name="text">
      <string>Auto downloading of RSS torrents is currently disabled. You can enable it in application settings.</string>
     </property>
     <property name="wordWrap">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QSplitter" name="mainSplitter">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="orientation">
      <enum>Qt::Orientation::Horizontal</enum>
     </property>
     <widget class="QWidget" name="ruleListLayoutWidget">
      <layout class="QVBoxLayout" name="ruleListLayout">
       <item>
        <layout class="QHBoxLayout" name="ruleListHeaderLayout">
         <item>
          <widget class="QLabel" name="ruleListLabel">
           <property name="font">
            <font>
             <bold>true</bold>
            </font>
           </property>
           <property name="text">
            <string>Download Rules</string>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QToolButton" name="renameRuleBtn">
           <property name="enabled">
            <bool>false</bool>
           </property>
           <property name="toolTip">
            <string>Rename selected rule. You can also use the F2 hotkey to rename.</string>
           </property>
           <property name="iconSize">
            <size>
             <width>24</width>
             <height>20</height>
            </size>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QToolButton" name="removeRuleBtn">
           <property name="iconSize">
            <size>
             <width>24</width>
             <height>20</height>
            </size>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QToolButton" name="addRuleBtn">
           <property name="iconSize">
            <size>
             <width>24</width>
             <height>20</height>
            </size>
           </property>
          </widget>
         </item>
        </layout>
       </item>
       <item>
        <widget class="QListWidget" name="ruleList">
         <property name="contextMenuPolicy">
          <enum>Qt::ContextMenuPolicy::CustomContextMenu</enum>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QSplitter" name="ruleDefSplitter">
      <property name="orientation">
       <enum>Qt::Orientation::Vertical</enum>
      </property>
      <widget class="QScrollArea" name="ruleScrollArea">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="verticalScrollBarPolicy">
        <enum>Qt::ScrollBarPolicy::ScrollBarAlwaysOn</enum>
       </property>
       <property name="horizontalScrollBarPolicy">
        <enum>Qt::ScrollBarPolicy::ScrollBarAsNeeded</enum>
       </property>
       <property name="sizeAdjustPolicy">
        <enum>QAbstractScrollArea::SizeAdjustPolicy::AdjustToContentsOnFirstShow</enum>
       </property>
       <property name="widgetResizable">
        <bool>true</bool>
       </property>
       <widget class="QWidget" name="scrollAreaWidgetContents">
        <property name="geometry">
         <rect>
          <x>0</x>
          <y>0</y>
          <width>370</width>
          <height>277</height>
         </rect>
        </property>
        <layout class="QVBoxLayout" name="verticalLayout_8" stretch="0,0,0,0,0,0,0,1">
         <item>
          <layout class="QHBoxLayout" name="priorityLayout">
           <item>
            <widget class="QLabel" name="priorityLabel">
             <property name="text">
              <string>Priority:</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QSpinBox" name="prioritySpinBox"/>
           </item>
           <item>
            <spacer name="prioritySpacer">
             <property name="orientation">
              <enum>Qt::Orientation::Horizontal</enum>
             </property>
             <property name="sizeHint" stdset="0">
              <size>
               <width>40</width>
               <height>20</height>
              </size>
             </property>
            </spacer>
           </item>
          </layout>
         </item>
         <item>
          <widget class="QCheckBox" name="checkRegex">
           <property name="text">
            <string>Use Regular Expressions</string>
           </property>
          </widget>
         </item>
         <item>
          <layout class="QGridLayout" name="gridLayout">
           <item row="0" column="0">
            <widget class="QLabel" name="labelMustContain">
             <property name="text">
              <string>Must Contain:</string>
             </property>
            </widget>
           </item>
           <item row="0" column="1">
            <widget class="QLineEdit" name="lineContains"/>
           </item>
           <item row="0" column="2">
            <widget class="QLabel" name="labelMustStat">
             <property name="maximumSize">
              <size>
               <width>18</width>
               <height>18</height>
              </size>
             </property>
            </widget>
           </item>
           <item row="1" column="0">
            <widget class="QLabel" name="labelMustNotContain">
             <property name="text">
              <string>Must Not Contain:</string>
             </property>
            </widget>
           </item>
           <item row="1" column="1">
            <widget class="QLineEdit" name="lineNotContains"/>
           </item>
           <item row="1" column="2">
            <widget class="QLabel" name="labelMustNotStat">
             <property name="maximumSize">
              <size>
               <width>18</width>
               <height>18</height>
              </size>
             </property>
            </widget>
           </item>
           <item row="2" column="0">
            <widget class="QLabel" name="lblEFilter">
             <property name="text">
              <string>Episode Filter:</string>
             </property>
            </widget>
           </item>
           <item row="2" column="1">
            <widget class="QLineEdit" name="lineEFilter"/>
           </item>
           <item row="2" column="2">
            <widget class="QLabel" name="lblEFilterStat">
             <property name="maximumSize">
              <size>
               <width>18</width>
               <height>18</height>
              </size>
             </property>
            </widget>
           </item>
           <item row="2" column="2">
            <widget class="QLabel" name="labelEpFilterStat">
             <property name="maximumSize">
              <size>
               <width>18</width>
               <height>18</height>
              </size>
             </property>
            </widget>
           </item>
          </layout>
         </item>
         <item>
          <widget class="QCheckBox" name="checkSmart">
           <property name="toolTip">
            <string>Smart Episode Filter will check the episode number to prevent downloading of duplicates.
Supports the formats: S01E01, 1x1, 2017.12.31 and 31.12.2017 (Date formats also support - as a separator)</string>
           </property>
           <property name="text">
            <string>Use Smart Episode Filter</string>
           </property>
          </widget>
         </item>
         <item>
          <layout class="QHBoxLayout" name="ignorePeriodLayout">
           <item>
            <widget class="QLabel" name="lblIgnoreDays">
             <property name="text">
              <string extracomment="... X days">Ignore Subsequent Matches for (0 to Disable)</string>
             </property>
            </widget>
           </item>
           <item>
            <widget class="QSpinBox" name="spinIgnorePeriod">
             <property name="enabled">
              <bool>true</bool>
             </property>
             <property name="specialValueText">
              <string>Disabled</string>
             </property>
             <property name="suffix">
              <string> days</string>
             </property>
             <property name="minimum">
              <number>0</number>
             </property>
             <property name="maximum">
              <number>365</number>
             </property>
            </widget>
           </item>
          </layout>
         </item>
         <item>
          <widget class="QLabel" name="lblLastMatch">
           <property name="enabled">
            <bool>true</bool>
           </property>
           <property name="alignment">
            <set>Qt::AlignmentFlag::AlignRight|Qt::AlignmentFlag::AlignTrailing|Qt::AlignmentFlag::AlignVCenter</set>
           </property>
          </widget>
         </item>
         <item>
          <widget class="QGroupBox" name="torrentParametersGroupBox">
           <property name="title">
            <string>Torrent parameters</string>
           </property>
           <property name="flat">
            <bool>true</bool>
           </property>
           <layout class="QVBoxLayout" name="verticalLayout_7">
            <property name="leftMargin">
             <number>0</number>
            </property>
            <property name="topMargin">
             <number>0</number>
            </property>
            <property name="rightMargin">
             <number>0</number>
            </property>
            <property name="bottomMargin">
             <number>0</number>
            </property>
           </layout>
          </widget>
         </item>
         <item>
          <spacer name="verticalSpacer">
           <property name="orientation">
            <enum>Qt::Orientation::Vertical</enum>
           </property>
           <property name="sizeHint" stdset="0">
            <size>
             <width>20</width>
             <height>0</height>
            </size>
           </property>
          </spacer>
         </item>
        </layout>
       </widget>
      </widget>
      <widget class="QWidget" name="layoutWidget">
       <layout class="QVBoxLayout" name="verticalLayout">
        <property name="sizeConstraint">
         <enum>QLayout::SizeConstraint::SetDefaultConstraint</enum>
        </property>
        <item>
         <widget class="QLabel" name="lblListFeeds">
          <property name="font">
           <font>
            <bold>false</bold>
           </font>
          </property>
          <property name="text">
           <string>Apply Rule to Feeds:</string>
          </property>
         </widget>
        </item>
        <item>
         <widget class="QListWidget" name="listFeeds"/>
        </item>
       </layout>
      </widget>
     </widget>
     <widget class="QWidget" name="matchingArticlesLayoutWidget">
      <layout class="QVBoxLayout" name="matchingArticlesLayout">
       <item>
        <widget class="QLabel" name="matchingArticlesLabel">
         <property name="font">
          <font>
           <bold>true</bold>
          </font>
         </property>
         <property name="text">
          <string>Matching RSS Articles</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QTreeWidget" name="matchingArticlesTree">
         <attribute name="headerVisible">
          <bool>false</bool>
         </attribute>
         <column>
          <property name="text">
           <string notr="true">1</string>
          </property>
         </column>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="buttonsLayout">
     <item>
      <widget class="QPushButton" name="importBtn">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="text">
        <string>&amp;Import...</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="exportBtn">
       <property name="enabled">
        <bool>true</bool>
       </property>
       <property name="text">
        <string>&amp;Export...</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QDialogButtonBox" name="buttonBox">
       <property name="focusPolicy">
        <enum>Qt::FocusPolicy::StrongFocus</enum>
       </property>
       <property name="standardButtons">
        <set>QDialogButtonBox::StandardButton::Close</set>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
</file>

<file path="gui/rss/feedlistwidget.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "feedlistwidget.h"

#include <QDragMoveEvent>
#include <QDropEvent>
#include <QHeaderView>
#include <QTreeWidgetItem>

#include "base/global.h"
#include "base/rss/rss_article.h"
#include "base/rss/rss_feed.h"
#include "base/rss/rss_folder.h"
#include "base/rss/rss_session.h"
#include "gui/uithememanager.h"

namespace
{
    enum
    {
        StickyItemTagRole = Qt::UserRole + 1
    };

    class FeedListItem final : public QTreeWidgetItem
    {
    public:
        using QTreeWidgetItem::QTreeWidgetItem;

    private:
        bool operator<(const QTreeWidgetItem &other) const override
        {
            const bool lhsSticky = data(0, StickyItemTagRole).toBool();
            const bool rhsSticky = other.data(0, StickyItemTagRole).toBool();

            if (lhsSticky == rhsSticky)
                return QTreeWidgetItem::operator<(other);

            const int order = treeWidget()->header()->sortIndicatorOrder();
            return ((order == Qt::AscendingOrder) ? lhsSticky : rhsSticky);
        }
    };

    QIcon loadIcon(const Path &path, const QString &fallbackId)
    {
        const QPixmap pixmap {path.data()};
        if (!pixmap.isNull())
            return {pixmap};

        return UIThemeManager::instance()->getIcon(fallbackId);
    }

    QIcon rssFeedIcon(const RSS::Feed *feed)
    {
        if (feed->isLoading())
            return UIThemeManager::instance()->getIcon(u"loading"_s);
        if (feed->hasError())
            return UIThemeManager::instance()->getIcon(u"task-reject"_s, u"unavailable"_s);

        return loadIcon(feed->iconPath(), u"application-rss"_s);
    }
}

FeedListWidget::FeedListWidget(QWidget *parent)
    : QTreeWidget(parent)
{
    setContextMenuPolicy(Qt::CustomContextMenu);
    setDragDropMode(QAbstractItemView::InternalMove);
    setSelectionMode(QAbstractItemView::ExtendedSelection);
    setColumnCount(1);
    headerItem()->setText(0, tr("RSS feeds"));

    connect(RSS::Session::instance(), &RSS::Session::itemAdded, this, &FeedListWidget::handleItemAdded);
    connect(RSS::Session::instance(), &RSS::Session::feedStateChanged, this, &FeedListWidget::handleFeedStateChanged);
    connect(RSS::Session::instance(), &RSS::Session::feedIconLoaded, this, &FeedListWidget::handleFeedIconLoaded);
    connect(RSS::Session::instance(), &RSS::Session::itemPathChanged, this, &FeedListWidget::handleItemPathChanged);
    connect(RSS::Session::instance(), &RSS::Session::itemAboutToBeRemoved, this, &FeedListWidget::handleItemAboutToBeRemoved);

    m_rssToTreeItemMapping[RSS::Session::instance()->rootFolder()] = invisibleRootItem();

    m_unreadStickyItem = new FeedListItem(this);
    m_unreadStickyItem->setData(0, Qt::UserRole, QVariant::fromValue(
            reinterpret_cast<intptr_t>(RSS::Session::instance()->rootFolder())));
    m_unreadStickyItem->setText(0, tr("Unread  (%1)").arg(RSS::Session::instance()->rootFolder()->unreadCount()));
    m_unreadStickyItem->setData(0, Qt::DecorationRole, UIThemeManager::instance()->getIcon(u"mail-inbox"_s));
    m_unreadStickyItem->setData(0, StickyItemTagRole, true);


    connect(RSS::Session::instance()->rootFolder(), &RSS::Item::unreadCountChanged, this, &FeedListWidget::handleItemUnreadCountChanged);

    setSortingEnabled(false);
    fill(nullptr, RSS::Session::instance()->rootFolder());
    setSortingEnabled(true);

//    setCurrentItem(m_unreadStickyItem);
}

void FeedListWidget::handleItemAdded(RSS::Item *rssItem)
{
    auto *parentItem = m_rssToTreeItemMapping.value(
                RSS::Session::instance()->itemByPath(RSS::Item::parentPath(rssItem->path())));
    createItem(rssItem, parentItem);
}

void FeedListWidget::handleFeedStateChanged(RSS::Feed *feed)
{
    QTreeWidgetItem *item = m_rssToTreeItemMapping.value(feed);
    Q_ASSERT(item);

    item->setData(0, Qt::DecorationRole, rssFeedIcon(feed));
}

void FeedListWidget::handleFeedIconLoaded(RSS::Feed *feed)
{
    if (!feed->isLoading() && !feed->hasError())
    {
        QTreeWidgetItem *item = m_rssToTreeItemMapping.value(feed);
        Q_ASSERT(item);

        item->setData(0, Qt::DecorationRole, rssFeedIcon(feed));
    }
}

void FeedListWidget::handleItemUnreadCountChanged(RSS::Item *rssItem)
{
    if (rssItem == RSS::Session::instance()->rootFolder())
    {
        m_unreadStickyItem->setText(0, tr("Unread  (%1)").arg(RSS::Session::instance()->rootFolder()->unreadCount()));
    }
    else
    {
        QTreeWidgetItem *item = mapRSSItem(rssItem);
        Q_ASSERT(item);
        item->setData(0, Qt::DisplayRole, u"%1  (%2)"_s.arg(rssItem->name(), QString::number(rssItem->unreadCount())));
    }
}

void FeedListWidget::handleItemPathChanged(RSS::Item *rssItem)
{
    QTreeWidgetItem *item = mapRSSItem(rssItem);
    Q_ASSERT(item);

    item->setData(0, Qt::DisplayRole, u"%1  (%2)"_s.arg(rssItem->name(), QString::number(rssItem->unreadCount())));

    RSS::Item *parentRssItem = RSS::Session::instance()->itemByPath(RSS::Item::parentPath(rssItem->path()));
    QTreeWidgetItem *parentItem = mapRSSItem(parentRssItem);
    Q_ASSERT(parentItem);

    parentItem->addChild(item);
}

void FeedListWidget::handleItemAboutToBeRemoved(RSS::Item *rssItem)
{
    rssItem->disconnect(this);
    delete m_rssToTreeItemMapping.take(rssItem);

    // RSS Item is still valid in this slot so if it is the last
    // item we should prevent Unread list populating
    if (m_rssToTreeItemMapping.size() == 1)
        setCurrentItem(nullptr);
}

QTreeWidgetItem *FeedListWidget::stickyUnreadItem() const
{
    return m_unreadStickyItem;
}

QList<QTreeWidgetItem *> FeedListWidget::getAllOpenedFolders(QTreeWidgetItem *parent) const
{
    QList<QTreeWidgetItem *> openedFolders;
    int nbChildren = (parent ? parent->childCount() : topLevelItemCount());
    for (int i = 0; i < nbChildren; ++i)
    {
        QTreeWidgetItem *item (parent ? parent->child(i) : topLevelItem(i));
        if (isFolder(item) && item->isExpanded())
        {
            QList<QTreeWidgetItem *> openedSubfolders = getAllOpenedFolders(item);
            if (!openedSubfolders.empty())
                openedFolders << openedSubfolders;
            else
                openedFolders << item;
        }
    }
    return openedFolders;
}

RSS::Item *FeedListWidget::getRSSItem(QTreeWidgetItem *item) const
{
    if (!item)
        return nullptr;

    return reinterpret_cast<RSS::Item *>(item->data(0, Qt::UserRole).value<intptr_t>());
}

QTreeWidgetItem *FeedListWidget::mapRSSItem(RSS::Item *rssItem) const
{
    return m_rssToTreeItemMapping.value(rssItem);
}

QString FeedListWidget::itemPath(QTreeWidgetItem *item) const
{
    return getRSSItem(item)->path();
}

bool FeedListWidget::isFeed(QTreeWidgetItem *item) const
{
    return qobject_cast<RSS::Feed *>(getRSSItem(item));
}

bool FeedListWidget::isFolder(QTreeWidgetItem *item) const
{
    return qobject_cast<RSS::Folder *>(getRSSItem(item));
}

void FeedListWidget::dragMoveEvent(QDragMoveEvent *event)
{
    QTreeWidget::dragMoveEvent(event);

    QTreeWidgetItem *item = itemAt(event->position().toPoint());
    if ((item == m_unreadStickyItem)  // Prohibit dropping onto global unread counter
        || selectedItems().contains(m_unreadStickyItem)  // Prohibit dragging of global unread counter
        || (item && isFeed(item)))  // Prohibit dropping onto feeds
    {
        event->ignore();
    }
}

void FeedListWidget::dropEvent(QDropEvent *event)
{
    QTreeWidgetItem *destFolderItem = itemAt(event->position().toPoint());
    RSS::Folder *destFolder = (destFolderItem
                               ? static_cast<RSS::Folder *>(getRSSItem(destFolderItem))
                               : RSS::Session::instance()->rootFolder());

    // move as much items as possible
    for (QTreeWidgetItem *srcItem : asConst(selectedItems()))
    {
        auto *rssItem = getRSSItem(srcItem);
        RSS::Session::instance()->moveItem(rssItem, RSS::Item::joinPath(destFolder->path(), rssItem->name()));
    }

    QTreeWidget::dropEvent(event);
    if (destFolderItem)
        destFolderItem->setExpanded(true);
}

QTreeWidgetItem *FeedListWidget::createItem(RSS::Item *rssItem, QTreeWidgetItem *parentItem)
{
    auto *item = new FeedListItem;
    item->setData(0, Qt::DisplayRole, u"%1  (%2)"_s.arg(rssItem->name(), QString::number(rssItem->unreadCount())));
    item->setData(0, Qt::UserRole, QVariant::fromValue(reinterpret_cast<intptr_t>(rssItem)));
    m_rssToTreeItemMapping[rssItem] = item;

    QIcon icon;
    if (auto *feed = qobject_cast<RSS::Feed *>(rssItem))
        icon = rssFeedIcon(feed);
    else
        icon = UIThemeManager::instance()->getIcon(u"directory"_s);
    item->setData(0, Qt::DecorationRole, icon);

    connect(rssItem, &RSS::Item::unreadCountChanged, this, &FeedListWidget::handleItemUnreadCountChanged);

    if (!parentItem || (parentItem == m_unreadStickyItem))
        addTopLevelItem(item);
    else
        parentItem->addChild(item);

    return item;
}

void FeedListWidget::fill(QTreeWidgetItem *parent, RSS::Folder *rssParent)
{
    for (auto *rssItem : asConst(rssParent->items()))
    {
        QTreeWidgetItem *item = createItem(rssItem, parent);
        // Recursive call if this is a folder.
        if (auto *folder = qobject_cast<RSS::Folder *>(rssItem))
            fill(item, folder);
    }
}
</file>

<file path="gui/rss/feedlistwidget.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2010  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QHash>
#include <QTreeWidget>

namespace RSS
{
    class Article;
    class Feed;
    class Folder;
    class Item;
}

class FeedListWidget final : public QTreeWidget
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(FeedListWidget)

public:
    explicit FeedListWidget(QWidget *parent);

    QTreeWidgetItem *stickyUnreadItem() const;
    QList<QTreeWidgetItem *> getAllOpenedFolders(QTreeWidgetItem *parent = nullptr) const;
    RSS::Item *getRSSItem(QTreeWidgetItem *item) const;
    QTreeWidgetItem *mapRSSItem(RSS::Item *rssItem) const;
    QString itemPath(QTreeWidgetItem *item) const;
    bool isFeed(QTreeWidgetItem *item) const;
    bool isFolder(QTreeWidgetItem *item) const;

private slots:
    void handleItemAdded(RSS::Item *rssItem);
    void handleFeedStateChanged(RSS::Feed *feed);
    void handleFeedIconLoaded(RSS::Feed *feed);
    void handleItemUnreadCountChanged(RSS::Item *rssItem);
    void handleItemPathChanged(RSS::Item *rssItem);
    void handleItemAboutToBeRemoved(RSS::Item *rssItem);

private:
    void dragMoveEvent(QDragMoveEvent *event) override;
    void dropEvent(QDropEvent *event) override;
    QTreeWidgetItem *createItem(RSS::Item *rssItem, QTreeWidgetItem *parentItem = nullptr);
    void fill(QTreeWidgetItem *parent, RSS::Folder *rssParent);

    QHash<RSS::Item *, QTreeWidgetItem *> m_rssToTreeItemMapping;
    QTreeWidgetItem *m_unreadStickyItem = nullptr;
};
</file>

<file path="gui/rss/htmlbrowser.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2013  Mladen Milinkovic <max@smoothware.net>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "htmlbrowser.h"

#include <QApplication>
#include <QDateTime>
#include <QDebug>
#include <QNetworkDiskCache>
#include <QNetworkReply>
#include <QNetworkRequest>
#include <QScrollBar>
#include <QStyle>

#include "base/global.h"
#include "base/path.h"
#include "base/profile.h"

HtmlBrowser::HtmlBrowser(QWidget *parent)
    : QTextBrowser(parent)
{
    m_netManager = new QNetworkAccessManager(this);
    m_diskCache = new QNetworkDiskCache(this);
    m_diskCache->setCacheDirectory((specialFolderLocation(SpecialFolder::Cache) / Path(u"rss"_s)).data());
    m_diskCache->setMaximumCacheSize(50 * 1024 * 1024);
    qDebug() << "HtmlBrowser  cache path:" << m_diskCache->cacheDirectory() << " max size:" << m_diskCache->maximumCacheSize() / 1024 / 1024 << "MB";
    m_netManager->setCache(m_diskCache);

    connect(m_netManager, &QNetworkAccessManager::finished, this, &HtmlBrowser::resourceLoaded);
}

QVariant HtmlBrowser::loadResource(int type, const QUrl &name)
{
    if (type == QTextDocument::ImageResource)
    {
        QUrl url(name);
        if (url.scheme().isEmpty())
            url.setScheme(u"http"_s);

        QIODevice *dev = m_diskCache->data(url);
        if (dev)
        {
            qDebug() << "HtmlBrowser::loadResource() cache " << url.toString();
            QByteArray res = dev->readAll();
            delete dev;
            return res;
        }

        if (!m_activeRequests.contains(url))
        {
            m_activeRequests.insert(url, true);
            qDebug() << "HtmlBrowser::loadResource() get " << url.toString();
            QNetworkRequest req(url);
            req.setAttribute(QNetworkRequest::CacheLoadControlAttribute, QNetworkRequest::PreferCache);
            m_netManager->get(req);
        }

        return {};
    }

    return QTextBrowser::loadResource(type, name);
}

void HtmlBrowser::resourceLoaded(QNetworkReply *reply)
{
    m_activeRequests.remove(reply->request().url());

    if ((reply->error() == QNetworkReply::NoError) && (reply->size() > 0))
    {
        qDebug() << "HtmlBrowser::resourceLoaded() save " << reply->request().url().toString();
    }
    else
    {
        // If resource failed to load, replace it with warning icon and store it in cache for 1 day.
        // Otherwise HTMLBrowser will keep trying to download it every time article is displayed,
        // since it's not possible to cache error responses.
        QNetworkCacheMetaData metaData;
        QNetworkCacheMetaData::AttributesMap atts;
        metaData.setUrl(reply->request().url());
        metaData.setSaveToDisk(true);
        atts[QNetworkRequest::HttpStatusCodeAttribute] = 200;
        atts[QNetworkRequest::HttpReasonPhraseAttribute] = u"Ok"_s;
        metaData.setAttributes(atts);
        const auto currentDateTime = QDateTime::currentDateTime();
        metaData.setLastModified(currentDateTime);
        metaData.setExpirationDate(currentDateTime.addDays(1));
        QIODevice *dev = m_diskCache->prepare(metaData);
        if (!dev)
            return;

        QApplication::style()->standardIcon(QStyle::SP_MessageBoxWarning).pixmap(32, 32).save(dev, "PNG");
        m_diskCache->insert(dev);
    }
    // Refresh the document display and keep scrollbars where they are
    int sx = horizontalScrollBar()->value();
    int sy = verticalScrollBar()->value();
    document()->setHtml(document()->toHtml());
    horizontalScrollBar()->setValue(sx);
    verticalScrollBar()->setValue(sy);
}
</file>

<file path="gui/rss/htmlbrowser.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2013  Mladen Milinkovic <max@smoothware.net>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QHash>
#include <QTextBrowser>

class QNetworkAccessManager;
class QNetworkDiskCache;
class QNetworkReply;

class HtmlBrowser final : public QTextBrowser
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(HtmlBrowser)

public:
    explicit HtmlBrowser(QWidget* parent = nullptr);
    ~HtmlBrowser() = default;

    QVariant loadResource(int type, const QUrl &name) override;

protected:
    QNetworkAccessManager *m_netManager = nullptr;
    QNetworkDiskCache *m_diskCache = nullptr;
    QHash<QUrl, bool> m_activeRequests;

protected slots:
    void resourceLoaded(QNetworkReply *reply);
};
</file>

<file path="gui/rss/rssfeeddialog.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2025  Vladimir Golovnev <glassez@yandex.ru>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "rssfeeddialog.h"

#include <QPushButton>

#include "ui_rssfeeddialog.h"

RSSFeedDialog::RSSFeedDialog(QWidget *parent)
    : QDialog(parent)
    , m_ui {new Ui::RSSFeedDialog}
{
    m_ui->setupUi(this);

    m_ui->spinRefreshInterval->setMaximum(std::numeric_limits<int>::max());
    m_ui->spinRefreshInterval->setStepType(QAbstractSpinBox::AdaptiveDecimalStepType);
    m_ui->spinRefreshInterval->setSuffix(tr(" sec"));
    m_ui->spinRefreshInterval->setSpecialValueText(tr("Default"));

    // disable Ok button
    m_ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(false);
    connect(m_ui->buttonBox, &QDialogButtonBox::accepted, this, &QDialog::accept);
    connect(m_ui->buttonBox, &QDialogButtonBox::rejected, this, &QDialog::reject);

    connect(m_ui->textFeedURL, &QLineEdit::textChanged, this, &RSSFeedDialog::feedURLChanged);
}

RSSFeedDialog::~RSSFeedDialog()
{
    delete m_ui;
}

QString RSSFeedDialog::feedURL() const
{
    return m_ui->textFeedURL->text();
}

void RSSFeedDialog::setFeedURL(const QString &feedURL)
{
    m_ui->textFeedURL->setText(feedURL);
}

std::chrono::seconds RSSFeedDialog::refreshInterval() const
{
    return std::chrono::seconds(m_ui->spinRefreshInterval->value());
}

void RSSFeedDialog::setRefreshInterval(const std::chrono::seconds refreshInterval)
{
    m_ui->spinRefreshInterval->setValue(refreshInterval.count());
}

void RSSFeedDialog::feedURLChanged(const QString &feedURL)
{
    m_ui->buttonBox->button(QDialogButtonBox::Ok)->setEnabled(!feedURL.isEmpty());
}
</file>

<file path="gui/rss/rssfeeddialog.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2025  Vladimir Golovnev <glassez@yandex.ru>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <chrono>
#include <QDialog>

namespace Ui
{
    class RSSFeedDialog;
}

class RSSFeedDialog final : public QDialog
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(RSSFeedDialog)

public:
    explicit RSSFeedDialog(QWidget *parent = nullptr);
    ~RSSFeedDialog() override;

    QString feedURL() const;
    void setFeedURL(const QString &feedURL);
    std::chrono::seconds refreshInterval() const;
    void setRefreshInterval(std::chrono::seconds refreshInterval);

private:
    void feedURLChanged(const QString &feedURL);

    Ui::RSSFeedDialog *m_ui = nullptr;
};
</file>

<file path="gui/rss/rssfeeddialog.ui">
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>RSSFeedDialog</class>
 <widget class="QDialog" name="RSSFeedDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>555</width>
    <height>106</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>RSS Feed Options</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QGridLayout" name="gridLayout">
     <item row="0" column="0">
      <widget class="QLabel" name="labelFeedURL">
       <property name="text">
        <string>URL:</string>
       </property>
      </widget>
     </item>
     <item row="0" column="1">
      <widget class="QLineEdit" name="textFeedURL"/>
     </item>
     <item row="1" column="0">
      <widget class="QLabel" name="labelRefreshInterval">
       <property name="text">
        <string>Refresh interval:</string>
       </property>
      </widget>
     </item>
     <item row="1" column="1">
      <widget class="QSpinBox" name="spinRefreshInterval">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <spacer name="verticalSpacer_2">
     <property name="orientation">
      <enum>Qt::Orientation::Vertical</enum>
     </property>
     <property name="sizeHint" stdset="0">
      <size>
       <width>20</width>
       <height>40</height>
      </size>
     </property>
    </spacer>
   </item>
   <item>
    <widget class="QDialogButtonBox" name="buttonBox">
     <property name="orientation">
      <enum>Qt::Orientation::Horizontal</enum>
     </property>
     <property name="standardButtons">
      <set>QDialogButtonBox::StandardButton::Cancel|QDialogButtonBox::StandardButton::Ok</set>
     </property>
    </widget>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
</file>

<file path="gui/rss/rsswidget.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2006  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "rsswidget.h"

#include <QClipboard>
#include <QDesktopServices>
#include <QDragMoveEvent>
#include <QMenu>
#include <QMessageBox>
#include <QRegularExpression>
#include <QShortcut>
#include <QString>

#include "base/global.h"
#include "base/net/downloadmanager.h"
#include "base/preferences.h"
#include "base/rss/rss_article.h"
#include "base/rss/rss_feed.h"
#include "base/rss/rss_folder.h"
#include "base/rss/rss_session.h"
#include "gui/autoexpandabledialog.h"
#include "gui/interfaces/iguiapplication.h"
#include "gui/uithememanager.h"
#include "gui/utils/keysequence.h"
#include "articlelistwidget.h"
#include "automatedrssdownloader.h"
#include "feedlistwidget.h"
#include "rssfeeddialog.h"
#include "ui_rsswidget.h"

namespace
{
    void convertRelativeUrlToAbsolute(QString &html, const QString &baseUrl)
    {
        const QRegularExpression rx {uR"(((<a\s+[^>]*?href|<img\s+[^>]*?src)\s*=\s*["'])((https?|ftp):)?(\/\/[^\/]*)?(\/?[^\/"].*?)(["']))"_s
            , QRegularExpression::CaseInsensitiveOption};

        const QString normalizedBaseUrl = baseUrl.endsWith(u'/') ? baseUrl : (baseUrl + u'/');
        const QUrl url {normalizedBaseUrl};
        const QString defaultScheme = url.scheme();
        QRegularExpressionMatchIterator iter = rx.globalMatch(html);

        while (iter.hasNext())
        {
            const QRegularExpressionMatch match = iter.next();
            const QStringView scheme = match.capturedView(4);
            const QStringView host = match.capturedView(5);
            if (!scheme.isEmpty())
            {
                if (host.isEmpty())
                    break; // invalid URL, should never happen

                // already absolute URL
                continue;
            }

            QStringView relativePath = match.capturedView(6);
            if (relativePath.startsWith(u'/'))
            {
#if QT_VERSION >= QT_VERSION_CHECK(6, 8, 0)
                relativePath.slice(1);
#else
                relativePath = relativePath.sliced(1);
#endif
            }

            const QString absoluteUrl = !host.isEmpty()
                    ? QString(defaultScheme + u':' + host) : (normalizedBaseUrl + relativePath);
            const QString fullMatch = match.captured(0);
            const QStringView prefix = match.capturedView(1);
            const QStringView suffix = match.capturedView(7);

            html.replace(fullMatch, (prefix + absoluteUrl + suffix));
        }
    }
}


RSSWidget::RSSWidget(IGUIApplication *app, QWidget *parent)
    : GUIApplicationComponent(app, parent)
    , m_ui {new Ui::RSSWidget}
{
    m_ui->setupUi(this);

    // Icons
    m_ui->actionCopyFeedURL->setIcon(UIThemeManager::instance()->getIcon(u"edit-copy"_s));
    m_ui->actionDelete->setIcon(UIThemeManager::instance()->getIcon(u"edit-clear"_s));
    m_ui->actionDownloadTorrent->setIcon(UIThemeManager::instance()->getIcon(u"downloading"_s, u"download"_s));
    m_ui->actionEditFeed->setIcon(UIThemeManager::instance()->getIcon(u"edit-rename"_s));
    m_ui->actionMarkItemsRead->setIcon(UIThemeManager::instance()->getIcon(u"task-complete"_s, u"mail-mark-read"_s));
    m_ui->actionNewFolder->setIcon(UIThemeManager::instance()->getIcon(u"folder-new"_s));
    m_ui->actionNewSubscription->setIcon(UIThemeManager::instance()->getIcon(u"list-add"_s));
    m_ui->actionOpenNewsURL->setIcon(UIThemeManager::instance()->getIcon(u"application-url"_s));
    m_ui->actionRename->setIcon(UIThemeManager::instance()->getIcon(u"edit-rename"_s));
    m_ui->actionUpdate->setIcon(UIThemeManager::instance()->getIcon(u"view-refresh"_s));
    m_ui->actionUpdateAllFeeds->setIcon(UIThemeManager::instance()->getIcon(u"view-refresh"_s));
#ifndef Q_OS_MACOS
    m_ui->newFeedButton->setIcon(UIThemeManager::instance()->getIcon(u"list-add"_s));
    m_ui->markReadButton->setIcon(UIThemeManager::instance()->getIcon(u"task-complete"_s, u"mail-mark-read"_s));
    m_ui->updateAllButton->setIcon(UIThemeManager::instance()->getIcon(u"view-refresh"_s));
    m_ui->rssDownloaderBtn->setIcon(UIThemeManager::instance()->getIcon(u"downloading"_s, u"download"_s));
#endif

    connect(m_ui->articleListWidget, &ArticleListWidget::customContextMenuRequested, this, &RSSWidget::displayItemsListMenu);
    connect(m_ui->articleListWidget, &ArticleListWidget::currentItemChanged, this, &RSSWidget::handleCurrentArticleItemChanged);
    connect(m_ui->articleListWidget, &ArticleListWidget::itemDoubleClicked, this, &RSSWidget::downloadSelectedTorrents);

    connect(m_ui->feedListWidget, &QAbstractItemView::doubleClicked, this, &RSSWidget::renameSelectedRSSItem);
    connect(m_ui->feedListWidget, &QTreeWidget::currentItemChanged, this, &RSSWidget::handleCurrentFeedItemChanged);
    connect(m_ui->feedListWidget, &QWidget::customContextMenuRequested, this, &RSSWidget::displayRSSListMenu);
    loadFoldersOpenState();
    m_ui->feedListWidget->setCurrentItem(m_ui->feedListWidget->stickyUnreadItem());

    const auto *editHotkey = new QShortcut(Qt::Key_F2, m_ui->feedListWidget, nullptr, nullptr, Qt::WidgetShortcut);
    connect(editHotkey, &QShortcut::activated, this, &RSSWidget::renameSelectedRSSItem);
    const auto *deleteHotkey = new QShortcut(Utils::KeySequence::deleteItem(), m_ui->feedListWidget, nullptr, nullptr, Qt::WidgetShortcut);
    connect(deleteHotkey, &QShortcut::activated, this, &RSSWidget::deleteSelectedItems);

    // Feeds list actions
    connect(m_ui->actionDelete, &QAction::triggered, this, &RSSWidget::deleteSelectedItems);
    connect(m_ui->actionRename, &QAction::triggered, this, &RSSWidget::renameSelectedRSSItem);
    connect(m_ui->actionEditFeed, &QAction::triggered, this, &RSSWidget::editSelectedRSSFeed);
    connect(m_ui->actionUpdate, &QAction::triggered, this, &RSSWidget::refreshSelectedItems);
    connect(m_ui->actionNewFolder, &QAction::triggered, this, &RSSWidget::askNewFolder);
    connect(m_ui->actionNewSubscription, &QAction::triggered, this, &RSSWidget::on_newFeedButton_clicked);
    connect(m_ui->actionUpdateAllFeeds, &QAction::triggered, this, &RSSWidget::refreshAllFeeds);
    connect(m_ui->updateAllButton, &QAbstractButton::clicked, this, &RSSWidget::refreshAllFeeds);
    connect(m_ui->actionCopyFeedURL, &QAction::triggered, this, &RSSWidget::copySelectedFeedsURL);
    connect(m_ui->actionMarkItemsRead, &QAction::triggered, this, &RSSWidget::on_markReadButton_clicked);

    // News list actions
    connect(m_ui->actionOpenNewsURL, &QAction::triggered, this, &RSSWidget::openSelectedArticlesUrls);
    connect(m_ui->actionDownloadTorrent, &QAction::triggered, this, &RSSWidget::downloadSelectedTorrents);

    // Restore sliders position
    restoreSlidersPosition();
    // Bind saveSliders slots
    connect(m_ui->splitterMain, &QSplitter::splitterMoved, this, &RSSWidget::saveSlidersPosition);
    connect(m_ui->splitterSide, &QSplitter::splitterMoved, this, &RSSWidget::saveSlidersPosition);

    if (RSS::Session::instance()->isProcessingEnabled())
        m_ui->labelWarn->hide();
    connect(RSS::Session::instance(), &RSS::Session::processingStateChanged
            , this, &RSSWidget::handleSessionProcessingStateChanged);
    connect(RSS::Session::instance()->rootFolder(), &RSS::Folder::unreadCountChanged
            , this, &RSSWidget::handleUnreadCountChanged);

    m_ui->textBrowser->installEventFilter(this);
}

RSSWidget::~RSSWidget()
{
    // we need it here to properly mark latest article
    // as read without having additional code
    m_ui->articleListWidget->clear();

    saveFoldersOpenState();

    delete m_ui;
}

// display a right-click menu
void RSSWidget::displayRSSListMenu(const QPoint &pos)
{
    if (!m_ui->feedListWidget->indexAt(pos).isValid())
        // No item under the mouse, clear selection
        m_ui->feedListWidget->clearSelection();

    QMenu *menu = new QMenu(this);
    menu->setAttribute(Qt::WA_DeleteOnClose);

    const QList<QTreeWidgetItem *> selectedItems = m_ui->feedListWidget->selectedItems();
    if (!selectedItems.isEmpty())
    {
        menu->addAction(m_ui->actionUpdate);
        menu->addAction(m_ui->actionMarkItemsRead);
        menu->addSeparator();

        if (selectedItems.size() == 1)
        {
            QTreeWidgetItem *selectedItem = selectedItems.first();
            if (selectedItem != m_ui->feedListWidget->stickyUnreadItem())
            {
                menu->addAction(m_ui->actionRename);
                if (m_ui->feedListWidget->isFeed(selectedItem))
                    menu->addAction(m_ui->actionEditFeed);
                menu->addAction(m_ui->actionDelete);
                menu->addSeparator();
                if (m_ui->feedListWidget->isFolder(selectedItem))
                    menu->addAction(m_ui->actionNewFolder);
            }
        }
        else
        {
            menu->addAction(m_ui->actionDelete);
            menu->addSeparator();
        }

        menu->addAction(m_ui->actionNewSubscription);

        if (m_ui->feedListWidget->isFeed(selectedItems.first()))
        {
            menu->addSeparator();
            menu->addAction(m_ui->actionCopyFeedURL);
        }
    }
    else
    {
        menu->addAction(m_ui->actionNewSubscription);
        menu->addAction(m_ui->actionNewFolder);
        menu->addSeparator();
        menu->addAction(m_ui->actionUpdateAllFeeds);
    }

    menu->popup(QCursor::pos());
}

void RSSWidget::displayItemsListMenu()
{
    bool hasTorrent = false;
    bool hasLink = false;
    for (const QListWidgetItem *item : asConst(m_ui->articleListWidget->selectedItems()))
    {
        auto *article = item->data(Qt::UserRole).value<RSS::Article *>();
        Q_ASSERT(article);

        if (!article->torrentUrl().isEmpty())
            hasTorrent = true;
        if (!article->link().isEmpty())
            hasLink = true;
        if (hasTorrent && hasLink)
            break;
    }

    QMenu *myItemListMenu = new QMenu(this);
    myItemListMenu->setAttribute(Qt::WA_DeleteOnClose);

    if (hasTorrent)
        myItemListMenu->addAction(m_ui->actionDownloadTorrent);
    if (hasLink)
        myItemListMenu->addAction(m_ui->actionOpenNewsURL);

    if (!myItemListMenu->isEmpty())
        myItemListMenu->popup(QCursor::pos());
}

void RSSWidget::askNewFolder()
{
    bool ok = false;
    QString newName = AutoExpandableDialog::getText(
                this, tr("Please choose a folder name"), tr("Folder name:"), QLineEdit::Normal
                , tr("New folder"), &ok);
    if (!ok) return;

    newName = newName.trimmed();
    if (newName.isEmpty()) return;

    // Determine destination folder for new item
    QTreeWidgetItem *destItem = nullptr;
    QList<QTreeWidgetItem *> selectedItems = m_ui->feedListWidget->selectedItems();
    if (!selectedItems.empty())
    {
        destItem = selectedItems.first();
        if (!m_ui->feedListWidget->isFolder(destItem))
            destItem = destItem->parent();
    }
    // Consider the case where the user clicked on Unread item
    RSS::Folder *rssDestFolder = ((!destItem || (destItem == m_ui->feedListWidget->stickyUnreadItem()))
            ? RSS::Session::instance()->rootFolder()
            : qobject_cast<RSS::Folder *>(m_ui->feedListWidget->getRSSItem(destItem)));

    const QString newFolderPath = RSS::Item::joinPath(rssDestFolder->path(), newName);
    const nonstd::expected<RSS::Folder *, QString> result = RSS::Session::instance()->addFolder(newFolderPath);
    if (!result)
    {
        QMessageBox::warning(this, u"qBittorrent"_s, result.error(), QMessageBox::Ok);
        return;
    }

    RSS::Folder *newFolder = result.value();

    // Expand destination folder to display new feed
    if (destItem && (destItem != m_ui->feedListWidget->stickyUnreadItem()))
        destItem->setExpanded(true);
    // As new RSS items are added synchronously, we can do the following here.
    m_ui->feedListWidget->setCurrentItem(m_ui->feedListWidget->mapRSSItem(newFolder));
}

// add a stream by a button
void RSSWidget::on_newFeedButton_clicked()
{
    // Determine destination folder for new item
    QTreeWidgetItem *destItem = nullptr;
    QList<QTreeWidgetItem *> selectedItems = m_ui->feedListWidget->selectedItems();
    if (!selectedItems.empty())
    {
        destItem = selectedItems.first();
        if (!m_ui->feedListWidget->isFolder(destItem))
            destItem = destItem->parent();
    }
    // Consider the case where the user clicked on Unread item
    RSS::Folder *destFolder = ((!destItem || (destItem == m_ui->feedListWidget->stickyUnreadItem()))
            ? RSS::Session::instance()->rootFolder()
            : qobject_cast<RSS::Folder *>(m_ui->feedListWidget->getRSSItem(destItem)));

    // Ask for feed URL
    const QString clipText = qApp->clipboard()->text();
    const QString defaultURL = Net::DownloadManager::hasSupportedScheme(clipText) ? clipText : u"https://"_s;

    RSS::Feed *newFeed = nullptr;
    RSSFeedDialog dialog {this};
    dialog.setFeedURL(defaultURL);
    while (!newFeed && (dialog.exec() == RSSFeedDialog::Accepted))
    {
        const QString feedURL = dialog.feedURL().trimmed();
        const std::chrono::seconds refreshInterval = dialog.refreshInterval();

        const QString feedPath = RSS::Item::joinPath(destFolder->path(), feedURL);
        const nonstd::expected<RSS::Feed *, QString> result = RSS::Session::instance()->addFeed(feedURL, feedPath, refreshInterval);
        if (result)
            newFeed = result.value();
        else
            QMessageBox::warning(&dialog, u"qBittorrent"_s, result.error(), QMessageBox::Ok);
    }

    if (!newFeed)
        return;

    // Expand destination folder to display new feed
    if (destItem && (destItem != m_ui->feedListWidget->stickyUnreadItem()))
        destItem->setExpanded(true);
    // As new RSS items are added synchronously, we can do the following here.
    m_ui->feedListWidget->setCurrentItem(m_ui->feedListWidget->mapRSSItem(newFeed));
}

void RSSWidget::deleteSelectedItems()
{
    const QList<QTreeWidgetItem *> selectedItems = m_ui->feedListWidget->selectedItems();
    if (selectedItems.isEmpty())
        return;
    if ((selectedItems.size() == 1) && (selectedItems.first() == m_ui->feedListWidget->stickyUnreadItem()))
        return;

    QMessageBox::StandardButton answer = QMessageBox::question(
                this, tr("Deletion confirmation"), tr("Are you sure you want to delete the selected RSS feeds?")
                , QMessageBox::Yes | QMessageBox::No, QMessageBox::No);
    if (answer == QMessageBox::No)
        return;

    for (QTreeWidgetItem *item : selectedItems)
        if (item != m_ui->feedListWidget->stickyUnreadItem())
            RSS::Session::instance()->removeItem(m_ui->feedListWidget->itemPath(item));
}

void RSSWidget::loadFoldersOpenState()
{
    const QStringList openedFolders = Preferences::instance()->getRssOpenFolders();
    for (const QString &varPath : openedFolders)
    {
        QTreeWidgetItem *parent = nullptr;
        for (const QString &name : asConst(varPath.split(u'\\')))
        {
            int nbChildren = (parent ? parent->childCount() : m_ui->feedListWidget->topLevelItemCount());
            for (int i = 0; i < nbChildren; ++i)
            {
                QTreeWidgetItem *child = (parent ? parent->child(i) : m_ui->feedListWidget->topLevelItem(i));
                if (m_ui->feedListWidget->getRSSItem(child)->name() == name)
                {
                    parent = child;
                    parent->setExpanded(true);
                    break;
                }
            }
        }
    }
}

void RSSWidget::saveFoldersOpenState()
{
    QStringList openedFolders;
    for (QTreeWidgetItem *item : asConst(m_ui->feedListWidget->getAllOpenedFolders()))
        openedFolders << m_ui->feedListWidget->itemPath(item);
    Preferences::instance()->setRssOpenFolders(openedFolders);
}

void RSSWidget::refreshAllFeeds()
{
    RSS::Session::instance()->rootFolder()->refresh();
}

void RSSWidget::downloadSelectedTorrents()
{
    for (QListWidgetItem *item : asConst(m_ui->articleListWidget->selectedItems()))
    {
        auto *article = item->data(Qt::UserRole).value<RSS::Article *>();
        Q_ASSERT(article);

        // Mark as read
        article->markAsRead();

        app()->addTorrentManager()->addTorrent(article->torrentUrl());
    }
}

// open the url of the selected RSS articles in the Web browser
void RSSWidget::openSelectedArticlesUrls()
{
    for (QListWidgetItem *item : asConst(m_ui->articleListWidget->selectedItems()))
    {
        auto *article = item->data(Qt::UserRole).value<RSS::Article *>();
        Q_ASSERT(article);

        // Mark as read
        article->markAsRead();

        if (!article->link().isEmpty())
            QDesktopServices::openUrl(QUrl(article->link()));
    }
}

void RSSWidget::renameSelectedRSSItem()
{
    QList<QTreeWidgetItem *> selectedItems = m_ui->feedListWidget->selectedItems();
    if (selectedItems.size() != 1) return;

    QTreeWidgetItem *item = selectedItems.first();
    if (item == m_ui->feedListWidget->stickyUnreadItem())
        return;

    RSS::Item *rssItem = m_ui->feedListWidget->getRSSItem(item);
    const QString parentPath = RSS::Item::parentPath(rssItem->path());
    bool ok = false;
    do
    {
        QString newName = AutoExpandableDialog::getText(
                    this, tr("Please choose a new name for this RSS feed"), tr("New feed name:")
                    , QLineEdit::Normal, rssItem->name(), &ok);
        // Check if name is already taken
        if (!ok) return;

        const nonstd::expected<void, QString> result = RSS::Session::instance()->moveItem(rssItem, RSS::Item::joinPath(parentPath, newName));
        if (!result)
        {
            QMessageBox::warning(nullptr, tr("Rename failed"), result.error());
            ok = false;
        }
    } while (!ok);
}

void RSSWidget::editSelectedRSSFeed()
{
    QList<QTreeWidgetItem *> selectedItems = m_ui->feedListWidget->selectedItems();
    if (selectedItems.size() != 1)
        return;

    QTreeWidgetItem *item = selectedItems.first();
    RSS::Feed *rssFeed = qobject_cast<RSS::Feed *>(m_ui->feedListWidget->getRSSItem(item));
    Q_ASSERT(rssFeed);
    if (!rssFeed) [[unlikely]]
        return;

    auto *dialog = new RSSFeedDialog(this);
    dialog->setAttribute(Qt::WA_DeleteOnClose);
    dialog->setFeedURL(rssFeed->url());
    dialog->setRefreshInterval(rssFeed->refreshInterval());
    connect(dialog, &RSSFeedDialog::accepted, this, [this, dialog, rssFeed]
    {
        rssFeed->setRefreshInterval(dialog->refreshInterval());

        const QString newURL = dialog->feedURL();
        const nonstd::expected<void, QString> result = RSS::Session::instance()->setFeedURL(rssFeed, newURL);
        if (!result)
            QMessageBox::warning(this, u"qBittorrent"_s, result.error(), QMessageBox::Ok);
    });
    dialog->open();
}

void RSSWidget::refreshSelectedItems()
{
    for (QTreeWidgetItem *item : asConst(m_ui->feedListWidget->selectedItems()))
    {
        if (item == m_ui->feedListWidget->stickyUnreadItem())
        {
            refreshAllFeeds();
            return;
        }

        m_ui->feedListWidget->getRSSItem(item)->refresh();
    }
}

void RSSWidget::copySelectedFeedsURL()
{
    QStringList URLs;
    for (QTreeWidgetItem *item : asConst(m_ui->feedListWidget->selectedItems()))
    {
        if (auto *feed = qobject_cast<RSS::Feed *>(m_ui->feedListWidget->getRSSItem(item)))
            URLs << feed->url();
    }
    qApp->clipboard()->setText(URLs.join(u'\n'));
}

void RSSWidget::handleCurrentFeedItemChanged(QTreeWidgetItem *currentItem)
{
    m_ui->articleListWidget->setRSSItem(m_ui->feedListWidget->getRSSItem(currentItem)
                                    , (currentItem == m_ui->feedListWidget->stickyUnreadItem()));
}

void RSSWidget::on_markReadButton_clicked()
{
    for (QTreeWidgetItem *item : asConst(m_ui->feedListWidget->selectedItems()))
    {
        m_ui->feedListWidget->getRSSItem(item)->markAsRead();
        if (item == m_ui->feedListWidget->stickyUnreadItem())
            break; // all items was read
    }
}

// display a news
void RSSWidget::handleCurrentArticleItemChanged(QListWidgetItem *currentItem, QListWidgetItem *previousItem)
{
    m_ui->textBrowser->clear();

    if (previousItem)
    {
        auto *article = m_ui->articleListWidget->getRSSArticle(previousItem);
        Q_ASSERT(article);
        article->markAsRead();
    }

    if (!currentItem)
        return;

    auto *article = m_ui->articleListWidget->getRSSArticle(currentItem);
    renderArticle(article);
}

void RSSWidget::saveSlidersPosition()
{
    // Remember sliders positions
    Preferences *const pref = Preferences::instance();
    pref->setRssSideSplitterState(m_ui->splitterSide->saveState());
    pref->setRssMainSplitterState(m_ui->splitterMain->saveState());
}

void RSSWidget::restoreSlidersPosition()
{
    const Preferences *const pref = Preferences::instance();
    const QByteArray stateSide = pref->getRssSideSplitterState();
    if (!stateSide.isEmpty())
        m_ui->splitterSide->restoreState(stateSide);
    const QByteArray stateMain = pref->getRssMainSplitterState();
    if (!stateMain.isEmpty())
        m_ui->splitterMain->restoreState(stateMain);
}

void RSSWidget::updateRefreshInterval(int val) const
{
    RSS::Session::instance()->setRefreshInterval(val);
}

void RSSWidget::on_rssDownloaderBtn_clicked()
{
    auto *downloader = new AutomatedRssDownloader(this);
    downloader->setAttribute(Qt::WA_DeleteOnClose);
    downloader->open();
}

void RSSWidget::handleSessionProcessingStateChanged(bool enabled)
{
    m_ui->labelWarn->setVisible(!enabled);
}

void RSSWidget::handleUnreadCountChanged()
{
    emit unreadCountUpdated(RSS::Session::instance()->rootFolder()->unreadCount());
}

bool RSSWidget::eventFilter(QObject *obj, QEvent *event)
{
    if ((obj == m_ui->textBrowser) && (event->type() == QEvent::PaletteChange))
    {
        QListWidgetItem *currentItem = m_ui->articleListWidget->currentItem();
        if (currentItem)
        {
            const RSS::Article *article = m_ui->articleListWidget->getRSSArticle(currentItem);
            renderArticle(article);
        }
    }

    return false;
}

void RSSWidget::renderArticle(const RSS::Article *article) const
{
    Q_ASSERT(article);

    const QString articleLink = article->link();
    const QString highlightedBaseColor = m_ui->textBrowser->palette().color(QPalette::Active, QPalette::Highlight).name();
    const QString highlightedBaseTextColor = m_ui->textBrowser->palette().color(QPalette::Active, QPalette::HighlightedText).name();
    const QString alternateBaseColor = m_ui->textBrowser->palette().color(QPalette::Active, QPalette::AlternateBase).name();

    QString html = u"<div style='border: 2px solid red; margin-left: 5px; margin-right: 5px; margin-bottom: 5px;'>"
        + u"<div style='background-color: \"%1\"; font-weight: bold; color: \"%2\";'>%3</div>"_s.arg(highlightedBaseColor, highlightedBaseTextColor, article->title());
    if (const QDateTime articleDate = article->date(); articleDate.isValid())
        html += u"<div style='background-color: \"%1\";'><b>%2</b>%3</div>"_s.arg(alternateBaseColor, tr("Date: "), QLocale::system().toString(articleDate.toLocalTime(), QLocale::ShortFormat));
    if (m_ui->feedListWidget->currentItem() == m_ui->feedListWidget->stickyUnreadItem())
        html += u"<div style='background-color: \"%1\";'><b>%2</b>%3</div>"_s.arg(alternateBaseColor, tr("Feed: "), article->feed()->title());
    if (const QString articleAuthor = article->author(); !articleAuthor.isEmpty())
        html += u"<div style='background-color: \"%1\";'><b>%2</b>%3</div>"_s.arg(alternateBaseColor, tr("Author: "), articleAuthor);
    if (!articleLink.isEmpty())
        html += u"<div style='background-color: \"%1\";'><a href='%2' target='_blank'><b>%3</b></a></div>"_s.arg(alternateBaseColor, articleLink, tr("Open link"));
    html += u"</div>"
            u"<div style='margin-left: 5px; margin-right: 5px;'>";
    if (QString description = article->description(); Qt::mightBeRichText(description))
    {
        html += description;
    }
    else
    {
        QRegularExpression rx;
        // If description is plain text, replace BBCode tags with HTML and wrap everything in <pre></pre> so it looks nice
        rx.setPatternOptions(QRegularExpression::InvertedGreedinessOption
                             | QRegularExpression::CaseInsensitiveOption);

        rx.setPattern(u"\\[img\\](.+)\\[/img\\]"_s);
        description.replace(rx, u"<img src=\"\\1\">"_s);

        rx.setPattern(u"\\[url=(\")?(.+)\\1\\]"_s);
        description.replace(rx, u"<a href=\"\\2\">"_s)
            .replace(u"[/url]"_s, u"</a>"_s, Qt::CaseInsensitive);

        rx.setPattern(u"\\[(/)?([bius])\\]"_s);
        description.replace(rx, u"<\\1\\2>"_s);

        rx.setPattern(u"\\[color=(\")?(.+)\\1\\]"_s);
        description.replace(rx, u"<span style=\"color:\\2\">"_s)
            .replace(u"[/color]"_s, u"</span>"_s, Qt::CaseInsensitive);

        rx.setPattern(u"\\[size=(\")?(.+)\\d\\1\\]"_s);
        description.replace(rx, u"<span style=\"font-size:\\2px\">"_s)
            .replace(u"[/size]"_s, u"</span>"_s, Qt::CaseInsensitive);

        html += u"<pre>" + description + u"</pre>";
    }
    html += u"</div>";

    // Supplement relative URLs to absolute ones
    const QUrl url {articleLink};
    const QString baseUrl = url.toString(QUrl::RemovePath | QUrl::RemoveQuery);
    convertRelativeUrlToAbsolute(html, baseUrl);

    m_ui->textBrowser->setHtml(html);
}
</file>

<file path="gui/rss/rsswidget.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2017-2023  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 * Copyright (C) 2006  Arnaud Demaiziere <arnaud@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QWidget>

#include "gui/guiapplicationcomponent.h"

class QListWidgetItem;
class QTreeWidgetItem;

namespace RSS
{
    class Article;
}

namespace Ui
{
    class RSSWidget;
}

class RSSWidget final : public GUIApplicationComponent<QWidget>
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(RSSWidget)

public:
    explicit RSSWidget(IGUIApplication *app, QWidget *parent = nullptr);
    ~RSSWidget() override;

public slots:
    void deleteSelectedItems();
    void updateRefreshInterval(int val) const;

signals:
    void unreadCountUpdated(int count);

private slots:
    void on_newFeedButton_clicked();
    void refreshAllFeeds();
    void on_markReadButton_clicked();
    void displayRSSListMenu(const QPoint &pos);
    void displayItemsListMenu();
    void renameSelectedRSSItem();
    void editSelectedRSSFeed();
    void refreshSelectedItems();
    void copySelectedFeedsURL();
    void handleCurrentFeedItemChanged(QTreeWidgetItem *currentItem);
    void handleCurrentArticleItemChanged(QListWidgetItem *currentItem, QListWidgetItem *previousItem);
    void openSelectedArticlesUrls();
    void downloadSelectedTorrents();
    void saveSlidersPosition();
    void restoreSlidersPosition();
    void askNewFolder();
    void saveFoldersOpenState();
    void loadFoldersOpenState();
    void on_rssDownloaderBtn_clicked();
    void handleSessionProcessingStateChanged(bool enabled);
    void handleUnreadCountChanged();

private:
    bool eventFilter(QObject *obj, QEvent *event) override;
    void renderArticle(const RSS::Article *article) const;

    Ui::RSSWidget *m_ui = nullptr;
};
</file>

<file path="gui/rss/rsswidget.ui">
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>RSSWidget</class>
 <widget class="QWidget" name="RSSWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>811</width>
    <height>447</height>
   </rect>
  </property>
  <property name="acceptDrops">
   <bool>false</bool>
  </property>
  <property name="windowTitle">
   <string>Search</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_2">
   <item>
    <widget class="QLabel" name="labelWarn">
     <property name="font">
      <font>
       <italic>true</italic>
      </font>
     </property>
     <property name="styleSheet">
      <string notr="true">color: red;</string>
     </property>
     <property name="text">
      <string>Fetching of RSS feeds is disabled now! You can enable it in application settings.</string>
     </property>
     <property name="wordWrap">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QPushButton" name="newFeedButton">
       <property name="text">
        <string>New subscription</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="markReadButton">
       <property name="text">
        <string>Mark items read</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="updateAllButton">
       <property name="toolTip">
        <string>Refresh RSS streams</string>
       </property>
       <property name="text">
        <string>Update all</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="spacer1">
       <property name="orientation">
        <enum>Qt::Orientation::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="rssDownloaderBtn">
       <property name="text">
        <string>RSS Downloader...</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QSplitter" name="splitterSide">
     <property name="sizePolicy">
      <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
       <horstretch>0</horstretch>
       <verstretch>0</verstretch>
      </sizepolicy>
     </property>
     <property name="orientation">
      <enum>Qt::Orientation::Horizontal</enum>
     </property>
     <widget class="FeedListWidget" name="feedListWidget"/>
     <widget class="QWidget" name="layoutWidget">
      <layout class="QVBoxLayout" name="verticalLayout">
       <item>
        <widget class="QLabel" name="news_lbl">
         <property name="font">
          <font>
           <bold>true</bold>
          </font>
         </property>
         <property name="text">
          <string>Torrents: (double-click to download)</string>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QSplitter" name="splitterMain">
         <property name="sizePolicy">
          <sizepolicy hsizetype="Expanding" vsizetype="Expanding">
           <horstretch>0</horstretch>
           <verstretch>0</verstretch>
          </sizepolicy>
         </property>
         <property name="orientation">
          <enum>Qt::Orientation::Horizontal</enum>
         </property>
         <widget class="ArticleListWidget" name="articleListWidget"/>
         <widget class="HtmlBrowser" name="textBrowser">
          <property name="openExternalLinks">
           <bool>true</bool>
          </property>
         </widget>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
  </layout>
  <action name="actionDelete">
   <property name="text">
    <string>Delete</string>
   </property>
   <property name="toolTip">
    <string>Delete</string>
   </property>
  </action>
  <action name="actionRename">
   <property name="text">
    <string>Rename...</string>
   </property>
   <property name="toolTip">
    <string>Rename</string>
   </property>
  </action>
  <action name="actionUpdate">
   <property name="text">
    <string>Update</string>
   </property>
   <property name="toolTip">
    <string>Update</string>
   </property>
  </action>
  <action name="actionNewSubscription">
   <property name="text">
    <string>New subscription...</string>
   </property>
  </action>
  <action name="actionUpdateAllFeeds">
   <property name="text">
    <string>Update all feeds</string>
   </property>
   <property name="toolTip">
    <string>Update all feeds</string>
   </property>
  </action>
  <action name="actionMarkItemsRead">
   <property name="text">
    <string>Mark items read</string>
   </property>
   <property name="toolTip">
    <string>Mark items read</string>
   </property>
  </action>
  <action name="actionDownloadTorrent">
   <property name="text">
    <string>Download torrent</string>
   </property>
  </action>
  <action name="actionOpenNewsURL">
   <property name="text">
    <string>Open news URL</string>
   </property>
  </action>
  <action name="actionCopyFeedURL">
   <property name="text">
    <string>Copy feed URL</string>
   </property>
  </action>
  <action name="actionNewFolder">
   <property name="text">
    <string>New folder...</string>
   </property>
  </action>
  <action name="actionEditFeed">
   <property name="text">
    <string>Feed options...</string>
   </property>
  </action>
 </widget>
 <customwidgets>
  <customwidget>
   <class>HtmlBrowser</class>
   <extends>QTextBrowser</extends>
   <header>gui/rss/htmlbrowser.h</header>
  </customwidget>
  <customwidget>
   <class>FeedListWidget</class>
   <extends>QTreeWidget</extends>
   <header>gui/rss/feedlistwidget.h</header>
  </customwidget>
  <customwidget>
   <class>ArticleListWidget</class>
   <extends>QListWidget</extends>
   <header>gui/rss/articlelistwidget.h</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>
</file>

<file path="gui/search/pluginselectdialog.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "pluginselectdialog.h"

#include <QClipboard>
#include <QDropEvent>
#include <QFileDialog>
#include <QHeaderView>
#include <QImageReader>
#include <QMenu>
#include <QMessageBox>
#include <QMimeData>

#include "base/global.h"
#include "base/net/downloadmanager.h"
#include "base/preferences.h"
#include "base/utils/fs.h"
#include "gui/autoexpandabledialog.h"
#include "gui/uithememanager.h"
#include "gui/utils.h"
#include "pluginsourcedialog.h"
#include "searchwidget.h"
#include "ui_pluginselectdialog.h"

#define SETTINGS_KEY(name) u"SearchPluginSelectDialog/" name

enum PluginColumns
{
    PLUGIN_NAME,
    PLUGIN_VERSION,
    PLUGIN_URL,
    PLUGIN_STATE,
    PLUGIN_ID
};

PluginSelectDialog::PluginSelectDialog(SearchPluginManager *pluginManager, QWidget *parent)
    : QDialog(parent)
    , m_ui(new Ui::PluginSelectDialog)
    , m_storeDialogSize(SETTINGS_KEY(u"Size"_s))
    , m_pluginManager(pluginManager)
{
    m_ui->setupUi(this);

    m_ui->pluginsTree->setRootIsDecorated(false);
    m_ui->pluginsTree->hideColumn(PLUGIN_ID);
    m_ui->pluginsTree->header()->setFirstSectionMovable(true);
    m_ui->pluginsTree->header()->setSortIndicator(0, Qt::AscendingOrder);

    m_ui->actionUninstall->setIcon(UIThemeManager::instance()->getIcon(u"list-remove"_s));

    connect(m_ui->actionEnable, &QAction::toggled, this, &PluginSelectDialog::enableSelection);
    connect(m_ui->pluginsTree, &QTreeWidget::customContextMenuRequested, this, &PluginSelectDialog::displayContextMenu);
    connect(m_ui->pluginsTree, &QTreeWidget::itemDoubleClicked, this, &PluginSelectDialog::togglePluginState);

    loadSupportedSearchPlugins();

    connect(m_pluginManager, &SearchPluginManager::pluginInstalled, this, &PluginSelectDialog::pluginInstalled);
    connect(m_pluginManager, &SearchPluginManager::pluginInstallationFailed, this, &PluginSelectDialog::pluginInstallationFailed);
    connect(m_pluginManager, &SearchPluginManager::pluginUpdated, this, &PluginSelectDialog::pluginUpdated);
    connect(m_pluginManager, &SearchPluginManager::pluginUpdateFailed, this, &PluginSelectDialog::pluginUpdateFailed);
    connect(m_pluginManager, &SearchPluginManager::checkForUpdatesFinished, this, &PluginSelectDialog::checkForUpdatesFinished);
    connect(m_pluginManager, &SearchPluginManager::checkForUpdatesFailed, this, &PluginSelectDialog::checkForUpdatesFailed);

    if (const QSize dialogSize = m_storeDialogSize; dialogSize.isValid())
        resize(dialogSize);
}

PluginSelectDialog::~PluginSelectDialog()
{
    m_storeDialogSize = size();
    delete m_ui;
}

void PluginSelectDialog::dropEvent(QDropEvent *event)
{
    event->acceptProposedAction();

    QStringList files;
    if (event->mimeData()->hasUrls())
    {
        for (const QUrl &url : asConst(event->mimeData()->urls()))
        {
            if (!url.isEmpty())
            {
                if (url.scheme().compare(u"file", Qt::CaseInsensitive) == 0)
                    files << url.toLocalFile();
                else
                    files << url.toString();
            }
        }
    }
    else
    {
        files = event->mimeData()->text().split(u'\n');
    }

    if (files.isEmpty()) return;

    for (const QString &file : asConst(files))
    {
        qDebug("dropped %s", qUtf8Printable(file));
        startAsyncOp();
        m_pluginManager->installPlugin(file);
    }
}

// Decode if we accept drag 'n drop or not
void PluginSelectDialog::dragEnterEvent(QDragEnterEvent *event)
{
    for (const QString &mime : asConst(event->mimeData()->formats()))
    {
        qDebug("mimeData: %s", qUtf8Printable(mime));
    }

    if (event->mimeData()->hasFormat(u"text/plain"_s) || event->mimeData()->hasFormat(u"text/uri-list"_s))
    {
        event->acceptProposedAction();
    }
}

void PluginSelectDialog::on_updateButton_clicked()
{
    startAsyncOp();
    m_pluginManager->checkForUpdates();
}

void PluginSelectDialog::togglePluginState(QTreeWidgetItem *item, int)
{
    PluginInfo *plugin = m_pluginManager->pluginInfo(item->text(PLUGIN_ID));
    m_pluginManager->enablePlugin(plugin->name, !plugin->enabled);
    if (plugin->enabled)
    {
        item->setText(PLUGIN_STATE, tr("Yes"));
        setRowColor(m_ui->pluginsTree->indexOfTopLevelItem(item), u"green"_s);
    }
    else
    {
        item->setText(PLUGIN_STATE, tr("No"));
        setRowColor(m_ui->pluginsTree->indexOfTopLevelItem(item), u"red"_s);
    }
}

void PluginSelectDialog::displayContextMenu()
{
    const QList<QTreeWidgetItem *> items = m_ui->pluginsTree->selectedItems();
    if (items.isEmpty())
        return;

    QMenu *myContextMenu = new QMenu(this);
    myContextMenu->setAttribute(Qt::WA_DeleteOnClose);

    const QString firstID = items.first()->text(PLUGIN_ID);
    m_ui->actionEnable->setChecked(m_pluginManager->pluginInfo(firstID)->enabled);
    myContextMenu->addAction(m_ui->actionEnable);
    myContextMenu->addSeparator();
    myContextMenu->addAction(m_ui->actionUninstall);

    myContextMenu->popup(QCursor::pos());
}

void PluginSelectDialog::on_closeButton_clicked()
{
    close();
}

void PluginSelectDialog::on_actionUninstall_triggered()
{
    bool error = false;
    for (QTreeWidgetItem *item : asConst(m_ui->pluginsTree->selectedItems()))
    {
        int index = m_ui->pluginsTree->indexOfTopLevelItem(item);
        Q_ASSERT(index != -1);
        QString id = item->text(PLUGIN_ID);
        if (m_pluginManager->uninstallPlugin(id))
        {
            delete item;
        }
        else
        {
            error = true;
            // Disable it instead
            m_pluginManager->enablePlugin(id, false);
            item->setText(PLUGIN_STATE, tr("No"));
            setRowColor(index, u"red"_s);
        }
    }

    if (error)
        QMessageBox::warning(this, tr("Uninstall warning"), tr("Some plugins could not be uninstalled because they are included in qBittorrent. Only the ones you added yourself can be uninstalled.\nThose plugins were disabled."));
    else
        QMessageBox::information(this, tr("Uninstall success"), tr("All selected plugins were uninstalled successfully"));
}

void PluginSelectDialog::enableSelection(bool enable)
{
    for (QTreeWidgetItem *item : asConst(m_ui->pluginsTree->selectedItems()))
    {
        int index = m_ui->pluginsTree->indexOfTopLevelItem(item);
        Q_ASSERT(index != -1);
        QString id = item->text(PLUGIN_ID);
        m_pluginManager->enablePlugin(id, enable);
        if (enable)
        {
            item->setText(PLUGIN_STATE, tr("Yes"));
            setRowColor(index, u"green"_s);
        }
        else
        {
            item->setText(PLUGIN_STATE, tr("No"));
            setRowColor(index, u"red"_s);
        }
    }
}

// Set the color of a row in data model
void PluginSelectDialog::setRowColor(const int row, const QString &color)
{
    QTreeWidgetItem *item = m_ui->pluginsTree->topLevelItem(row);
    for (int i = 0; i < m_ui->pluginsTree->columnCount(); ++i)
    {
        item->setData(i, Qt::ForegroundRole, QColor(color));
    }
}

QList<QTreeWidgetItem*> PluginSelectDialog::findItemsWithUrl(const QString &url)
{
    QList<QTreeWidgetItem*> res;
    res.reserve(m_ui->pluginsTree->topLevelItemCount());

    for (int i = 0; i < m_ui->pluginsTree->topLevelItemCount(); ++i)
    {
        QTreeWidgetItem *item = m_ui->pluginsTree->topLevelItem(i);
        if (url.startsWith(item->text(PLUGIN_URL), Qt::CaseInsensitive))
            res << item;
    }

    return res;
}

QTreeWidgetItem *PluginSelectDialog::findItemWithID(const QString &id)
{
    for (int i = 0; i < m_ui->pluginsTree->topLevelItemCount(); ++i)
    {
        QTreeWidgetItem *item = m_ui->pluginsTree->topLevelItem(i);
        if (id == item->text(PLUGIN_ID))
            return item;
    }

    return nullptr;
}

void PluginSelectDialog::loadSupportedSearchPlugins()
{
    // Some clean up first
    m_ui->pluginsTree->clear();
    for (const QString &name : asConst(m_pluginManager->allPlugins()))
        addNewPlugin(name);
}

void PluginSelectDialog::addNewPlugin(const QString &pluginName)
{
    auto *item = new QTreeWidgetItem(m_ui->pluginsTree);
    PluginInfo *plugin = m_pluginManager->pluginInfo(pluginName);
    item->setText(PLUGIN_NAME, plugin->fullName);
    item->setText(PLUGIN_URL, plugin->url);
    item->setText(PLUGIN_ID, plugin->name);
    if (plugin->enabled)
    {
        item->setText(PLUGIN_STATE, tr("Yes"));
        setRowColor(m_ui->pluginsTree->indexOfTopLevelItem(item), u"green"_s);
    }
    else
    {
        item->setText(PLUGIN_STATE, tr("No"));
        setRowColor(m_ui->pluginsTree->indexOfTopLevelItem(item), u"red"_s);
    }
    // Handle icon
    if (plugin->iconPath.exists())
    {
        // Good, we already have the icon
        item->setData(PLUGIN_NAME, Qt::DecorationRole, QIcon(plugin->iconPath.data()));
    }
    else
    {
        // Icon is missing, we must download it
        using namespace Net;
        DownloadManager::instance()->download(
                DownloadRequest(plugin->url + u"/favicon.ico").saveToFile(true)
                , Preferences::instance()->useProxyForGeneralPurposes(), this, &PluginSelectDialog::iconDownloadFinished);
    }
    item->setText(PLUGIN_VERSION, plugin->version.toString());
}

void PluginSelectDialog::startAsyncOp()
{
    ++m_asyncOps;
    if (m_asyncOps == 1)
        setCursor(QCursor(Qt::WaitCursor));
}

void PluginSelectDialog::finishAsyncOp()
{
    --m_asyncOps;
    if (m_asyncOps == 0)
        setCursor(QCursor(Qt::ArrowCursor));
}

void PluginSelectDialog::finishPluginUpdate()
{
    --m_pendingUpdates;
    if ((m_pendingUpdates == 0) && !m_updatedPlugins.isEmpty())
    {
        m_updatedPlugins.sort(Qt::CaseInsensitive);
        QMessageBox::information(this, tr("Search plugin update"), tr("Plugins installed or updated: %1").arg(m_updatedPlugins.join(u", ")));
        m_updatedPlugins.clear();
    }
}

void PluginSelectDialog::on_installButton_clicked()
{
    auto *dlg = new PluginSourceDialog(this);
    dlg->setAttribute(Qt::WA_DeleteOnClose);
    connect(dlg, &PluginSourceDialog::askForLocalFile, this, &PluginSelectDialog::askForLocalPlugin);
    connect(dlg, &PluginSourceDialog::askForUrl, this, &PluginSelectDialog::askForPluginUrl);
    dlg->show();
}

void PluginSelectDialog::askForPluginUrl()
{
    bool ok = false;
    QString clipTxt = qApp->clipboard()->text();
    auto defaultUrl = u"http://"_s;
    if (Net::DownloadManager::hasSupportedScheme(clipTxt) && clipTxt.endsWith(u".py"))
      defaultUrl = clipTxt;
    QString url = AutoExpandableDialog::getText(
                this, tr("New search engine plugin URL"),
                tr("URL:"), QLineEdit::Normal, defaultUrl, &ok
                );

    while (ok && !url.isEmpty() && !url.endsWith(u".py"))
    {
        QMessageBox::warning(this, tr("Invalid link"), tr("The link doesn't seem to point to a search engine plugin."));
        url = AutoExpandableDialog::getText(
                    this, tr("New search engine plugin URL"),
                    tr("URL:"), QLineEdit::Normal, url, &ok
                    );
    }

    if (ok && !url.isEmpty())
    {
        startAsyncOp();
        m_pluginManager->installPlugin(url);
    }
}

void PluginSelectDialog::askForLocalPlugin()
{
    const QStringList pathsList = QFileDialog::getOpenFileNames(
                nullptr, tr("Select search plugins"), QDir::homePath(),
                (tr("qBittorrent search plugin") + u" (*.py)"));
    for (const QString &path : pathsList)
    {
        startAsyncOp();
        m_pluginManager->installPlugin(path);
    }
}

void PluginSelectDialog::iconDownloadFinished(const Net::DownloadResult &result)
{
    if (result.status != Net::DownloadStatus::Success)
    {
        qDebug("Could not download favicon: %s, reason: %s", qUtf8Printable(result.url), qUtf8Printable(result.errorString));
        return;
    }

    const Path filePath = result.filePath;

    // Icon downloaded
    QIcon icon {filePath.data()};
    // Detect a non-decodable icon
    QList<QSize> sizes = icon.availableSizes();
    bool invalid = (sizes.isEmpty() || icon.pixmap(sizes.first()).isNull());
    if (!invalid)
    {
        for (QTreeWidgetItem *item : asConst(findItemsWithUrl(result.url)))
        {
            QString id = item->text(PLUGIN_ID);
            PluginInfo *plugin = m_pluginManager->pluginInfo(id);
            if (!plugin) continue;

            const QString ext = result.url.endsWith(u".ico", Qt::CaseInsensitive) ? u".ico"_s : u".png"_s;
            const Path iconPath = SearchPluginManager::pluginsLocation() / Path(id + ext);
            if (Utils::Fs::copyFile(filePath, iconPath))
            {
                // This 2nd check is necessary. Some favicons (eg from piratebay)
                // decode fine without an ext, but fail to do so when appending the ext
                // from the url. Probably a Qt bug.
                QIcon iconWithExt {iconPath.data()};
                QList<QSize> sizesExt = iconWithExt.availableSizes();
                bool invalidExt = (sizesExt.isEmpty() || iconWithExt.pixmap(sizesExt.first()).isNull());
                if (invalidExt)
                {
                    Utils::Fs::removeFile(iconPath);
                    continue;
                }

                item->setData(PLUGIN_NAME, Qt::DecorationRole, iconWithExt);
                m_pluginManager->updateIconPath(plugin);
            }
        }
    }
    // Delete tmp file
    Utils::Fs::removeFile(filePath);
}

void PluginSelectDialog::checkForUpdatesFinished(const QHash<QString, PluginVersion> &updateInfo)
{
    finishAsyncOp();
    if (updateInfo.isEmpty())
    {
        QMessageBox::information(this, tr("Search plugin update"), tr("All your plugins are already up to date."));
        return;
    }

    for (auto i = updateInfo.cbegin(); i != updateInfo.cend(); ++i)
    {
        startAsyncOp();
        ++m_pendingUpdates;
        m_pluginManager->updatePlugin(i.key());
    }
}

void PluginSelectDialog::checkForUpdatesFailed(const QString &reason)
{
    finishAsyncOp();
    QMessageBox::warning(this, tr("Search plugin update"), tr("Sorry, couldn't check for plugin updates. %1").arg(reason));
}

void PluginSelectDialog::pluginInstalled(const QString &name)
{
    addNewPlugin(name);
    finishAsyncOp();
    m_updatedPlugins.append(name);
    finishPluginUpdate();
}

void PluginSelectDialog::pluginInstallationFailed(const QString &name, const QString &reason)
{
    finishAsyncOp();
    QMessageBox::information(this, tr("Search plugin install")
        , tr("Couldn't install \"%1\" search engine plugin. %2").arg(name, reason));
    finishPluginUpdate();
}

void PluginSelectDialog::pluginUpdated(const QString &name)
{
    finishAsyncOp();
    PluginVersion version = m_pluginManager->pluginInfo(name)->version;
    QTreeWidgetItem *item = findItemWithID(name);
    item->setText(PLUGIN_VERSION, version.toString());
    m_updatedPlugins.append(name);
    finishPluginUpdate();
}

void PluginSelectDialog::pluginUpdateFailed(const QString &name, const QString &reason)
{
    finishAsyncOp();
    QMessageBox::information(this, tr("Search plugin update")
        , tr("Couldn't update \"%1\" search engine plugin. %2").arg(name, reason));
    finishPluginUpdate();
}
</file>

<file path="gui/search/pluginselectdialog.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QDialog>
#include <QStringList>

#include "base/search/searchpluginmanager.h"
#include "base/settingvalue.h"

class QDropEvent;
class QTreeWidgetItem;

namespace Net
{
    struct DownloadResult;
}

namespace Ui
{
    class PluginSelectDialog;
}

class PluginSelectDialog final : public QDialog
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(PluginSelectDialog)

public:
    explicit PluginSelectDialog(SearchPluginManager *pluginManager, QWidget *parent = nullptr);
    ~PluginSelectDialog() override;

    QList<QTreeWidgetItem*> findItemsWithUrl(const QString &url);
    QTreeWidgetItem *findItemWithID(const QString &id);

protected:
    void dropEvent(QDropEvent *event) override;
    void dragEnterEvent(QDragEnterEvent *event) override;

private slots:
    void on_actionUninstall_triggered();
    void on_updateButton_clicked();
    void on_installButton_clicked();
    void on_closeButton_clicked();
    void togglePluginState(QTreeWidgetItem*, int);
    void setRowColor(int row, const QString &color);
    void displayContextMenu();
    void enableSelection(bool enable);
    void askForLocalPlugin();
    void askForPluginUrl();
    void iconDownloadFinished(const Net::DownloadResult &result);

    void checkForUpdatesFinished(const QHash<QString, PluginVersion> &updateInfo);
    void checkForUpdatesFailed(const QString &reason);
    void pluginInstalled(const QString &name);
    void pluginInstallationFailed(const QString &name, const QString &reason);
    void pluginUpdated(const QString &name);
    void pluginUpdateFailed(const QString &name, const QString &reason);

private:
    void loadSupportedSearchPlugins();
    void addNewPlugin(const QString &pluginName);
    void startAsyncOp();
    void finishAsyncOp();
    void finishPluginUpdate();

    Ui::PluginSelectDialog *m_ui = nullptr;
    SettingValue<QSize> m_storeDialogSize;
    SearchPluginManager *m_pluginManager = nullptr;
    QStringList m_updatedPlugins;
    int m_asyncOps = 0;
    int m_pendingUpdates = 0;
};
</file>

<file path="gui/search/pluginselectdialog.ui">
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>PluginSelectDialog</class>
 <widget class="QDialog" name="PluginSelectDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>600</width>
    <height>345</height>
   </rect>
  </property>
  <property name="acceptDrops">
   <bool>true</bool>
  </property>
  <property name="windowTitle">
   <string>Search plugins</string>
  </property>
  <layout class="QVBoxLayout" name="pluginSelectLayout">
   <item>
    <widget class="QLabel" name="lbl_plugins">
     <property name="font">
      <font>
       <bold>true</bold>
       <underline>true</underline>
      </font>
     </property>
     <property name="text">
      <string>Installed search plugins:</string>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QTreeWidget" name="pluginsTree">
     <property name="contextMenuPolicy">
      <enum>Qt::ContextMenuPolicy::CustomContextMenu</enum>
     </property>
     <property name="selectionMode">
      <enum>QAbstractItemView::SelectionMode::ExtendedSelection</enum>
     </property>
     <property name="uniformRowHeights">
      <bool>true</bool>
     </property>
     <property name="itemsExpandable">
      <bool>false</bool>
     </property>
     <property name="sortingEnabled">
      <bool>true</bool>
     </property>
     <column>
      <property name="text">
       <string>Name</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Version</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Url</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string>Enabled</string>
      </property>
     </column>
     <column>
      <property name="text">
       <string/>
      </property>
     </column>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="label">
     <property name="text">
      <string>Warning: Be sure to comply with your country's copyright laws when downloading torrents from any of these search engines.</string>
     </property>
     <property name="wordWrap">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <widget class="QLabel" name="getNewPlugin_lbl">
     <property name="font">
      <font>
       <italic>true</italic>
      </font>
     </property>
     <property name="text">
      <string>You can get new search engine plugins here: &lt;a href=&quot;https://plugins.qbittorrent.org&quot;&gt;https://plugins.qbittorrent.org&lt;/a&gt;</string>
     </property>
     <property name="openExternalLinks">
      <bool>true</bool>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="layout1">
     <item>
      <widget class="QPushButton" name="installButton">
       <property name="text">
        <string>Install a new one</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="updateButton">
       <property name="text">
        <string>Check for updates</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="closeButton">
       <property name="text">
        <string>Close</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
  <action name="actionEnable">
   <property name="checkable">
    <bool>true</bool>
   </property>
   <property name="text">
    <string>Enabled</string>
   </property>
  </action>
  <action name="actionUninstall">
   <property name="text">
    <string>Uninstall</string>
   </property>
  </action>
 </widget>
 <resources/>
 <connections/>
</ui>
</file>

<file path="gui/search/pluginsourcedialog.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "pluginsourcedialog.h"

#include "gui/utils.h"
#include "ui_pluginsourcedialog.h"

#define SETTINGS_KEY(name) u"SearchPluginSourceDialog/" name

PluginSourceDialog::PluginSourceDialog(QWidget *parent)
    : QDialog(parent)
    , m_ui(new Ui::PluginSourceDialog)
    , m_storeDialogSize(SETTINGS_KEY(u"Size"_s))
{
    m_ui->setupUi(this);

    if (const QSize dialogSize = m_storeDialogSize; dialogSize.isValid())
        resize(dialogSize);
}

PluginSourceDialog::~PluginSourceDialog()
{
    m_storeDialogSize = size();
    delete m_ui;
}

void PluginSourceDialog::on_localButton_clicked()
{
    emit askForLocalFile();
    close();
}

void PluginSourceDialog::on_urlButton_clicked()
{
    emit askForUrl();
    close();
}
</file>

<file path="gui/search/pluginsourcedialog.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QDialog>

#include "base/settingvalue.h"

namespace Ui
{
    class PluginSourceDialog;
}

class PluginSourceDialog final : public QDialog
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(PluginSourceDialog)

public:
    explicit PluginSourceDialog(QWidget *parent = nullptr);
    ~PluginSourceDialog() override;

signals:
    void askForUrl();
    void askForLocalFile();

private slots:
    void on_localButton_clicked();
    void on_urlButton_clicked();

private:
    Ui::PluginSourceDialog *m_ui = nullptr;
    SettingValue<QSize> m_storeDialogSize;
};
</file>

<file path="gui/search/pluginsourcedialog.ui">
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>PluginSourceDialog</class>
 <widget class="QDialog" name="PluginSourceDialog">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>207</width>
    <height>76</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Plugin source</string>
  </property>
  <layout class="QVBoxLayout" name="pluginSourceLayout">
   <item>
    <widget class="QLabel" name="source_lbl">
     <property name="font">
      <font>
       <bold>true</bold>
       <underline>true</underline>
      </font>
     </property>
     <property name="text">
      <string>Search plugin source:</string>
     </property>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="layout1">
     <item>
      <widget class="QPushButton" name="localButton">
       <property name="text">
        <string>Local file</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="urlButton">
       <property name="text">
        <string>Web link</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
</file>

<file path="gui/search/searchjobwidget.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2018-2025  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "searchjobwidget.h"

#include <QApplication>
#include <QClipboard>
#include <QDesktopServices>
#include <QHeaderView>
#include <QKeyEvent>
#include <QMenu>
#include <QPalette>
#include <QStandardItemModel>
#include <QUrl>

#include "base/preferences.h"
#include "base/search/searchdownloadhandler.h"
#include "base/search/searchhandler.h"
#include "base/search/searchpluginmanager.h"
#include "base/utils/misc.h"
#include "gui/interfaces/iguiapplication.h"
#include "gui/lineedit.h"
#include "gui/uithememanager.h"
#include "searchsortmodel.h"
#include "ui_searchjobwidget.h"

namespace
{
    enum DataRole
    {
        LinkVisitedRole = Qt::UserRole + 100
    };

    QColor visitedRowColor()
    {
        return QApplication::palette().color(QPalette::Disabled, QPalette::WindowText);
    }

    QString statusText(SearchJobWidget::Status st)
    {
        switch (st)
        {
        case SearchJobWidget::Status::Ongoing:
            return SearchJobWidget::tr("Searching...");
        case SearchJobWidget::Status::Finished:
            return SearchJobWidget::tr("Search has finished");
        case SearchJobWidget::Status::Aborted:
            return SearchJobWidget::tr("Search aborted");
        case SearchJobWidget::Status::Error:
            return SearchJobWidget::tr("An error occurred during search...");
        case SearchJobWidget::Status::NoResults:
            return SearchJobWidget::tr("Search returned no results");
        default:
            return {};
        }
    }
}

SearchJobWidget::SearchJobWidget(const QString &id, IGUIApplication *app, QWidget *parent)
    : GUIApplicationComponent(app, parent)
    , m_nameFilteringMode {u"Search/FilteringMode"_s}
    , m_id {id}
    , m_ui {new Ui::SearchJobWidget}
{
    m_ui->setupUi(this);

    loadSettings();

    header()->setFirstSectionMovable(true);
    header()->setStretchLastSection(false);
    header()->setTextElideMode(Qt::ElideRight);

    // Set Search results list model
    m_searchListModel = new QStandardItemModel(0, SearchSortModel::NB_SEARCH_COLUMNS, this);
    m_searchListModel->setHeaderData(SearchSortModel::NAME, Qt::Horizontal, tr("Name", "i.e: file name"));
    m_searchListModel->setHeaderData(SearchSortModel::SIZE, Qt::Horizontal, tr("Size", "i.e: file size"));
    m_searchListModel->setHeaderData(SearchSortModel::SEEDS, Qt::Horizontal, tr("Seeders", "i.e: Number of full sources"));
    m_searchListModel->setHeaderData(SearchSortModel::LEECHES, Qt::Horizontal, tr("Leechers", "i.e: Number of partial sources"));
    m_searchListModel->setHeaderData(SearchSortModel::ENGINE_NAME, Qt::Horizontal, tr("Engine"));
    m_searchListModel->setHeaderData(SearchSortModel::ENGINE_URL, Qt::Horizontal, tr("Engine URL"));
    m_searchListModel->setHeaderData(SearchSortModel::PUB_DATE, Qt::Horizontal, tr("Published On"));
    // Set columns text alignment
    m_searchListModel->setHeaderData(SearchSortModel::SIZE, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);
    m_searchListModel->setHeaderData(SearchSortModel::SEEDS, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);
    m_searchListModel->setHeaderData(SearchSortModel::LEECHES, Qt::Horizontal, QVariant(Qt::AlignRight | Qt::AlignVCenter), Qt::TextAlignmentRole);

    m_proxyModel = new SearchSortModel(this);
    m_proxyModel->setDynamicSortFilter(true);
    m_proxyModel->setSourceModel(m_searchListModel);
    m_ui->resultsBrowser->setModel(m_proxyModel);

    m_ui->resultsBrowser->hideColumn(SearchSortModel::DL_LINK); // Hide url column
    m_ui->resultsBrowser->hideColumn(SearchSortModel::DESC_LINK);

    m_ui->resultsBrowser->setSelectionMode(QAbstractItemView::ExtendedSelection);
    m_ui->resultsBrowser->setRootIsDecorated(false);
    m_ui->resultsBrowser->setAllColumnsShowFocus(true);
    m_ui->resultsBrowser->setSortingEnabled(true);
    m_ui->resultsBrowser->setEditTriggers(QAbstractItemView::NoEditTriggers);

    // Ensure that at least one column is visible at all times
    bool atLeastOne = false;
    for (int i = 0; i < SearchSortModel::DL_LINK; ++i)
    {
        if (!m_ui->resultsBrowser->isColumnHidden(i))
        {
            atLeastOne = true;
            break;
        }
    }
    if (!atLeastOne)
        m_ui->resultsBrowser->setColumnHidden(SearchSortModel::NAME, false);
    // To also mitigate the above issue, we have to resize each column when
    // its size is 0, because explicitly 'showing' the column isn't enough
    // in the above scenario.
    for (int i = 0; i < SearchSortModel::DL_LINK; ++i)
    {
        if ((m_ui->resultsBrowser->columnWidth(i) <= 0) && !m_ui->resultsBrowser->isColumnHidden(i))
            m_ui->resultsBrowser->resizeColumnToContents(i);
    }

    header()->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(header(), &QWidget::customContextMenuRequested, this, &SearchJobWidget::displayColumnHeaderMenu);
    connect(header(), &QHeaderView::sectionResized, this, &SearchJobWidget::saveSettings);
    connect(header(), &QHeaderView::sectionMoved, this, &SearchJobWidget::saveSettings);
    connect(header(), &QHeaderView::sortIndicatorChanged, this, &SearchJobWidget::saveSettings);

    fillFilterComboBoxes();

    m_lineEditSearchResultsFilter = new LineEdit(this);
    m_lineEditSearchResultsFilter->setPlaceholderText(tr("Filter search results..."));
    m_lineEditSearchResultsFilter->setContextMenuPolicy(Qt::CustomContextMenu);
    connect(m_lineEditSearchResultsFilter, &QWidget::customContextMenuRequested, this, &SearchJobWidget::showFilterContextMenu);
    connect(m_lineEditSearchResultsFilter, &LineEdit::textChanged, this, &SearchJobWidget::filterSearchResults);
    m_ui->horizontalLayout->insertWidget(0, m_lineEditSearchResultsFilter);

    connect(m_ui->filterMode, qOverload<int>(&QComboBox::currentIndexChanged)
            , this, &SearchJobWidget::updateFilter);
    connect(m_ui->minSeeds, &QAbstractSpinBox::editingFinished, this, &SearchJobWidget::updateFilter);
    connect(m_ui->minSeeds, qOverload<int>(&QSpinBox::valueChanged)
            , this, &SearchJobWidget::updateFilter);
    connect(m_ui->maxSeeds, &QAbstractSpinBox::editingFinished, this, &SearchJobWidget::updateFilter);
    connect(m_ui->maxSeeds, qOverload<int>(&QSpinBox::valueChanged)
            , this, &SearchJobWidget::updateFilter);
    connect(m_ui->minSize, &QAbstractSpinBox::editingFinished, this, &SearchJobWidget::updateFilter);
    connect(m_ui->minSize, qOverload<double>(&QDoubleSpinBox::valueChanged)
            , this, &SearchJobWidget::updateFilter);
    connect(m_ui->maxSize, &QAbstractSpinBox::editingFinished, this, &SearchJobWidget::updateFilter);
    connect(m_ui->maxSize, qOverload<double>(&QDoubleSpinBox::valueChanged)
            , this, &SearchJobWidget::updateFilter);
    connect(m_ui->minSizeUnit, qOverload<int>(&QComboBox::currentIndexChanged)
            , this, &SearchJobWidget::updateFilter);
    connect(m_ui->maxSizeUnit, qOverload<int>(&QComboBox::currentIndexChanged)
            , this, &SearchJobWidget::updateFilter);

    connect(m_ui->resultsBrowser, &QAbstractItemView::doubleClicked, this, &SearchJobWidget::onItemDoubleClicked);

    connect(UIThemeManager::instance(), &UIThemeManager::themeChanged, this, &SearchJobWidget::onUIThemeChanged);
}

SearchJobWidget::SearchJobWidget(const QString &id, const QString &searchPattern
        , const QList<SearchResult> &searchResults, IGUIApplication *app, QWidget *parent)
    : SearchJobWidget(id, app, parent)
{
    m_searchPattern = searchPattern;
    m_proxyModel->setNameFilter(m_searchPattern);
    updateFilter();

    appendSearchResults(searchResults);
}

SearchJobWidget::SearchJobWidget(const QString &id, SearchHandler *searchHandler, IGUIApplication *app, QWidget *parent)
    : SearchJobWidget(id, app, parent)
{
    assignSearchHandler(searchHandler);
}

SearchJobWidget::~SearchJobWidget()
{
    saveSettings();
    delete m_ui;
}

QString SearchJobWidget::id() const
{
    return m_id;
}

QString SearchJobWidget::searchPattern() const
{
    return m_searchPattern;
}

QList<SearchResult> SearchJobWidget::searchResults() const
{
    return m_searchResults;
}

void SearchJobWidget::onItemDoubleClicked(const QModelIndex &index)
{
    downloadTorrent(index);
}

QHeaderView *SearchJobWidget::header() const
{
    return m_ui->resultsBrowser->header();
}

// Set the color of a row in data model
void SearchJobWidget::setRowColor(int row, const QColor &color)
{
    for (int i = 0; i < m_proxyModel->columnCount(); ++i)
        m_proxyModel->setData(m_proxyModel->index(row, i), color, Qt::ForegroundRole);
}

void SearchJobWidget::setRowVisited(const int row)
{
    m_proxyModel->setDynamicSortFilter(false);

    m_proxyModel->setData(m_proxyModel->index(row, 0), true, LinkVisitedRole);
    setRowColor(row, visitedRowColor());

    m_proxyModel->setDynamicSortFilter(true);
}

void SearchJobWidget::onUIThemeChanged()
{
    m_proxyModel->setDynamicSortFilter(false);

    for (int row = 0; row < m_proxyModel->rowCount(); ++row)
    {
        const QVariant userData = m_proxyModel->data(m_proxyModel->index(row, 0), LinkVisitedRole);
        const bool isVisited = userData.toBool();
        if (isVisited)
            setRowColor(row, visitedRowColor());
    }

    m_proxyModel->setDynamicSortFilter(true);
}

SearchJobWidget::Status SearchJobWidget::status() const
{
    return m_status;
}

int SearchJobWidget::visibleResultsCount() const
{
    return m_proxyModel->rowCount();
}

LineEdit *SearchJobWidget::lineEditSearchResultsFilter() const
{
    return m_lineEditSearchResultsFilter;
}

void SearchJobWidget::assignSearchHandler(SearchHandler *searchHandler)
{
    Q_ASSERT(searchHandler);
    if (!searchHandler) [[unlikely]]
        return;

    m_searchResults.clear();
    m_searchListModel->removeRows(0, m_searchListModel->rowCount());
    delete m_searchHandler;

    m_searchHandler = searchHandler;
    m_searchHandler->setParent(this);
    connect(m_searchHandler, &SearchHandler::newSearchResults, this, &SearchJobWidget::appendSearchResults);
    connect(m_searchHandler, &SearchHandler::searchFinished, this, &SearchJobWidget::searchFinished);
    connect(m_searchHandler, &SearchHandler::searchFailed, this, &SearchJobWidget::searchFailed);

    m_searchPattern = m_searchHandler->pattern();

    m_proxyModel->setNameFilter(m_searchPattern);
    updateFilter();

    setStatus(Status::Ongoing);
}

void SearchJobWidget::cancelSearch()
{
    if (!m_searchHandler)
        return;

    m_searchHandler->cancelSearch();
    setStatus(Status::Aborted);
}

void SearchJobWidget::downloadTorrents(const AddTorrentOption option)
{
    const QModelIndexList rows = m_ui->resultsBrowser->selectionModel()->selectedRows();
    for (const QModelIndex &rowIndex : rows)
        downloadTorrent(rowIndex, option);
}

void SearchJobWidget::openTorrentPages() const
{
    const QModelIndexList rows {m_ui->resultsBrowser->selectionModel()->selectedRows()};
    for (const QModelIndex &rowIndex : rows)
    {
        const QString descrLink = m_proxyModel->data(
                    m_proxyModel->index(rowIndex.row(), SearchSortModel::DESC_LINK)).toString();
        if (!descrLink.isEmpty())
            QDesktopServices::openUrl(QUrl::fromEncoded(descrLink.toUtf8()));
    }
}

void SearchJobWidget::copyTorrentURLs() const
{
    copyField(SearchSortModel::DESC_LINK);
}

void SearchJobWidget::copyTorrentDownloadLinks() const
{
    copyField(SearchSortModel::DL_LINK);
}

void SearchJobWidget::copyTorrentNames() const
{
    copyField(SearchSortModel::NAME);
}

void SearchJobWidget::copyField(const int column) const
{
    const QModelIndexList rows {m_ui->resultsBrowser->selectionModel()->selectedRows()};
    QStringList list;

    for (const QModelIndex &rowIndex : rows)
    {
        const QString field = m_proxyModel->data(
            m_proxyModel->index(rowIndex.row(), column)).toString();
        if (!field.isEmpty())
            list << field;
    }

    if (!list.empty())
        QApplication::clipboard()->setText(list.join(u'\n'));
}

void SearchJobWidget::setStatus(Status value)
{
    if (m_status == value)
        return;

    m_status = value;
    setStatusTip(statusText(value));
    emit statusChanged();
}

void SearchJobWidget::downloadTorrent(const QModelIndex &rowIndex, const AddTorrentOption option)
{
    const QString torrentUrl = m_proxyModel->data(
                m_proxyModel->index(rowIndex.row(), SearchSortModel::DL_LINK)).toString();
    const QString engineName = m_proxyModel->data(
                m_proxyModel->index(rowIndex.row(), SearchSortModel::ENGINE_NAME)).toString();

    if (torrentUrl.startsWith(u"magnet:", Qt::CaseInsensitive))
    {
        addTorrentToSession(torrentUrl, option);
    }
    else
    {
        SearchDownloadHandler *downloadHandler = SearchPluginManager::instance()->downloadTorrent(engineName, torrentUrl);
        connect(downloadHandler, &SearchDownloadHandler::downloadFinished
            , this, [this, option](const QString &source) { addTorrentToSession(source, option); });
        connect(downloadHandler, &SearchDownloadHandler::downloadFinished, downloadHandler, &SearchDownloadHandler::deleteLater);
    }

    setRowVisited(rowIndex.row());
}

void SearchJobWidget::addTorrentToSession(const QString &source, const AddTorrentOption option)
{
    app()->addTorrentManager()->addTorrent(source, {}, option);
}

void SearchJobWidget::updateResultsCount()
{
    const int totalResults = m_searchListModel->rowCount();
    const int filteredResults = m_proxyModel->rowCount();
    m_ui->resultsLbl->setText(tr("Results (showing <i>%1</i> out of <i>%2</i>):", "i.e: Search results")
                              .arg(filteredResults).arg(totalResults));

    m_noSearchResults = (totalResults == 0);
    emit resultsCountUpdated();
}

void SearchJobWidget::updateFilter()
{
    using Utils::Misc::SizeUnit;

    m_proxyModel->enableNameFilter(filteringMode() == NameFilteringMode::OnlyNames);
    // we update size and seeds filter parameters in the model even if they are disabled
    m_proxyModel->setSeedsFilter(m_ui->minSeeds->value(), m_ui->maxSeeds->value());
    m_proxyModel->setSizeFilter(
        sizeInBytes(m_ui->minSize->value(), static_cast<SizeUnit>(m_ui->minSizeUnit->currentIndex())),
        sizeInBytes(m_ui->maxSize->value(), static_cast<SizeUnit>(m_ui->maxSizeUnit->currentIndex())));

    m_nameFilteringMode = filteringMode();

    m_proxyModel->invalidate();
    updateResultsCount();
}

void SearchJobWidget::fillFilterComboBoxes()
{
    using Utils::Misc::SizeUnit;
    using Utils::Misc::unitString;

    QStringList unitStrings;
    unitStrings.append(unitString(SizeUnit::Byte));
    unitStrings.append(unitString(SizeUnit::KibiByte));
    unitStrings.append(unitString(SizeUnit::MebiByte));
    unitStrings.append(unitString(SizeUnit::GibiByte));
    unitStrings.append(unitString(SizeUnit::TebiByte));
    unitStrings.append(unitString(SizeUnit::PebiByte));
    unitStrings.append(unitString(SizeUnit::ExbiByte));

    m_ui->minSizeUnit->clear();
    m_ui->maxSizeUnit->clear();
    m_ui->minSizeUnit->addItems(unitStrings);
    m_ui->maxSizeUnit->addItems(unitStrings);

    m_ui->minSize->setValue(0);
    m_ui->minSizeUnit->setCurrentIndex(static_cast<int>(SizeUnit::MebiByte));

    m_ui->maxSize->setValue(-1);
    m_ui->maxSizeUnit->setCurrentIndex(static_cast<int>(SizeUnit::GibiByte));

    m_ui->filterMode->clear();

    m_ui->filterMode->addItem(tr("Torrent names only"), static_cast<int>(NameFilteringMode::OnlyNames));
    m_ui->filterMode->addItem(tr("Everywhere"), static_cast<int>(NameFilteringMode::Everywhere));

    const QVariant selectedMode = static_cast<int>(m_nameFilteringMode.get(NameFilteringMode::OnlyNames));
    const int index = m_ui->filterMode->findData(selectedMode);
    m_ui->filterMode->setCurrentIndex((index == -1) ? 0 : index);
}

void SearchJobWidget::filterSearchResults(const QString &name)
{
    const QString pattern = (Preferences::instance()->getRegexAsFilteringPatternForSearchJob()
                    ? name : Utils::String::wildcardToRegexPattern(name));
    m_proxyModel->setFilterRegularExpression(QRegularExpression(pattern, QRegularExpression::CaseInsensitiveOption));
    updateResultsCount();
}

void SearchJobWidget::showFilterContextMenu()
{
    const Preferences *pref = Preferences::instance();

    QMenu *menu = m_lineEditSearchResultsFilter->createStandardContextMenu();
    menu->setAttribute(Qt::WA_DeleteOnClose);
    menu->addSeparator();

    QAction *useRegexAct = menu->addAction(tr("Use regular expressions"));
    useRegexAct->setCheckable(true);
    useRegexAct->setChecked(pref->getRegexAsFilteringPatternForSearchJob());
    connect(useRegexAct, &QAction::toggled, pref, &Preferences::setRegexAsFilteringPatternForSearchJob);
    connect(useRegexAct, &QAction::toggled, this, [this]() { filterSearchResults(m_lineEditSearchResultsFilter->text()); });

    menu->popup(QCursor::pos());
}

void SearchJobWidget::contextMenuEvent(QContextMenuEvent *event)
{
    auto *menu = new QMenu(this);
    menu->setAttribute(Qt::WA_DeleteOnClose);

    menu->addAction(UIThemeManager::instance()->getIcon(u"download"_s)
        , tr("Open download window"), this, [this]() { downloadTorrents(AddTorrentOption::ShowDialog); });
    menu->addAction(UIThemeManager::instance()->getIcon(u"downloading"_s, u"download"_s)
        , tr("Download"), this, [this]() { downloadTorrents(AddTorrentOption::SkipDialog); });
    menu->addSeparator();
    menu->addAction(UIThemeManager::instance()->getIcon(u"application-url"_s), tr("Open description page")
        , this, &SearchJobWidget::openTorrentPages);

    QMenu *copySubMenu = menu->addMenu(
        UIThemeManager::instance()->getIcon(u"edit-copy"_s), tr("Copy"));

    copySubMenu->addAction(UIThemeManager::instance()->getIcon(u"name"_s, u"edit-copy"_s), tr("Name")
        , this, &SearchJobWidget::copyTorrentNames);
    copySubMenu->addAction(UIThemeManager::instance()->getIcon(u"insert-link"_s, u"edit-copy"_s), tr("Download link")
        , this, &SearchJobWidget::copyTorrentDownloadLinks);
    copySubMenu->addAction(UIThemeManager::instance()->getIcon(u"application-url"_s, u"edit-copy"_s), tr("Description page URL")
        , this, &SearchJobWidget::copyTorrentURLs);

    menu->popup(event->globalPos());
}

SearchJobWidget::NameFilteringMode SearchJobWidget::filteringMode() const
{
    return static_cast<NameFilteringMode>(m_ui->filterMode->itemData(m_ui->filterMode->currentIndex()).toInt());
}

void SearchJobWidget::loadSettings()
{
    header()->restoreState(Preferences::instance()->getSearchTabHeaderState());
}

void SearchJobWidget::saveSettings() const
{
    Preferences::instance()->setSearchTabHeaderState(header()->saveState());
}

int SearchJobWidget::visibleColumnsCount() const
{
    int count = 0;
    for (int i = 0, iMax = m_ui->resultsBrowser->header()->count(); i < iMax; ++i)
    {
        if (!m_ui->resultsBrowser->isColumnHidden(i))
            ++count;
    }

    return count;
}

void SearchJobWidget::displayColumnHeaderMenu()
{
    auto *menu = new QMenu(this);
    menu->setAttribute(Qt::WA_DeleteOnClose);
    menu->setTitle(tr("Column visibility"));
    menu->setToolTipsVisible(true);

    for (int i = 0; i < SearchSortModel::DL_LINK; ++i)
    {
        const auto columnName = m_searchListModel->headerData(i, Qt::Horizontal, Qt::DisplayRole).toString();
        QAction *action = menu->addAction(columnName, this, [this, i](const bool checked)
        {
            if (!checked && (visibleColumnsCount() <= 1))
                return;

            m_ui->resultsBrowser->setColumnHidden(i, !checked);

            if (checked && (m_ui->resultsBrowser->columnWidth(i) <= 5))
                m_ui->resultsBrowser->resizeColumnToContents(i);

            saveSettings();
        });
        action->setCheckable(true);
        action->setChecked(!m_ui->resultsBrowser->isColumnHidden(i));
    }

    menu->addSeparator();
    QAction *resizeAction = menu->addAction(tr("Resize columns"), this, [this]()
    {
        for (int i = 0, count = m_ui->resultsBrowser->header()->count(); i < count; ++i)
        {
            if (!m_ui->resultsBrowser->isColumnHidden(i))
                m_ui->resultsBrowser->resizeColumnToContents(i);
        }
        saveSettings();
    });
    resizeAction->setToolTip(tr("Resize all non-hidden columns to the size of their contents"));

    menu->popup(QCursor::pos());
}

void SearchJobWidget::searchFinished(bool cancelled)
{
    if (cancelled)
        setStatus(Status::Aborted);
    else if (m_noSearchResults)
        setStatus(Status::NoResults);
    else
        setStatus(Status::Finished);
}

void SearchJobWidget::searchFailed()
{
    setStatus(Status::Error);
}

void SearchJobWidget::appendSearchResults(const QList<SearchResult> &results)
{
    for (const SearchResult &result : results)
    {
        // Add item to search result list
        int row = m_searchListModel->rowCount();
        m_searchListModel->insertRow(row);

        const auto setModelData = [this, row] (const int column, const QString &displayData
                , const QVariant &underlyingData, const Qt::Alignment textAlignmentData = {})
        {
            const QMap<int, QVariant> data =
            {
                {Qt::DisplayRole, displayData},
                {SearchSortModel::UnderlyingDataRole, underlyingData},
                {Qt::TextAlignmentRole, QVariant {textAlignmentData}}
            };
            m_searchListModel->setItemData(m_searchListModel->index(row, column), data);
        };

        setModelData(SearchSortModel::NAME, result.fileName, result.fileName);
        setModelData(SearchSortModel::DL_LINK, result.fileUrl, result.fileUrl);
        setModelData(SearchSortModel::ENGINE_NAME, result.engineName, result.engineName);
        setModelData(SearchSortModel::ENGINE_URL, result.siteUrl, result.siteUrl);
        setModelData(SearchSortModel::DESC_LINK, result.descrLink, result.descrLink);
        setModelData(SearchSortModel::SIZE, Utils::Misc::friendlyUnit(result.fileSize), result.fileSize, (Qt::AlignRight | Qt::AlignVCenter));
        setModelData(SearchSortModel::SEEDS, QString::number(result.nbSeeders), result.nbSeeders, (Qt::AlignRight | Qt::AlignVCenter));
        setModelData(SearchSortModel::LEECHES, QString::number(result.nbLeechers), result.nbLeechers, (Qt::AlignRight | Qt::AlignVCenter));
        setModelData(SearchSortModel::PUB_DATE, QLocale().toString(result.pubDate.toLocalTime(), QLocale::ShortFormat), result.pubDate);
    }

    m_searchResults.append(results);
    updateResultsCount();
}

void SearchJobWidget::keyPressEvent(QKeyEvent *event)
{
    switch (event->key())
    {
    case Qt::Key_Enter:
    case Qt::Key_Return:
        downloadTorrents();
        break;
    default:
        QWidget::keyPressEvent(event);
    }
}
</file>

<file path="gui/search/searchjobwidget.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2018-2025  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QWidget>

#include "base/settingvalue.h"
#include "gui/guiaddtorrentmanager.h"
#include "gui/guiapplicationcomponent.h"

#define ENGINE_URL_COLUMN 4
#define URL_COLUMN 5

class QHeaderView;
class QModelIndex;
class QStandardItemModel;

class LineEdit;
class SearchHandler;
class SearchSortModel;
struct SearchResult;

template <typename T> class SettingValue;

namespace Ui
{
    class SearchJobWidget;
}

class SearchJobWidget final : public GUIApplicationComponent<QWidget>
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(SearchJobWidget)

public:
    enum class NameFilteringMode
    {
        Everywhere,
        OnlyNames
    };
    Q_ENUM(NameFilteringMode)

    enum class Status
    {
        Ready,
        Ongoing,
        Finished,
        Error,
        Aborted,
        NoResults
    };

    SearchJobWidget(const QString &id, const QString &searchPattern, const QList<SearchResult> &searchResults, IGUIApplication *app, QWidget *parent = nullptr);
    SearchJobWidget(const QString &id, SearchHandler *searchHandler, IGUIApplication *app, QWidget *parent = nullptr);
    ~SearchJobWidget() override;

    QString id() const;
    QString searchPattern() const;
    QList<SearchResult> searchResults() const;
    Status status() const;
    int visibleResultsCount() const;
    LineEdit *lineEditSearchResultsFilter() const;

    void assignSearchHandler(SearchHandler *searchHandler);
    void cancelSearch();

signals:
    void resultsCountUpdated();
    void statusChanged();

protected:
    void keyPressEvent(QKeyEvent *event) override;

private slots:
    void displayColumnHeaderMenu();

private:
    SearchJobWidget(const QString &id, IGUIApplication *app, QWidget *parent);

    void loadSettings();
    void saveSettings() const;
    void updateFilter();
    void filterSearchResults(const QString &name);
    void showFilterContextMenu();
    void contextMenuEvent(QContextMenuEvent *event) override;
    void onItemDoubleClicked(const QModelIndex &index);
    void searchFinished(bool cancelled);
    void searchFailed();
    void appendSearchResults(const QList<SearchResult> &results);
    void updateResultsCount();
    void setStatus(Status value);
    void downloadTorrent(const QModelIndex &rowIndex, AddTorrentOption option = AddTorrentOption::Default);
    void addTorrentToSession(const QString &source, AddTorrentOption option = AddTorrentOption::Default);
    void fillFilterComboBoxes();
    NameFilteringMode filteringMode() const;
    QHeaderView *header() const;
    int visibleColumnsCount() const;
    void setRowColor(int row, const QColor &color);
    void setRowVisited(int row);
    void onUIThemeChanged();

    void downloadTorrents(AddTorrentOption option = AddTorrentOption::Default);
    void openTorrentPages() const;
    void copyTorrentURLs() const;
    void copyTorrentDownloadLinks() const;
    void copyTorrentNames() const;
    void copyField(int column) const;

    SettingValue<NameFilteringMode> m_nameFilteringMode;

    QString m_id;
    QString m_searchPattern;
    QList<SearchResult> m_searchResults;
    Ui::SearchJobWidget *m_ui = nullptr;
    SearchHandler *m_searchHandler = nullptr;
    QStandardItemModel *m_searchListModel = nullptr;
    SearchSortModel *m_proxyModel = nullptr;
    LineEdit *m_lineEditSearchResultsFilter = nullptr;
    Status m_status = Status::Ready;
    bool m_noSearchResults = true;
};

Q_DECLARE_METATYPE(SearchJobWidget::NameFilteringMode)
</file>

<file path="gui/search/searchjobwidget.ui">
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>SearchJobWidget</class>
 <widget class="QWidget" name="SearchJobWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>1216</width>
    <height>364</height>
   </rect>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout">
   <item>
    <layout class="QHBoxLayout" name="horizontalLayout">
     <item>
      <widget class="QLabel" name="resultsLbl">
       <property name="text">
        <string>Results(xxx)</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer">
       <property name="orientation">
        <enum>Qt::Orientation::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>40</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QLabel" name="label_5">
       <property name="text">
        <string>Search in:</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QComboBox" name="filterMode">
       <property name="toolTip">
        <string>&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Some search engines search in torrent description and in torrent file names too. Whether such results will be shown in the list below is controlled by this mode.&lt;/p&gt;&lt;p&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Everywhere &lt;/span&gt;disables filtering and shows everything returned by the search engines.&lt;/p&gt;&lt;p&gt;&lt;span style=&quot; font-weight:600;&quot;&gt;Torrent names only&lt;/span&gt; shows only torrents whose names match the search query.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</string>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_2">
       <property name="orientation">
        <enum>Qt::Orientation::Horizontal</enum>
       </property>
       <property name="sizeType">
        <enum>QSizePolicy::Policy::Minimum</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>12</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QLabel" name="label">
       <property name="toolTip">
        <string>Set minimum and maximum allowed number of seeders</string>
       </property>
       <property name="text">
        <string>Seeds:</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QSpinBox" name="minSeeds">
       <property name="toolTip">
        <string>Minimum number of seeds</string>
       </property>
       <property name="maximum">
        <number>1000</number>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QLabel" name="label_4">
       <property name="text">
        <string>to</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QSpinBox" name="maxSeeds">
       <property name="toolTip">
        <string>Maximum number of seeds</string>
       </property>
       <property name="specialValueText">
        <string>∞</string>
       </property>
       <property name="maximum">
        <number>1000</number>
       </property>
      </widget>
     </item>
     <item>
      <spacer name="horizontalSpacer_3">
       <property name="orientation">
        <enum>Qt::Orientation::Horizontal</enum>
       </property>
       <property name="sizeType">
        <enum>QSizePolicy::Policy::Minimum</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>12</width>
         <height>20</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QLabel" name="label_3">
       <property name="toolTip">
        <string>Set minimum and maximum allowed size of a torrent</string>
       </property>
       <property name="text">
        <string>Size:</string>
       </property>
      </widget>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_3">
       <item>
        <widget class="QDoubleSpinBox" name="minSize">
         <property name="toolTip">
          <string>Minimum torrent size</string>
         </property>
         <property name="maximum">
          <double>1000.000000000000000</double>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QComboBox" name="minSizeUnit"/>
       </item>
      </layout>
     </item>
     <item>
      <widget class="QLabel" name="label_2">
       <property name="text">
        <string>to</string>
       </property>
      </widget>
     </item>
     <item>
      <layout class="QHBoxLayout" name="horizontalLayout_4">
       <item>
        <widget class="QDoubleSpinBox" name="maxSize">
         <property name="toolTip">
          <string>Maximum torrent size</string>
         </property>
         <property name="specialValueText">
          <string>∞</string>
         </property>
         <property name="maximum">
          <double>1000.000000000000000</double>
         </property>
        </widget>
       </item>
       <item>
        <widget class="QComboBox" name="maxSizeUnit"/>
       </item>
      </layout>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QTreeView" name="resultsBrowser"/>
   </item>
  </layout>
 </widget>
 <resources/>
 <connections/>
</ui>
</file>

<file path="gui/search/searchsortmodel.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2013  sledgehammer999 <hammered999@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "searchsortmodel.h"

#include "base/global.h"

SearchSortModel::SearchSortModel(QObject *parent)
    : base(parent)
{
    setSortRole(UnderlyingDataRole);
    setFilterRole(UnderlyingDataRole);
}

void SearchSortModel::enableNameFilter(const bool enabled)
{
    m_isNameFilterEnabled = enabled;
}

void SearchSortModel::setNameFilter(const QString &searchTerm)
{
    m_searchTerm = searchTerm;
    if ((searchTerm.length() > 2) && searchTerm.startsWith(u'"') && searchTerm.endsWith(u'"'))
        m_searchTermWords = QStringList(m_searchTerm.sliced(1, (m_searchTerm.length() - 2)));
    else
        m_searchTermWords = searchTerm.split(u' ', Qt::SkipEmptyParts);
}

void SearchSortModel::setSizeFilter(const qint64 minSize, const qint64 maxSize)
{
    m_minSize = std::max(static_cast<qint64>(0), minSize);
    m_maxSize = std::max(static_cast<qint64>(-1), maxSize);
}

void SearchSortModel::setSeedsFilter(const int minSeeds, const int maxSeeds)
{
    m_minSeeds = std::max(0, minSeeds);
    m_maxSeeds = std::max(-1, maxSeeds);
}

void SearchSortModel::setLeechesFilter(const int minLeeches, const int maxLeeches)
{
    m_minLeeches = std::max(0, minLeeches);
    m_maxLeeches = std::max(-1, maxLeeches);
}

bool SearchSortModel::isNameFilterEnabled() const
{
    return m_isNameFilterEnabled;
}

QString SearchSortModel::searchTerm() const
{
    return m_searchTerm;
}

int SearchSortModel::minSeeds() const
{
    return m_minSeeds;
}

int SearchSortModel::maxSeeds() const
{
    return m_maxSeeds;
}

qint64 SearchSortModel::minSize() const
{
    return m_minSize;
}

qint64 SearchSortModel::maxSize() const
{
    return m_maxSize;
}

bool SearchSortModel::lessThan(const QModelIndex &left, const QModelIndex &right) const
{
    switch (sortColumn())
    {
    case NAME:
    case ENGINE_URL:
        {
            const QString strL = left.data().toString();
            const QString strR = right.data().toString();
            return m_naturalLessThan(strL, strR);
        }
        break;
    default:
        return base::lessThan(left, right);
    };
}

bool SearchSortModel::filterAcceptsRow(const int sourceRow, const QModelIndex &sourceParent) const
{
    const QAbstractItemModel *const sourceModel = this->sourceModel();

    if (m_isNameFilterEnabled && !m_searchTerm.isEmpty())
    {
        const QString name = sourceModel->data(sourceModel->index(sourceRow, NAME, sourceParent), UnderlyingDataRole).toString();
        for (const QString &word : asConst(m_searchTermWords))
        {
            if (!name.contains(word, Qt::CaseInsensitive))
                return false;
        }
    }

    if ((m_minSize > 0) || (m_maxSize >= 0))
    {
        const qlonglong size = sourceModel->data(sourceModel->index(sourceRow, SIZE, sourceParent), UnderlyingDataRole).toLongLong();
        if (((m_minSize > 0) && (size < m_minSize))
            || ((m_maxSize > 0) && (size > m_maxSize)))
            return false;
    }

    if ((m_minSeeds > 0) || (m_maxSeeds >= 0))
    {
        const int seeds = sourceModel->data(sourceModel->index(sourceRow, SEEDS, sourceParent), UnderlyingDataRole).toInt();
        if (((m_minSeeds > 0) && (seeds < m_minSeeds))
            || ((m_maxSeeds > 0) && (seeds > m_maxSeeds)))
            return false;
    }

    if ((m_minLeeches > 0) || (m_maxLeeches >= 0))
    {
        const int leeches = sourceModel->data(sourceModel->index(sourceRow, LEECHES, sourceParent), UnderlyingDataRole).toInt();
        if (((m_minLeeches > 0) && (leeches < m_minLeeches))
            || ((m_maxLeeches > 0) && (leeches > m_maxLeeches)))
            return false;
    }

    return base::filterAcceptsRow(sourceRow, sourceParent);
}
</file>

<file path="gui/search/searchsortmodel.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2013  sledgehammer999 <hammered999@gmail.com>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QSortFilterProxyModel>
#include <QStringList>

#include "base/utils/compare.h"

class SearchSortModel final : public QSortFilterProxyModel
{
    using base = QSortFilterProxyModel;

public:
    enum SearchColumn
    {
        NAME,
        SIZE,
        SEEDS,
        LEECHES,
        ENGINE_NAME,
        ENGINE_URL,
        PUB_DATE,
        DL_LINK,
        DESC_LINK,
        NB_SEARCH_COLUMNS
    };

    enum SearchDataRole
    {
        UnderlyingDataRole = Qt::UserRole
    };

    explicit SearchSortModel(QObject *parent = nullptr);

    void enableNameFilter(bool enabled);
    void setNameFilter(const QString &searchTerm = {});

    //! \brief Sets parameters for filtering by size
    //! \param minSize minimal size in bytes
    //! \param maxSize maximal size in bytes, negative value to disable filtering
    void setSizeFilter(qint64 minSize, qint64 maxSize);

    //! \brief Sets parameters for filtering by seeds number
    //! \param minSeeds minimal number of seeders
    //! \param maxSeeds maximal number of seeders, negative value to disable filtering
    void setSeedsFilter(int minSeeds, int maxSeeds);

    //! \brief Sets parameters for filtering by leeches number
    //! \param minLeeches minimal number of leechers
    //! \param maxLeeches maximal number of leechers, negative value to disable filtering
    void setLeechesFilter(int minLeeches, int maxLeeches);

    bool isNameFilterEnabled() const;

    QString searchTerm() const;

    int minSeeds() const;
    int maxSeeds() const;

    qint64 minSize() const;
    qint64 maxSize() const;

protected:
    bool lessThan(const QModelIndex &left, const QModelIndex &right) const override;
    bool filterAcceptsRow(int sourceRow, const QModelIndex &sourceParent) const override;

private:
    bool m_isNameFilterEnabled = false;
    QString m_searchTerm;
    QStringList m_searchTermWords;
    int m_minSeeds = 0, m_maxSeeds = -1;
    int m_minLeeches = 0, m_maxLeeches = -1;
    qint64 m_minSize = 0, m_maxSize = -1;

    Utils::Compare::NaturalLessThan<Qt::CaseInsensitive> m_naturalLessThan;
};
</file>

<file path="gui/search/searchwidget.cpp">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015-2025  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2020, Will Da Silva <will@willdasilva.xyz>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#include "searchwidget.h"

#include <QtSystemDetection>

#include <utility>

#include <QCompleter>
#include <QDebug>
#include <QEvent>
#include <QJsonArray>
#include <QJsonDocument>
#include <QJsonObject>
#include <QJsonParseError>
#include <QJsonValue>
#include <QList>
#include <QMenu>
#include <QMessageBox>
#include <QMouseEvent>
#include <QObject>
#include <QRegularExpression>
#include <QShortcut>
#include <QSortFilterProxyModel>
#include <QStringList>
#include <QStringListModel>
#include <QThread>

#include "base/global.h"
#include "base/logger.h"
#include "base/preferences.h"
#include "base/profile.h"
#include "base/search/searchhandler.h"
#include "base/search/searchpluginmanager.h"
#include "base/utils/bytearray.h"
#include "base/utils/compare.h"
#include "base/utils/datetime.h"
#include "base/utils/fs.h"
#include "base/utils/foreignapps.h"
#include "base/utils/io.h"
#include "gui/desktopintegration.h"
#include "gui/interfaces/iguiapplication.h"
#include "gui/uithememanager.h"
#include "pluginselectdialog.h"
#include "searchjobwidget.h"
#include "ui_searchwidget.h"

const int HISTORY_FILE_MAX_SIZE = 10 * 1024 * 1024;
const int SESSION_FILE_MAX_SIZE = 10 * 1024 * 1024;
const int RESULTS_FILE_MAX_SIZE = 10 * 1024 * 1024;

const QString DATA_FOLDER_NAME = u"SearchUI"_s;
const QString HISTORY_FILE_NAME = u"History.txt"_s;
const QString SESSION_FILE_NAME = u"Session.json"_s;

const QString KEY_SESSION_TABS = u"Tabs"_s;
const QString KEY_SESSION_CURRENTTAB = u"CurrentTab"_s;
const QString KEY_TAB_ID = u"ID"_s;
const QString KEY_TAB_SEARCHPATTERN = u"SearchPattern"_s;
const QString KEY_RESULT_FILENAME = u"FileName"_s;
const QString KEY_RESULT_FILEURL = u"FileURL"_s;
const QString KEY_RESULT_FILESIZE = u"FileSize"_s;
const QString KEY_RESULT_SEEDERSCOUNT = u"SeedersCount"_s;
const QString KEY_RESULT_LEECHERSCOUNT = u"LeechersCount"_s;
const QString KEY_RESULT_ENGINENAME = u"EngineName"_s;
const QString KEY_RESULT_SITEURL = u"SiteURL"_s;
const QString KEY_RESULT_DESCRLINK = u"DescrLink"_s;
const QString KEY_RESULT_PUBDATE = u"PubDate"_s;

namespace
{
    class SearchHistorySortModel final : public QSortFilterProxyModel
    {
        Q_OBJECT
        Q_DISABLE_COPY_MOVE(SearchHistorySortModel)

    public:
        using QSortFilterProxyModel::QSortFilterProxyModel;

    private:
        bool lessThan(const QModelIndex &left, const QModelIndex &right) const override
        {
            const int result = m_naturalCompare(left.data(sortRole()).toString(), right.data(sortRole()).toString());
            return result < 0;
        }

        Utils::Compare::NaturalCompare<Qt::CaseInsensitive> m_naturalCompare;
    };

    struct TabData
    {
        QString tabID;
        QString searchPattern;
    };

    struct SessionData
    {
        QList<TabData> tabs;
        QString currentTabID;
    };

    QString statusIconName(const SearchJobWidget::Status st)
    {
        switch (st)
        {
        case SearchJobWidget::Status::Ongoing:
            return u"queued"_s;
        case SearchJobWidget::Status::Finished:
            return u"task-complete"_s;
        case SearchJobWidget::Status::Aborted:
            return u"task-reject"_s;
        case SearchJobWidget::Status::Error:
        case SearchJobWidget::Status::NoResults:
            return u"dialog-warning"_s;
        default:
            return {};
        }
    }

    Path makeDataFilePath(const QString &fileName)
    {
        return specialFolderLocation(SpecialFolder::Data) / Path(DATA_FOLDER_NAME) / Path(fileName);
    }

    QString makeTabName(SearchJobWidget *searchJobWdget)
    {
        Q_ASSERT(searchJobWdget);
        if (!searchJobWdget) [[unlikely]]
            return {};

        QString tabName = searchJobWdget->searchPattern();
        tabName.replace(QRegularExpression(u"&{1}"_s), u"&&"_s);
        return tabName;
    }

    nonstd::expected<QStringList, QString> loadHistory(const Path &filePath)
    {
        const auto readResult = Utils::IO::readFile(filePath, HISTORY_FILE_MAX_SIZE);
        if (!readResult)
        {
            if (readResult.error().status == Utils::IO::ReadError::NotExist)
                return {};

            return nonstd::make_unexpected(readResult.error().message);
        }

        const QList<QByteArrayView> lines = Utils::ByteArray::splitToViews(readResult.value(), "\n");
        QStringList history;
        history.reserve(lines.size());
        for (const QByteArrayView line : lines)
            history.append(QString::fromUtf8(line));

        return history;
    }

    nonstd::expected<SessionData, QString> loadSession(const Path &filePath)
    {
        const auto readResult = Utils::IO::readFile(filePath, SESSION_FILE_MAX_SIZE);
        if (!readResult)
        {
            if (readResult.error().status == Utils::IO::ReadError::NotExist)
                return {};

            return nonstd::make_unexpected(readResult.error().message);
        }

        const QString formatErrorMsg = SearchWidget::tr("Invalid data format.");
        QJsonParseError jsonError;
        const QJsonDocument sessionDoc = QJsonDocument::fromJson(readResult.value(), &jsonError);
        if (jsonError.error != QJsonParseError::NoError)
            return nonstd::make_unexpected(jsonError.errorString());

        if (!sessionDoc.isObject())
            return nonstd::make_unexpected(formatErrorMsg);

        const QJsonObject sessionObj = sessionDoc.object();
        const QJsonValue tabsVal = sessionObj[KEY_SESSION_TABS];
        if (!tabsVal.isArray())
            return nonstd::make_unexpected(formatErrorMsg);

        QList<TabData> tabs;
        QSet<QString> tabIDs;
        for (const QJsonValue &tabVal : asConst(tabsVal.toArray()))
        {
            if (!tabVal.isObject())
                return nonstd::make_unexpected(formatErrorMsg);

            const QJsonObject tabObj = tabVal.toObject();

            const QJsonValue tabIDVal = tabObj[KEY_TAB_ID];
            if (!tabIDVal.isString())
                return nonstd::make_unexpected(formatErrorMsg);

            const QJsonValue patternVal = tabObj[KEY_TAB_SEARCHPATTERN];
            if (!patternVal.isString())
                return nonstd::make_unexpected(formatErrorMsg);

            const QString tabID = tabIDVal.toString();
            tabIDs.insert(tabID);
            tabs.emplaceBack(TabData {tabID, patternVal.toString()});
            if (tabs.size() != tabIDs.size()) // duplicate ID
                return nonstd::make_unexpected(formatErrorMsg);
        }

        const QJsonValue currentTabVal = sessionObj[KEY_SESSION_CURRENTTAB];
        if (!currentTabVal.isString())
            return nonstd::make_unexpected(formatErrorMsg);

        return SessionData {.tabs = tabs, .currentTabID = currentTabVal.toString()};
    }

    nonstd::expected<QList<SearchResult>, QString> loadSearchResults(const Path &filePath)
    {
        const auto readResult = Utils::IO::readFile(filePath, RESULTS_FILE_MAX_SIZE);
        if (!readResult)
        {
            if (readResult.error().status != Utils::IO::ReadError::NotExist)
            {
                return nonstd::make_unexpected(readResult.error().message);
            }

            return {};
        }

        const QString formatErrorMsg = SearchWidget::tr("Invalid data format.");
        QJsonParseError jsonError;
        const QJsonDocument searchResultsDoc = QJsonDocument::fromJson(readResult.value(), &jsonError);
        if (jsonError.error != QJsonParseError::NoError)
            return nonstd::make_unexpected(jsonError.errorString());

        if (!searchResultsDoc.isArray())
            return nonstd::make_unexpected(formatErrorMsg);

        const QJsonArray resultsList = searchResultsDoc.array();
        QList<SearchResult> searchResults;
        for (const QJsonValue &resultVal : resultsList)
        {
            if (!resultVal.isObject())
                return nonstd::make_unexpected(formatErrorMsg);

            const QJsonObject resultObj = resultVal.toObject();
            SearchResult &searchResult = searchResults.emplaceBack();

            if (const QJsonValue fileNameVal = resultObj[KEY_RESULT_FILENAME]; fileNameVal.isString())
                searchResult.fileName = fileNameVal.toString();
            else
                return nonstd::make_unexpected(formatErrorMsg);

            if (const QJsonValue fileURLVal = resultObj[KEY_RESULT_FILEURL]; fileURLVal.isString())
                searchResult.fileUrl= fileURLVal.toString();
            else
                return nonstd::make_unexpected(formatErrorMsg);

            if (const QJsonValue fileSizeVal = resultObj[KEY_RESULT_FILESIZE]; fileSizeVal.isDouble())
                searchResult.fileSize= fileSizeVal.toInteger();
            else
                return nonstd::make_unexpected(formatErrorMsg);

            if (const QJsonValue seedersCountVal = resultObj[KEY_RESULT_SEEDERSCOUNT]; seedersCountVal.isDouble())
                searchResult.nbSeeders = seedersCountVal.toInteger();
            else
                return nonstd::make_unexpected(formatErrorMsg);

            if (const QJsonValue leechersCountVal = resultObj[KEY_RESULT_LEECHERSCOUNT]; leechersCountVal.isDouble())
                searchResult.nbLeechers = leechersCountVal.toInteger();
            else
                return nonstd::make_unexpected(formatErrorMsg);

            if (const QJsonValue engineNameVal = resultObj[KEY_RESULT_ENGINENAME]; engineNameVal.isString())
                searchResult.engineName= engineNameVal.toString();
            else
                return nonstd::make_unexpected(formatErrorMsg);

            if (const QJsonValue siteURLVal = resultObj[KEY_RESULT_SITEURL]; siteURLVal.isString())
                searchResult.siteUrl= siteURLVal.toString();
            else
                return nonstd::make_unexpected(formatErrorMsg);

            if (const QJsonValue descrLinkVal = resultObj[KEY_RESULT_DESCRLINK]; descrLinkVal.isString())
                searchResult.descrLink= descrLinkVal.toString();
            else
                return nonstd::make_unexpected(formatErrorMsg);

            if (const QJsonValue pubDateVal = resultObj[KEY_RESULT_PUBDATE]; pubDateVal.isDouble())
                searchResult.pubDate = QDateTime::fromSecsSinceEpoch(pubDateVal.toInteger());
            else
                return nonstd::make_unexpected(formatErrorMsg);
        }

        return searchResults;
    }
}

class SearchWidget::DataStorage final : public QObject
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(DataStorage)

public:
    using QObject::QObject;

    void loadSession(bool withSearchResults);
    void storeSession(const SessionData &sessionData);
    void removeSession();
    void storeTab(const QString &tabID, const QList<SearchResult> &searchResults);
    void removeTab(const QString &tabID);
    void loadHistory();
    void storeHistory(const QStringList &history);
    void removeHistory();

signals:
    void historyLoaded(const QStringList &history);
    void sessionLoaded(const SessionData &sessionData);
    void tabLoaded(const QString &tabID, const QString &searchPattern, const QList<SearchResult> &searchResults);
};

SearchWidget::SearchWidget(IGUIApplication *app, QWidget *parent)
    : GUIApplicationComponent(app, parent)
    , m_ui {new Ui::SearchWidget()}
    , m_ioThread {new QThread}
    , m_dataStorage {new DataStorage}
{
    m_ui->setupUi(this);

    m_ui->stopButton->hide();
    m_ui->tabWidget->tabBar()->installEventFilter(this);

    const QString searchPatternHint = u"<html><head/><body><p>"
        + tr("A phrase to search for.") + u"<br>"
        + tr("Spaces in a search term may be protected by double quotes.")
        + u"</p><p>"
        + tr("Example:", "Search phrase example")
        + u"<br>"
        + tr("<b>foo bar</b>: search for <b>foo</b> and <b>bar</b>",
                 "Search phrase example, illustrates quotes usage, a pair of "
                 "space delimited words, individual words are highlighted")
        + u"<br>"
        + tr("<b>&quot;foo bar&quot;</b>: search for <b>foo bar</b>",
                 "Search phrase example, illustrates quotes usage, double quoted"
                 "pair of space delimited words, the whole pair is highlighted")
        + u"</p></body></html>";
    m_ui->lineEditSearchPattern->setToolTip(searchPatternHint);

#ifndef Q_OS_MACOS
    // Icons
    m_ui->searchButton->setIcon(UIThemeManager::instance()->getIcon(u"edit-find"_s));
    m_ui->pluginsButton->setIcon(UIThemeManager::instance()->getIcon(u"plugins"_s, u"preferences-system-network"_s));
#else
    // On macOS the icons overlap the text otherwise
    QSize iconSize = m_ui->tabWidget->iconSize();
    iconSize.setWidth(iconSize.width() + 16);
    m_ui->tabWidget->setIconSize(iconSize);
#endif
    connect(m_ui->tabWidget, &QTabWidget::tabCloseRequested, this, &SearchWidget::closeTab);
    connect(m_ui->tabWidget, &QTabWidget::currentChanged, this, &SearchWidget::currentTabChanged);
    connect(m_ui->tabWidget, &QTabWidget::currentChanged, this, &SearchWidget::saveSession);
    connect(m_ui->tabWidget->tabBar(), &QTabBar::tabMoved, this, &SearchWidget::saveSession);

    connect(m_ui->tabWidget, &QTabWidget::tabBarDoubleClicked, this, [this](const int tabIndex)
    {
        if (tabIndex < 0)
            return;

        // Reset current search pattern
        auto *searchJobWidget = static_cast<SearchJobWidget *>(m_ui->tabWidget->widget(tabIndex));
        const QString pattern = searchJobWidget->searchPattern();
        if (pattern != m_ui->lineEditSearchPattern->text())
        {
            m_ui->lineEditSearchPattern->setText(pattern);
            m_isNewQueryString = false;
            adjustSearchButton();
        }
    });

    const auto *searchManager = SearchPluginManager::instance();
    const auto onPluginChanged = [this]()
    {
        fillPluginComboBox();
        fillCatCombobox();
        selectActivePage();
    };
    connect(searchManager, &SearchPluginManager::pluginInstalled, this, onPluginChanged);
    connect(searchManager, &SearchPluginManager::pluginUninstalled, this, onPluginChanged);
    connect(searchManager, &SearchPluginManager::pluginUpdated, this, onPluginChanged);
    connect(searchManager, &SearchPluginManager::pluginEnabled, this, onPluginChanged);

    // Fill in category combobox
    onPluginChanged();

    connect(m_ui->pluginsButton, &QPushButton::clicked, this, &SearchWidget::pluginsButtonClicked);
    connect(m_ui->searchButton, &QPushButton::clicked, this, &SearchWidget::searchButtonClicked);
    connect(m_ui->stopButton, &QPushButton::clicked, this, &SearchWidget::stopButtonClicked);
    connect(m_ui->lineEditSearchPattern, &LineEdit::returnPressed, m_ui->searchButton, &QPushButton::click);
    connect(m_ui->lineEditSearchPattern, &LineEdit::textEdited, this, &SearchWidget::searchTextEdited);
    connect(m_ui->selectPlugin, qOverload<int>(&QComboBox::currentIndexChanged)
            , this, &SearchWidget::selectMultipleBox);
    connect(m_ui->selectPlugin, qOverload<int>(&QComboBox::currentIndexChanged)
            , this, &SearchWidget::fillCatCombobox);

    const auto *focusSearchHotkey = new QShortcut(QKeySequence::Find, this);
    connect(focusSearchHotkey, &QShortcut::activated, this, &SearchWidget::toggleFocusBetweenLineEdits);
    const auto *focusSearchHotkeyAlternative = new QShortcut((Qt::CTRL | Qt::Key_E), this);
    connect(focusSearchHotkeyAlternative, &QShortcut::activated, this, &SearchWidget::toggleFocusBetweenLineEdits);

    m_historyLength = Preferences::instance()->searchHistoryLength();
    m_storeOpenedTabs = Preferences::instance()->storeOpenedSearchTabs();
    m_storeOpenedTabsResults = Preferences::instance()->storeOpenedSearchTabResults();
    connect(Preferences::instance(), &Preferences::changed, this, &SearchWidget::onPreferencesChanged);

    m_dataStorage->moveToThread(m_ioThread.get());
    connect(m_ioThread.get(), &QThread::finished, m_dataStorage, &QObject::deleteLater);
    m_ioThread->setObjectName("SearchWidget m_ioThread");
    m_ioThread->start();

    loadHistory();
    restoreSession();
}

bool SearchWidget::eventFilter(QObject *object, QEvent *event)
{
    if (object == m_ui->tabWidget->tabBar())
    {
        // Close tabs when middle-clicked
        if (event->type() != QEvent::MouseButtonRelease)
            return false;

        const auto *mouseEvent = static_cast<QMouseEvent *>(event);
        const int tabIndex = m_ui->tabWidget->tabBar()->tabAt(mouseEvent->pos());
        if (tabIndex >= 0)
        {
            if (mouseEvent->button() == Qt::MiddleButton)
            {
                closeTab(tabIndex);
                return true;
            }

            if (mouseEvent->button() == Qt::RightButton)
            {
                showTabMenu(tabIndex);
                return true;
            }
        }

        return false;
    }

    return QWidget::eventFilter(object, event);
}

void SearchWidget::onPreferencesChanged()
{
    const auto *pref = Preferences::instance();

    const bool storeOpenedTabs = pref->storeOpenedSearchTabs();
    const bool isStoreOpenedTabsChanged = storeOpenedTabs != m_storeOpenedTabs;
    if (isStoreOpenedTabsChanged)
    {
        m_storeOpenedTabs = storeOpenedTabs;
        if (m_storeOpenedTabs)
        {
            saveSession();
        }
        else
        {
            QMetaObject::invokeMethod(m_dataStorage, &SearchWidget::DataStorage::removeSession);
        }
    }


    const bool storeOpenedTabsResults = pref->storeOpenedSearchTabResults();
    const bool isStoreOpenedTabsResultsChanged = storeOpenedTabsResults != m_storeOpenedTabsResults;
    if (isStoreOpenedTabsResultsChanged)
        m_storeOpenedTabsResults = storeOpenedTabsResults;

    if (isStoreOpenedTabsResultsChanged || isStoreOpenedTabsChanged)
    {
        if (m_storeOpenedTabsResults)
        {
            for (int tabIndex = (m_ui->tabWidget->count() - 1); tabIndex >= 0; --tabIndex)
            {
                const auto *tab = static_cast<SearchJobWidget *>(m_ui->tabWidget->widget(tabIndex));
                QMetaObject::invokeMethod(m_dataStorage, [this, tabID = tab->id(), searchResults = tab->searchResults()]
                {
                    m_dataStorage->storeTab(tabID, searchResults);
                });
            }
        }
        else
        {
            for (int tabIndex = (m_ui->tabWidget->count() - 1); tabIndex >= 0; --tabIndex)
            {
                const auto *tab = static_cast<SearchJobWidget *>(m_ui->tabWidget->widget(tabIndex));
                QMetaObject::invokeMethod(m_dataStorage, [this, tabID = tab->id()] { m_dataStorage->removeTab(tabID); });
            }
        }
    }

    const int historyLength = pref->searchHistoryLength();
    if (historyLength != m_historyLength)
    {
        if (m_historyLength <= 0)
        {
            createSearchPatternCompleter();
        }
        else
        {
            if (historyLength <= 0)
            {
                m_searchPatternCompleterModel->removeRows(0, m_searchPatternCompleterModel->rowCount());
                QMetaObject::invokeMethod(m_dataStorage, &SearchWidget::DataStorage::removeHistory);
            }
            else if (historyLength < m_historyLength)
            {
                if (const int rowCount = m_searchPatternCompleterModel->rowCount(); rowCount > historyLength)
                {
                    m_searchPatternCompleterModel->removeRows(0, (rowCount - historyLength));
                    QMetaObject::invokeMethod(m_dataStorage, [this]
                    {
                        m_dataStorage->storeHistory(m_searchPatternCompleterModel->stringList());
                    });
                }
            }
        }

        m_historyLength = historyLength;
    }
}

void SearchWidget::fillCatCombobox()
{
    m_ui->comboCategory->clear();
    m_ui->comboCategory->addItem(SearchPluginManager::categoryFullName(u"all"_s), u"all"_s);

    using QStrPair = std::pair<QString, QString>;
    QList<QStrPair> tmpList;
    const auto selectedPlugin = m_ui->selectPlugin->itemData(m_ui->selectPlugin->currentIndex()).toString();
    for (const QString &cat : asConst(SearchPluginManager::instance()->getPluginCategories(selectedPlugin)))
        tmpList << std::make_pair(SearchPluginManager::categoryFullName(cat), cat);
    std::sort(tmpList.begin(), tmpList.end(), [](const QStrPair &l, const QStrPair &r) { return (QString::localeAwareCompare(l.first, r.first) < 0); });

    for (const QStrPair &p : asConst(tmpList))
    {
        qDebug("Supported category: %s", qUtf8Printable(p.second));
        m_ui->comboCategory->addItem(p.first, p.second);
    }

    if (m_ui->comboCategory->count() > 1)
        m_ui->comboCategory->insertSeparator(1);
}

void SearchWidget::fillPluginComboBox()
{
    m_ui->selectPlugin->clear();
    m_ui->selectPlugin->addItem(tr("Only enabled"), u"enabled"_s);
    m_ui->selectPlugin->addItem(tr("All plugins"), u"all"_s);
    m_ui->selectPlugin->addItem(tr("Select..."), u"multi"_s);

    using QStrPair = std::pair<QString, QString>;
    QList<QStrPair> tmpList;
    for (const QString &name : asConst(SearchPluginManager::instance()->enabledPlugins()))
        tmpList << std::make_pair(SearchPluginManager::instance()->pluginFullName(name), name);
    std::sort(tmpList.begin(), tmpList.end(), [](const QStrPair &l, const QStrPair &r) { return (l.first < r.first); } );

    for (const QStrPair &p : asConst(tmpList))
        m_ui->selectPlugin->addItem(p.first, p.second);

    if (m_ui->selectPlugin->count() > 3)
        m_ui->selectPlugin->insertSeparator(3);
}

QString SearchWidget::selectedCategory() const
{
    return m_ui->comboCategory->itemData(m_ui->comboCategory->currentIndex()).toString();
}

QStringList SearchWidget::selectedPlugins() const
{
    const auto itemText = m_ui->selectPlugin->itemData(m_ui->selectPlugin->currentIndex()).toString();

    if (itemText == u"all")
        return SearchPluginManager::instance()->allPlugins();

    if ((itemText == u"enabled") || (itemText == u"multi"))
        return SearchPluginManager::instance()->enabledPlugins();

    return {itemText};
}

QString SearchWidget::generateTabID() const
{
    for (;;)
    {
        const QString tabID = QString::number(qHash(QDateTime::currentDateTimeUtc()));
        if (!m_tabWidgets.contains(tabID))
            return tabID;
    }

    return {};
}

int SearchWidget::addTab(const QString &tabID, SearchJobWidget *searchJobWdget)
{
    Q_ASSERT(!m_tabWidgets.contains(tabID));

    connect(searchJobWdget, &SearchJobWidget::statusChanged, this, [this, searchJobWdget]() { tabStatusChanged(searchJobWdget); });
    m_tabWidgets.insert(tabID, searchJobWdget);
    return m_ui->tabWidget->addTab(searchJobWdget, makeTabName(searchJobWdget));
}

void SearchWidget::updateHistory(const QString &newSearchPattern)
{
    if (m_historyLength <= 0)
        return;

    if (m_searchPatternCompleterModel->stringList().contains(newSearchPattern))
        return;

    const int rowNum = m_searchPatternCompleterModel->rowCount();
    m_searchPatternCompleterModel->insertRow(rowNum);
    m_searchPatternCompleterModel->setData(m_searchPatternCompleterModel->index(rowNum, 0), newSearchPattern);
    if (m_searchPatternCompleterModel->rowCount() > m_historyLength)
        m_searchPatternCompleterModel->removeRow(0);

    QMetaObject::invokeMethod(m_dataStorage, [this, history = m_searchPatternCompleterModel->stringList()]
    {
        m_dataStorage->storeHistory(history);
    });
}

void SearchWidget::loadHistory()
{
    if (m_historyLength <= 0)
        return;

    createSearchPatternCompleter();

    connect(m_dataStorage, &DataStorage::historyLoaded, this, [this](const QStringList &storedHistory)
    {
        if (m_historyLength <= 0)
            return;

        QStringList history = storedHistory;
        for (const QString &newPattern : asConst(m_searchPatternCompleterModel->stringList()))
        {
            if (!history.contains(newPattern))
                history.append(newPattern);
        }

        if (history.size() > m_historyLength)
            history.remove(0, (history.size() - m_historyLength));

        m_searchPatternCompleterModel->setStringList(history);
    });

    QMetaObject::invokeMethod(m_dataStorage, &SearchWidget::DataStorage::loadHistory);
}

void SearchWidget::saveSession() const
{
    if (!m_storeOpenedTabs)
        return;

    const int currentIndex = m_ui->tabWidget->currentIndex();
    SessionData sessionData;
    for (int tabIndex = 0; tabIndex < m_ui->tabWidget->count(); ++tabIndex)
    {
        auto *searchJobWidget = static_cast<SearchJobWidget *>(m_ui->tabWidget->widget(tabIndex));
        sessionData.tabs.emplaceBack(TabData {searchJobWidget->id(), searchJobWidget->searchPattern()});
        if (currentIndex == tabIndex)
            sessionData.currentTabID = searchJobWidget->id();
    }

    QMetaObject::invokeMethod(m_dataStorage, [this, sessionData] { m_dataStorage->storeSession(sessionData); });
}

void SearchWidget::createSearchPatternCompleter()
{
    Q_ASSERT(!m_ui->lineEditSearchPattern->completer());

    m_searchPatternCompleterModel = new QStringListModel(this);
    auto *sortModel = new SearchHistorySortModel(this);
    sortModel->setSourceModel(m_searchPatternCompleterModel);
    sortModel->sort(0);
    auto *completer = new QCompleter(sortModel, this);
    completer->setCaseSensitivity(Qt::CaseInsensitive);
    completer->setModelSorting(QCompleter::CaseInsensitivelySortedModel);
    m_ui->lineEditSearchPattern->setCompleter(completer);
}

void SearchWidget::restoreSession()
{
    if (!m_storeOpenedTabs)
        return;

    connect(m_dataStorage, &DataStorage::tabLoaded, this
            , [this](const QString &tabID, const QString &searchPattern, const QList<SearchResult> &searchResults)
    {
        auto *restoredTab = new SearchJobWidget(tabID, searchPattern, searchResults, app(), this);
        addTab(tabID, restoredTab);
    });

    connect(m_dataStorage, &DataStorage::sessionLoaded, this, [this](const SessionData &sessionData)
    {
        m_ui->tabWidget->setCurrentWidget(m_tabWidgets.value(sessionData.currentTabID));
    });

    QMetaObject::invokeMethod(m_dataStorage, [this] { m_dataStorage->loadSession(m_storeOpenedTabsResults); });
}

void SearchWidget::selectActivePage()
{
    if (SearchPluginManager::instance()->allPlugins().isEmpty())
    {
        m_ui->stackedPages->setCurrentWidget(m_ui->emptyPage);
        m_ui->lineEditSearchPattern->setEnabled(false);
        m_ui->comboCategory->setEnabled(false);
        m_ui->selectPlugin->setEnabled(false);
        m_ui->searchButton->setEnabled(false);
    }
    else
    {
        m_ui->stackedPages->setCurrentWidget(m_ui->searchPage);
        m_ui->lineEditSearchPattern->setEnabled(true);
        m_ui->comboCategory->setEnabled(true);
        m_ui->selectPlugin->setEnabled(true);
        m_ui->searchButton->setEnabled(true);
    }
}

SearchWidget::~SearchWidget()
{
    qDebug("Search destruction");
    delete m_ui;
}

void SearchWidget::currentTabChanged(const int index)
{
    // when we switch from a tab that is not empty to another that is empty
    // the download button doesn't have to be available
    m_currentSearchTab = (index >= 0)
        ? static_cast<SearchJobWidget *>(m_ui->tabWidget->widget(index))
        : nullptr;

    if (!m_currentSearchTab)
        m_isNewQueryString = true;

    if (!m_isNewQueryString)
        m_ui->lineEditSearchPattern->setText(m_currentSearchTab->searchPattern());

    adjustSearchButton();
}

void SearchWidget::selectMultipleBox([[maybe_unused]] const int index)
{
    const auto itemText = m_ui->selectPlugin->itemData(m_ui->selectPlugin->currentIndex()).toString();
    if (itemText == u"multi")
        pluginsButtonClicked();
}

void SearchWidget::toggleFocusBetweenLineEdits()
{
    if (m_ui->lineEditSearchPattern->hasFocus() && m_currentSearchTab)
    {
        m_currentSearchTab->lineEditSearchResultsFilter()->setFocus();
        m_currentSearchTab->lineEditSearchResultsFilter()->selectAll();
    }
    else
    {
        m_ui->lineEditSearchPattern->setFocus();
        m_ui->lineEditSearchPattern->selectAll();
    }
}

void SearchWidget::adjustSearchButton()
{
    if (!m_isNewQueryString
            && (m_currentSearchTab && (m_currentSearchTab->status() == SearchJobWidget::Status::Ongoing)))
    {
        if (m_ui->searchButton->isVisible())
        {
            m_ui->searchButton->hide();
            m_ui->stopButton->show();
        }
    }
    else
    {
        if (m_ui->stopButton->isVisible())
        {
            m_ui->stopButton->hide();
            m_ui->searchButton->show();
        }
    }
}

void SearchWidget::showTabMenu(const int index)
{
    QMenu *menu = new QMenu(this);

    if (auto *searchJobWidget = static_cast<SearchJobWidget *>(m_ui->tabWidget->widget(index));
            searchJobWidget->status() != SearchJobWidget::Status::Ongoing)
    {
        menu->addAction(tr("Refresh"), this, [this, searchJobWidget] { refreshTab(searchJobWidget); });
    }
    else
    {
        menu->addAction(tr("Stop"), this, [searchJobWidget] { searchJobWidget->cancelSearch(); });
    }

    menu->addSeparator();
    menu->addAction(tr("Close tab"), this, [this, index] { closeTab(index); });
    menu->addAction(tr("Close all tabs"), this, &SearchWidget::closeAllTabs);

    menu->setAttribute(Qt::WA_DeleteOnClose);
    menu->popup(QCursor::pos());
}

void SearchWidget::pluginsButtonClicked()
{
    auto *dlg = new PluginSelectDialog(SearchPluginManager::instance(), this);
    dlg->setAttribute(Qt::WA_DeleteOnClose);
    dlg->show();
}

void SearchWidget::searchTextEdited(const QString &text)
{
    if (m_currentSearchTab)
    {
        m_isNewQueryString = m_currentSearchTab->searchPattern() != text;
        adjustSearchButton();
    }
}

void SearchWidget::giveFocusToSearchInput()
{
    m_ui->lineEditSearchPattern->setFocus();
}

// Function called when we click on search button
void SearchWidget::searchButtonClicked()
{
    m_isNewQueryString = false;

    const QString pattern = m_ui->lineEditSearchPattern->text().trimmed();
    // No search pattern entered
    if (pattern.isEmpty())
    {
        QMessageBox::critical(this, tr("Empty search pattern"), tr("Please type a search pattern first"));
        return;
    }

    if (!Utils::ForeignApps::pythonInfo().isValid())
    {
        app()->desktopIntegration()->showNotification(tr("Search Engine"), tr("Please install Python to use the Search Engine."));
        return;
    }

    qDebug("Search with category: %s", qUtf8Printable(selectedCategory()));

    // Launch search
    auto *searchHandler = SearchPluginManager::instance()->startSearch(pattern, selectedCategory(), selectedPlugins());

    // Tab Addition
    const QString newTabID = generateTabID();
    auto *newTab = new SearchJobWidget(newTabID, searchHandler, app(), this);
    const int tabIndex = addTab(newTabID, newTab);
    m_ui->tabWidget->setTabToolTip(tabIndex, newTab->statusTip());
    m_ui->tabWidget->setTabIcon(tabIndex, UIThemeManager::instance()->getIcon(statusIconName(newTab->status())));
    m_ui->tabWidget->setCurrentWidget(newTab);
    adjustSearchButton();
    updateHistory(pattern);
    saveSession();
}

void SearchWidget::stopButtonClicked()
{
    m_currentSearchTab->cancelSearch();
}

void SearchWidget::tabStatusChanged(SearchJobWidget *tab)
{
    const int tabIndex = m_ui->tabWidget->indexOf(tab);
    m_ui->tabWidget->setTabToolTip(tabIndex, tab->statusTip());
    m_ui->tabWidget->setTabIcon(tabIndex, UIThemeManager::instance()->getIcon(
            statusIconName(static_cast<SearchJobWidget *>(tab)->status())));

    if (tab->status() != SearchJobWidget::Status::Ongoing)
    {
        if (tab == m_currentSearchTab)
            adjustSearchButton();

        emit searchFinished(tab->status() == SearchJobWidget::Status::Error);

        if (m_storeOpenedTabsResults)
        {
            QMetaObject::invokeMethod(m_dataStorage, [this, tabID = tab->id(), searchResults = tab->searchResults()]
            {
                m_dataStorage->storeTab(tabID, searchResults);
            });
        }
    }
}

void SearchWidget::closeTab(const int index)
{
    const auto *tab = static_cast<SearchJobWidget *>(m_ui->tabWidget->widget(index));
    const QString tabID = tab->id();
    delete m_tabWidgets.take(tabID);

    QMetaObject::invokeMethod(m_dataStorage, [this, tabID] { m_dataStorage->removeTab(tabID); });
    saveSession();
}

void SearchWidget::closeAllTabs()
{
    for (int tabIndex = (m_ui->tabWidget->count() - 1); tabIndex >= 0; --tabIndex)
    {
        const auto *tab = static_cast<SearchJobWidget *>(m_ui->tabWidget->widget(tabIndex));
        const QString tabID = tab->id();
        delete m_tabWidgets.take(tabID);
        QMetaObject::invokeMethod(m_dataStorage, [this, tabID] { m_dataStorage->removeTab(tabID); });
    }

    saveSession();
}

void SearchWidget::refreshTab(SearchJobWidget *searchJobWidget)
{
    if (!Utils::ForeignApps::pythonInfo().isValid())
    {
        app()->desktopIntegration()->showNotification(tr("Search Engine"), tr("Please install Python to use the Search Engine."));
        return;
    }

    // Re-launch search
    auto *searchHandler = SearchPluginManager::instance()->startSearch(searchJobWidget->searchPattern(), selectedCategory(), selectedPlugins());
    searchJobWidget->assignSearchHandler(searchHandler);
}

void SearchWidget::DataStorage::loadSession(const bool withSearchResults)
{
    const Path sessionFilePath = makeDataFilePath(SESSION_FILE_NAME);
    const auto loadResult = ::loadSession(sessionFilePath);
    if (!loadResult)
    {
        LogMsg(tr("Failed to load Search UI saved state data. File: \"%1\". Error: \"%2\"")
                .arg(sessionFilePath.toString(), loadResult.error()), Log::WARNING);
        return;
    }

    const SessionData &sessionData = loadResult.value();

    for (const auto &[tabID, searchPattern] : sessionData.tabs)
    {
        QList<SearchResult> searchResults;

        if (withSearchResults)
        {
            const Path tabStateFilePath = makeDataFilePath(tabID + u".json");
            if (const auto loadTabStateResult = loadSearchResults(tabStateFilePath))
            {
                searchResults = loadTabStateResult.value();
            }
            else
            {
                LogMsg(tr("Failed to load saved search results. Tab: \"%1\". File: \"%2\". Error: \"%3\"")
                        .arg(searchPattern, tabStateFilePath.toString(), loadTabStateResult.error()), Log::WARNING);
            }
        }

        emit tabLoaded(tabID, searchPattern, searchResults);
    }

    emit sessionLoaded(sessionData);
}

void SearchWidget::DataStorage::storeSession(const SessionData &sessionData)
{
    QJsonArray tabsList;
    for (const auto &[tabID, searchPattern] : sessionData.tabs)
    {
        const QJsonObject tabObj {
            {u"ID"_s, tabID},
            {u"SearchPattern"_s, searchPattern}
        };
        tabsList.append(tabObj);
    }

    const QJsonObject sessionObj {
        {u"Tabs"_s, tabsList},
        {u"CurrentTab"_s, sessionData.currentTabID}
    };

    const Path sessionFilePath = makeDataFilePath(SESSION_FILE_NAME);
    const auto saveResult = Utils::IO::saveToFile(sessionFilePath, QJsonDocument(sessionObj).toJson(QJsonDocument::Compact));
    if (!saveResult)
    {
        LogMsg(tr("Failed to save Search UI state. File: \"%1\". Error: \"%2\"")
                .arg(sessionFilePath.toString(), saveResult.error()), Log::WARNING);
    }
}

void SearchWidget::DataStorage::removeSession()
{
    Utils::Fs::removeFile(makeDataFilePath(SESSION_FILE_NAME));
}

void SearchWidget::DataStorage::storeTab(const QString &tabID, const QList<SearchResult> &searchResults)
{
    QJsonArray searchResultsArray;
    for (const SearchResult &searchResult : searchResults)
    {
        searchResultsArray.append(QJsonObject {
            {KEY_RESULT_FILENAME, searchResult.fileName},
            {KEY_RESULT_FILEURL, searchResult.fileUrl},
            {KEY_RESULT_FILESIZE, searchResult.fileSize},
            {KEY_RESULT_SEEDERSCOUNT, searchResult.nbSeeders},
            {KEY_RESULT_LEECHERSCOUNT, searchResult.nbLeechers},
            {KEY_RESULT_ENGINENAME, searchResult.engineName},
            {KEY_RESULT_SITEURL, searchResult.siteUrl},
            {KEY_RESULT_DESCRLINK, searchResult.descrLink},
            {KEY_RESULT_PUBDATE, Utils::DateTime::toSecsSinceEpoch(searchResult.pubDate)}
        });
    }

    const Path filePath = makeDataFilePath(tabID + u".json");
    const auto saveResult = Utils::IO::saveToFile(filePath, QJsonDocument(searchResultsArray).toJson(QJsonDocument::Compact));
    if (!saveResult)
    {
        LogMsg(tr("Failed to save search results. Tab: \"%1\". File: \"%2\". Error: \"%3\"")
                .arg(tabID, filePath.toString(), saveResult.error()), Log::WARNING);
    }
}

void SearchWidget::DataStorage::removeTab(const QString &tabID)
{
    Utils::Fs::removeFile(makeDataFilePath(tabID + u".json"));
}

void SearchWidget::DataStorage::loadHistory()
{
    const Path historyFilePath = makeDataFilePath(HISTORY_FILE_NAME);
    const auto loadResult = ::loadHistory(historyFilePath);
    if (!loadResult)
    {
        LogMsg(tr("Failed to load Search UI history. File: \"%1\". Error: \"%2\"")
                .arg(historyFilePath.toString(), loadResult.error()), Log::WARNING);
        return;
    }

    emit historyLoaded(loadResult.value());
}

void SearchWidget::DataStorage::storeHistory(const QStringList &history)
{
    const Path filePath = makeDataFilePath(HISTORY_FILE_NAME);
    const auto saveResult = Utils::IO::saveToFile(filePath, history.join(u'\n').toUtf8());
    if (!saveResult)
    {
        LogMsg(tr("Failed to save search history. File: \"%1\". Error: \"%2\"")
                .arg(filePath.toString(), saveResult.error()), Log::WARNING);
    }
}

void SearchWidget::DataStorage::removeHistory()
{
    Utils::Fs::removeFile(makeDataFilePath(HISTORY_FILE_NAME));
}

#include "searchwidget.moc"
</file>

<file path="gui/search/searchwidget.h">
/*
 * Bittorrent Client using Qt and libtorrent.
 * Copyright (C) 2015-2025  Vladimir Golovnev <glassez@yandex.ru>
 * Copyright (C) 2020, Will Da Silva <will@willdasilva.xyz>
 * Copyright (C) 2006  Christophe Dumez <chris@qbittorrent.org>
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 *
 * In addition, as a special exception, the copyright holders give permission to
 * link this program with the OpenSSL project's "OpenSSL" library (or with
 * modified versions of it that use the same license as the "OpenSSL" library),
 * and distribute the linked executables. You must obey the GNU General Public
 * License in all respects for all of the code used other than "OpenSSL".  If you
 * modify file(s), you may extend this exception to your version of the file(s),
 * but you are not obligated to do so. If you do not wish to do so, delete this
 * exception statement from your version.
 */

#pragma once

#include <QPointer>
#include <QSet>
#include <QWidget>

#include "base/utils/thread.h"
#include "gui/guiapplicationcomponent.h"

class QEvent;
class QObject;
class QStringListModel;

class SearchJobWidget;

namespace Ui
{
    class SearchWidget;
}

class SearchWidget : public GUIApplicationComponent<QWidget>
{
    Q_OBJECT
    Q_DISABLE_COPY_MOVE(SearchWidget)

public:
    explicit SearchWidget(IGUIApplication *app, QWidget *parent);
    ~SearchWidget() override;

    void giveFocusToSearchInput();

signals:
    void searchFinished(bool failed);

private:
    bool eventFilter(QObject *object, QEvent *event) override;

    void onPreferencesChanged();

    void pluginsButtonClicked();
    void searchButtonClicked();
    void stopButtonClicked();
    void searchTextEdited(const QString &text);
    void currentTabChanged(int index);

    void tabStatusChanged(SearchJobWidget *tab);

    void closeTab(int index);
    void closeAllTabs();
    void refreshTab(SearchJobWidget *searchJobWidget);
    void showTabMenu(int index);

    void selectMultipleBox(int index);
    void toggleFocusBetweenLineEdits();
    void adjustSearchButton();

    void fillCatCombobox();
    void fillPluginComboBox();
    void selectActivePage();

    QString selectedCategory() const;
    QStringList selectedPlugins() const;

    QString generateTabID() const;
    int addTab(const QString &tabID, SearchJobWidget *searchJobWdget);

    void loadHistory();
    void restoreSession();
    void updateHistory(const QString &newSearchPattern);
    void saveSession() const;

    void createSearchPatternCompleter();

    Ui::SearchWidget *m_ui = nullptr;
    QPointer<SearchJobWidget> m_currentSearchTab; // Selected tab
    bool m_isNewQueryString = false;
    QHash<QString, SearchJobWidget *> m_tabWidgets;

    bool m_storeOpenedTabs = false;
    bool m_storeOpenedTabsResults = false;
    int m_historyLength = 0;

    Utils::Thread::UniquePtr m_ioThread;

    class DataStorage;
    DataStorage *m_dataStorage = nullptr;

    QStringListModel *m_searchPatternCompleterModel = nullptr;
};
</file>

<file path="gui/search/searchwidget.ui">
<?xml version="1.0" encoding="UTF-8"?>
<ui version="4.0">
 <class>SearchWidget</class>
 <widget class="QWidget" name="SearchWidget">
  <property name="geometry">
   <rect>
    <x>0</x>
    <y>0</y>
    <width>843</width>
    <height>669</height>
   </rect>
  </property>
  <property name="windowTitle">
   <string>Search</string>
  </property>
  <layout class="QVBoxLayout" name="verticalLayout_3">
   <item>
    <layout class="QHBoxLayout" name="searchBarLayout">
     <item>
      <widget class="LineEdit" name="lineEditSearchPattern"/>
     </item>
     <item>
      <widget class="QComboBox" name="comboCategory">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QComboBox" name="selectPlugin">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="searchButton">
       <property name="sizePolicy">
        <sizepolicy hsizetype="Minimum" vsizetype="Preferred">
         <horstretch>0</horstretch>
         <verstretch>0</verstretch>
        </sizepolicy>
       </property>
       <property name="text">
        <string>Search</string>
       </property>
      </widget>
     </item>
     <item>
      <widget class="QPushButton" name="stopButton">
       <property name="text">
        <string>Stop</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
   <item>
    <widget class="QStackedWidget" name="stackedPages">
     <property name="currentIndex">
      <number>1</number>
     </property>
     <widget class="QWidget" name="emptyPage">
      <layout class="QVBoxLayout" name="verticalLayout">
       <property name="leftMargin">
        <number>0</number>
       </property>
       <property name="topMargin">
        <number>0</number>
       </property>
       <property name="rightMargin">
        <number>0</number>
       </property>
       <property name="bottomMargin">
        <number>0</number>
       </property>
       <item>
        <widget class="QLabel" name="label">
         <property name="text">
          <string>There aren't any search plugins installed.
Click the &quot;Search plugins...&quot; button at the bottom right of the window to install some.</string>
         </property>
         <property name="alignment">
          <set>Qt::AlignmentFlag::AlignCenter</set>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
     <widget class="QWidget" name="searchPage">
      <layout class="QVBoxLayout" name="verticalLayout_2">
       <property name="leftMargin">
        <number>0</number>
       </property>
       <property name="topMargin">
        <number>0</number>
       </property>
       <property name="rightMargin">
        <number>0</number>
       </property>
       <property name="bottomMargin">
        <number>0</number>
       </property>
       <item>
        <widget class="QTabWidget" name="tabWidget">
         <property name="tabsClosable">
          <bool>true</bool>
         </property>
         <property name="movable">
          <bool>true</bool>
         </property>
        </widget>
       </item>
      </layout>
     </widget>
    </widget>
   </item>
   <item>
    <layout class="QHBoxLayout" name="layout2">
     <item>
      <spacer name="spacer2">
       <property name="orientation">
        <enum>Qt::Orientation::Horizontal</enum>
       </property>
       <property name="sizeHint" stdset="0">
        <size>
         <width>0</width>
         <height>0</height>
        </size>
       </property>
      </spacer>
     </item>
     <item>
      <widget class="QPushButton" name="pluginsButton">
       <property name="text">
        <string>Search plugins...</string>
       </property>
      </widget>
     </item>
    </layout>
   </item>
  </layout>
 </widget>
 <customwidgets>
  <customwidget>
   <class>LineEdit</class>
   <extends>QLineEdit</extends>
   <header>gui/lineedit.h</header>
  </customwidget>
 </customwidgets>
 <resources/>
 <connections/>
</ui>
</file>

</files>
